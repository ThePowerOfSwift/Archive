#include "MetronomeClick.js"#include "MetronomeMarking.js"#include "conversions.js"function Metronome(left, altitude, g, agogicPrototype, depth, group) {    //this.g = curGraph.g;        // Agogic prototype contains: array of beat units, subdivision, beatScale, tempo (scale)         this.left = left;    this.altitude = altitude;    this.g = g;    this.tempo = agogicPrototype.tempo;    this.subdivision = agogicPrototype.subdivision;    this.beatScale = agogicPrototype.beatScale;    this.tempoScale = agogicPrototype.tempoScale;    this.beatStructure = agogicPrototype.beatStructure;        this.tempo = agogicPrototype.tempo;    this.depth = depth;        this.lightColor = tupletColor[this.depth].lightColor;    this.darkColor = tupletColor[this.depth].darkColor;        this.strokeWidth = 0.66 * this.g;    this.color = gray[50];        // Add current group to parent group    this.group = group.groupItems.add();        $.writeln("Metronome: " + curBeamGroup.withTempo);    // Draw metronome marking    if (curBeamGroup.withTempo === true) this.metronomeMarking();        // Draw clicks and lines as necessary    this.clicks();  }Metronome.prototype.metronomeMarking = function() {        var altitude = curTupletBracket.altitude + curTupletBracket.dir_vert * (            curTupletBracket.height + 0.382 * this.g);    // Eek: accomodate for height, clean UP!!!    if (curTupletBracket.dir_vert === -1) altitude -= 2 * this.g;    var metronomeMarking = new MetronomeMarking(            this.left,        altitude,        this.g,        this.tempo,        this.subdivision,        this.depth,        this.group    );  };Metronome.prototype.clicks = function() {        // Begin at left point of metronome    this.x = this.left;        // Iterate through all of the larger scale subdivisions    for (var s = 0; s < this.beatStructure.length; s ++) {                var curSubdivision = this.beatStructure[s];        if (curSubdivision.length === 1 && curSubdivision[0] === 3) {            this.declareOrdLine();            this.addOrdLinePoint(this.x);            this.addOrdLinePoint(                this.x + curScore.beat_width * this.beatScale *                 8 * 2 / this.subdivision            );        };                // Iterate through each beat unit (either 2 or 3)        for (var c = 0; c < curSubdivision.length; c ++) {                        // If first click in subdivision            if (c === 0) {                                // Declare new ord line                this.declareOrdLine();                                // Add point to new line at current x val                this.addOrdLinePoint(this.x);                                // If first click of a non-first subdivision                if (s !== 0) {                                        // Add point to dashed line                    this.addDashedLinePoint(this.x);                };              }            // If last click in subdivision            else if (c === curSubdivision.length - 1) {                                if (curSubdivision[c] === 2) {                                        // Add point to new line at current x val                    this.addOrdLinePoint(this.x);                }                // Extend line to third click in 3-beat                else if (curSubdivision[c] === 3) {                                        this.addOrdLinePoint(                        this.x + curScore.beat_width * this.beatScale *                         8 * 2 / this.subdivision                    );                };                                // If not last click in last subdivision                if (s !== this.beatStructure.length - 1) {                                        // Declare dashed line                    this.declareDashedLine();                                        if (curSubdivision[c] === 2) {                                                // Add point to dashed line                        this.addDashedLinePoint(this.x);                    }                    // Start dashed line on 3rd beat of 3-beat                      else if (curSubdivision[c] === 3) {                                                this.addDashedLinePoint(                            this.x + curScore.beat_width * this.beatScale *                            8 * 2 / this.subdivision                        );                    };                };            };                        var curClick = curSubdivision[c];                        // Draw click            var click = new MetronomeClick(                                this.x,                this.altitude,                this.g,                curClick,                this.subdivision,                this.depth,                this.group            );            // For triangle            if (curClick === 3) {                //$.writeln("triangle; subdivision: " + this.subdivision);                var curClickX = this.x + curScore.beat_width *                         this.beatScale * 8 / this.subdivision;                for (var d = 0; d < 2; d ++) {                    var nextSubdClick = new MetronomeClick(                        curClickX,                        this.altitude,                        this.g,                        2,                        this.subdivision * 2,                        this.depth,                        this.group                    );                    curClickX += curScore.beat_width *                         this.beatScale * 8 / this.subdivision;                }            }                        // Advance position            this.x += curScore.beat_width *                 this.beatScale * curClick * 8 / this.subdivision;        };    };}Metronome.prototype.declareOrdLine = function() {        // Vary strokeWidth based on subdivision level    var strokeWidth = (0.25 * this.g) / subdToLevel(this.subdivision);        // Declare ordLine    this.ordLine = this.group.pathItems.add();    this.ordLine.strokeWidth = strokeWidth;    this.ordLine.strokeColor = this.lightColor;    this.ordLine.fillColor = this.lightColor;};Metronome.prototype.addOrdLinePoint = function(x) {        // Draw ord line point at current location    var ordLinePoint = this.ordLine.pathPoints.add();    ordLinePoint.anchor = [x, this.altitude];    ordLinePoint.leftDirection = ordLinePoint.anchor;    ordLinePoint.rightDirection = ordLinePoint.anchor;};Metronome.prototype.declareDashedLine = function() {    // Vary strokeWidth based on subdivision level    var strokeWidth = (0.25 * this.g) / subdToLevel(this.subdivision);    // Vary dash width based on subdivision level    var strokeDashes = 5 / subdToLevel(this.subdivision);        // Declare dashed line    this.dashedLine = this.group.pathItems.add();    this.dashedLine.strokeWidth = strokeWidth;    this.dashedLine.strokeColor = this.lightColor;    this.dashedLine.filled = false;    this.dashedLine.strokeDashes = [strokeDashes];};Metronome.prototype.addDashedLinePoint = function(x) {        // Add point to dashed line    var dashedLinePoint = this.dashedLine.pathPoints.add();    dashedLinePoint.anchor = [x, this.altitude];    dashedLinePoint.leftDirection = dashedLinePoint.anchor;    dashedLinePoint.rightDirection = dashedLinePoint.anchor;};Metronome.prototype.pickup = function() {        // Increase subdivision level for last beats if next subd > cur subd};Metronome.prototype.recuperate = function() {        // Increase subdivision level for first beats if prev subd > cur subd};