#include "SubdivisionGraphic.js"#include "TupletBracketLigature.js"function TupletBracket(    BeamGroup, graphicalContext, left, altitude, tupletDepth,    spanSum, beats, subdivision, beatStructure,    beatScale, tempo) {        // Establish the things    this.BeamGroup = BeamGroup;    this.graphicalContext = graphicalContext.groupItems.add();    this.left = left || 36;    this.altitude = altitude || 400;    this.stemDirection = this.BeamGroup.stemDirection || 1;    this.tupletDepth = tupletDepth || 0;    this.spanSum = spanSum || 11;    this.beats = beats || 7;    this.subdivision = subdivision || 32;    this.beatScale = beatScale || 1;    this.tempoScale = 1/beatScale;    this.tempo = tempo || 60;    // Do the things    this.graphicalDimensions();    this.graphic();    this.text();    this.bracket();}TupletBracket.prototype.graphicalDimensions = function() {    this.graphicalContext.name = (        this.spanSum + "/" + this.beats + ": " + this.subdivision    );    this.g = this.BeamGroup.g;    this.beatWidth = this.BeamGroup.beatWidth;    this.width = (        (this.beats / this.subdivision) * 8 * this.beatWidth * this.beatScale    );    this.right = this.left + this.width;    this.center = this.left + (0.5 * this.width);    this.padRight = 0.5 * this.g;        this.bracketHeight = 0.85 * this.g;    this.strokeWidth = 0.0809 * this.g;    this.graphicWidth = 0.5 * this.g;    this.graphicPad = 0.382 * this.g;    this.graphicAdjust = (0.5 * this.graphicWidth) + this.graphicPad;};TupletBracket.prototype.getDimensions = function() {};TupletBracket.prototype.graphic = function() {    var x = this.center;    var y = this.altitude + (        this.stemDirection * (this.bracketHeight - 0.1 * this.g)    );    var graphic = new SubdivisionGraphic(this, x, y);};TupletBracket.prototype.text = function() {    var tupletText = [this.spanSum, this.beats];    var font = app.textFonts.getByName("AvenirNextCondensed-Regular");    var color = tupletColor[this.tupletDepth].darkColor;    var textSize = 1.5 * this.g;    var textHeight = 1.25 * textSize;    var vertRef = this.altitude + (this.stemDirection * this.bracketHeight);    var textTop = vertRef + 5 + (20 / textHeight); // this is dirty    var textScale = 0.382 * textSize;    var horizRef = [1, -1];    var justify = [Justification.RIGHT, Justification.LEFT];    this.textWidths = [];    for (var t = 0; t < 2; t ++) {        var left = this.center - (horizRef[t] * this.graphicAdjust);        var text = this.graphicalContext.textFrames.add();        text.contents = tupletText[t];        text.top = textTop;        text.left = left;        text.textRange.paragraphAttributes.justification = justify[t];        text.textRange.characterAttributes.size = textSize;        text.textRange.characterAttributes.fillColor = color;        text.textRange.characterAttributes.textFont = font;        var width = tupletText[t].toString().length * textScale;        this.textWidths.push(width);    };};TupletBracket.prototype.bracket = function() {    var color = tupletColor[this.tupletDepth].lightColor;    var outsideRightDisplace = 0.2 * this.g;    var horizRef = [1, -1];    var xRef = [this.left, this.right - this.padRight];    var yRef = this.altitude;    for (var b = 0; b < 2; b ++) {        var lengths = [            (                (0.5 * this.width) -                 this.graphicAdjust -                 this.graphicPad -                 this.textWidths[b]            ),            (                (0.5 * this.width) -                 this.graphicAdjust -                 this.graphicPad -                 this.textWidths[b] -                 this.padRight            )        ];        var points = [            [                 xRef[b], yRef             ],            [                 xRef[b] - b * outsideRightDisplace,                 yRef + this.stemDirection * this.bracketHeight            ],            [                xRef[b] + horizRef[b] * lengths[b],                yRef + this.stemDirection * this.bracketHeight            ]        ];        if (b === 1 && points[2][0] > points[1][0]) { /* don't draw bracket!*/}        else {            var bracket = this.graphicalContext.pathItems.add();            bracket.setEntirePath(points);            bracket.strokeWidth = this.strokeWidth;            bracket.strokeColor = color;            bracket.filled = false;        };    };};TupletBracket.prototype.ligature = function(x) {    //var graphicalContext = this.BeamGroup.ligatureContext;    var ligature = new TupletBracketLigature(this, x);    return ligature;}