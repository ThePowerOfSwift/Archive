#include "arrayMethods.js"#include "conversions.js"#include "colors.js"#include "json2.js"function rhythmTreeToSpanGroup(beats, subdivision, durList) {    var parentSpan = {};    parentSpan.type = "spanGroup";    parentSpan.beats = beats;    parentSpan.subdivision = subdivision;    parentSpan.beatScale = 1;    parentSpan.tempoScale = 1;    parentSpan.spans = [];    parentSpan.durList = [];    this.traverseTree(durList, parentSpan);    parentSpan.subd_adj = parentSpan.subdivision;    parentSpan.subdLevel_adj = valToSubdLevel(beats, parentSpan.subd_adj);    this.completeSpan(parentSpan);    return parentSpan;}rhythmTreeToSpanGroup.prototype.traverseTree = function(    durList, parentSpan, depth, d, sum) {    // Check if we have already recursed downward, or if we have just started    if (typeof depth === "number") { depth ++ }    else { depth = 0 };        // iterate through all values in current level of array    var sum = 0;    for (var d = 0; d < durList.length; d ++) {        if (typeof durList[d] === "object") {            var beats = durList[d][0];            var newDurList = durList[d][1];            sum += Math.abs(beats);            // Create new parent span group            var childSpan = {};            childSpan.type = "spanGroup";            childSpan.beats = beats;                        // Create array for the next level of embedded spans to be pushed            childSpan.spans = [];                        // Add new beats to old parent?            parentSpan.spans.push(childSpan);                        // recurse downward            this.traverseTree(newDurList, childSpan, depth, d, sum)        }        else if (typeof durList[d] === "number") {            var curDur = durList[d];            var curDurAbs = Math.abs(curDur);            sum += curDurAbs;            var childSpan = {};            if (curDur > 0) { childSpan.type = "event"; }            else { childSpan.type = "rest"; };            childSpan.beats = curDurAbs;            parentSpan.spans.push(childSpan);        }        else if (typeof durList[d] === "string") {            var curDur = parseInt(durList[d]);            var curDurAbs = Math.abs(curDur);            sum += curDurAbs;            var childSpan = {};            if (curDur > 0) {                 childSpan.type = "event";                childSpan.extension = "begin";            }            else { childSpan.type = "extension"; };            childSpan.beats = curDurAbs;            parentSpan.spans.push(childSpan);        };        // IF LAST EVENT        if (d === durList.length - 1) {                    // New adjusted object (with sum, beats, subdivision)            var adjusted = xAdjustY(                sum,                 parentSpan.beats,                 parentSpan.subdivision            );            spanSum_adj = adjusted.spanSum;            beats_adj = adjusted.beats;            parentSpan.spanSum = sum;            parentSpan.spanSum_adj = spanSum_adj;            parentSpan.beats_adj = beats_adj;        };    };  };rhythmTreeToSpanGroup.prototype.completeSpan = function(parentSpan, depth, s) {        // Check if we have already recursed downward, or if we have just started    if (typeof depth === "number") { depth ++; }    else { depth = 0; };    for (s = 0; s < parentSpan.spans.length; s ++) {        var curSpan = parentSpan.spans[s];        var beats = parentSpan.beats;        var beats_adj = parentSpan.beats_adj;        var spanSum_adj = parentSpan.spanSum_adj;        var beatScale = parentSpan.beatScale;        var tempoScale = parentSpan.tempoScale;        var subdivision = parentSpan.subd_adj;        var subdScale = beats_adj/beats;        parentSpan.durList.push(curSpan.beats);                curSpan.subdivision = parentSpan.subdivision * subdScale;        curSpan.beatScale = beatScale * (beats_adj / spanSum_adj);        curSpan.tempoScale = tempoScale * (spanSum_adj / beats_adj);        if (curSpan.type === "event" || curSpan.type === "rest") {            curSpan.subdLevel_adj = valToSubdLevel(curSpan.beats, curSpan.subdivision);        }        else if (curSpan.type === "spanGroup") {            curSpan.durList = [];            curSpan.subd_adj = subdivision * subdScale;            this.completeSpan(curSpan, depth, s);        };    };};rhythmTreeToSpanGroup.prototype.testComponents = function(performerList) {    var components = [];    for (var p = 0; p < performerList.length; p ++) {        var performer = performerList[p];        if (performer === "FL") {            // just sounding            var graphList = ["sounding"];        }        else if (performer === "CL") {            // sounding, fingered            var graphList = ["sounding", "fingered"];            var sounding = {                "performerID": performer,                "instrumentID": performer,                "graphID": "sounding",                "info": {}            };            var fingered = {                "performerID": performer,                "instrumentID": performer,                "graphID": "fingered",                "info": {}            };        }        else if (performer === "VA") {            // sounding, fingered            var sounding = {                "performerID": performer,                "instrumentID": performer,                "graphID": "sounding",                "info": {}            };            var fingered = {                "performerID": performer,                "instrumentID": performer,                "graphID": "fingered",                "info": {}            };            var amountPitches = Math.floor(Math.random()*2 + 1);            var soundingPitchINFO = {};            var fingeredPitchINFO = {};            for (var p = 0; p < amountPitches; p ++) {                var randomPitch = Math.floor(Math.random()*100)/4 + 60;                var soundingPitch = {};                soundingPitch.type = "ord";                soundingPitch.color = gray[50];                var fingeredPitch = {};                fingeredPitch.type = "ord";                fingeredPitch.color = gray[85];                soundingPitchINFO[randomPitch] = soundingPitch;                fingeredPitchINFO[randomPitch + 2] = fingeredPitch;            };            sounding.info = soundingPitchINFO;            fingered.info = fingeredPitchINFO;            components.push(fingered, sounding);        };    };    return components;}