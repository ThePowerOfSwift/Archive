#include "arrayMethods.js"#include "conversions.js"#include "colors.js"#include "TupletBracket.js"#include "AgogicPrototype.js"#include "FING_FL_C.js"function BeamGroup(    Span,    left,     altitude,     stem_direction,    isExpanded,    withTempo,    withMetrics,    withNumerics        ) {     // Call out to everyone, I am current beam group    curBeamGroup = this;    // Initiate array for referenceable beam objects    this.beam = [];        // Inititate array for referenceable beamlet objects    this.beamlet = [];        // For testing only, establish beamGroup group    this.beamGroup = testDoc.groupItems.add();    // Create group for activation / recuperation lines to ensure z-order    this.lineGroup = this.beamGroup.groupItems.add();        // for testing only    this.g = 5;    //this.g = curGraph.g; or this.g = curPlayer.g;    this.beamlet_direction = 1;    this.beam_strokeWidth = 0.33 * this.g;    this.beam_displacement = 0.5 * this.g;    this.beam_padding = 0.225 * this.g;            this.curTupletDepth = 0;    this.tupletGroup_displace = 1.618 * this.g;    this.subdivision = Span.subdivision;    this.beats = Span.beats;    // DEFAULTS ---------------------------------------------------------------    this.left = left || 36;    this.altitude = altitude || 400;    this.stem_direction = stem_direction || 1;    this.isExpanded = isExpanded || false;    this.withTempo = withTempo || false;    this.withMetrics = withMetrics || true;    this.withNumerics = withNumerics || true;    if (this.withMetrics === false || this.withNumerics === false) {        this.beam_strokeWidth = 0.225 * this.g;    };        // GRAPHIC ATTRIBUTES: POSITION    this.width = curScore.beat_width*(this.beats/this.subdivision)*8;    this.center = this.left + .5*this.width;    this.right = this.left + this.width;        // Establish left point as start for horizontal counting    this.x = this.left;        this.stem_direction = stem_direction || 1;    // Begin counter of all events    this.amountEvents = 0;        this.maxTupletDepth = 0;    this.prevDepth = 0;    // Create referenceable array of lowest subdLevel at each depth (expansion)    this.leastSubdLevelAtDepth = [];        // Count events to keep track of progress    this.countEvents(Span);        // Count through total beats in BeamGroup    this.eventCount = 0;        // Establish individual IDs for each Span to differentiate    this.idCount = 0;        // Establish flattened list of events    this.flattened = [];    // Recurse through all events to create flattened list    this.flatten(Span);    // GRAPHIC ATTRIBUTES: DRAWING    this.strokeColor = black;        // Find max tuplet depth    this.tupletDepth(Span);    // Deal with the vertical expansion of tupletBracket (metronome, tempo);    this.expansion(this.isExpanded, this.withTempo);        // Initialize current depth at 0    this.curTupletDepth = 0;        // Calls for the drawing of each spanGroup recursively    this.spanRecurse(Span, this.beamGroup);    // Add metric slash to left side of beamGroup if no metrics    if (this.withMetrics === false || this.withNumerics === false) {        this.slash();    };}BeamGroup.prototype.countEvents = function(Span, s) {        for (s = 0; s < Span.spans.length; s ++) {        var curSpan = Span.spans[s];        if (curSpan.type === "spanGroup") {            // Recurse downward            this.countEvents(curSpan, s);        }        else if (curSpan.type === "rest" || curSpan.type === "event") {            this.amountEvents ++;        };    };};BeamGroup.prototype.tupletDepth = function(Span, depth, s) {        // Check if we have already recursed downward, or if we have just started    if (typeof depth === "number") {                depth ++;        ////t.w("DEPTH: " + depth + ": subdivision: " + Span.spans[0].subdivision);        var localSubdLevel = subdToLevel(Span.spans[0].subdivision);        if (! this.leastSubdLevelAtDepth[depth]) {            this.leastSubdLevelAtDepth[depth] = localSubdLevel        }        else if (localSubdLevel < this.leastSubdLevelAtDepth[depth]) {            this.leastSubdLevelAtDepth[depth] = localSubdLevel;        };        /*// Only if tuplet (not if subdividable)        if (Span.spanSum_adj !== Span.beats_adj) {                        // Increment depth if NOT first instance            depth ++        };*/    }    else {                // Establish depth at zero if first instance        depth = 0;        this.leastSubdLevelAtDepth[0] = subdToLevel(Span.spans[0].subdivision);    };            for (var s = 0; s < Span.spans.length; s ++) {              var curSpan = Span.spans[s];                // Only if current depth is increase over last, re-establish max depth        if (depth > this.prevDepth) this.maxTupletDepth = depth;                // If span is a group of more spans, recurse through those        if (curSpan.type === "spanGroup") {                        // Recurse downward if curSpan is a spanGroup            this.tupletDepth(curSpan, depth, s);                        // Once all is done, set previous depth to current depth            if (depth > this.prevDepth) this.prevDepth = depth;        };     };    return depth;};BeamGroup.prototype.expansion = function(expanded, withTempo) {    this.tupletBracket_displacementAtDepth = [];    this.clickHeightAtDepth = [];        // Populate this.clickHeightAtDepth with appriopriate values    for (var d = 0; d <= this.maxTupletDepth; d ++) {        if (d === this.maxTupletDepth) {            this.tupletBracket_displacementAtDepth[d] = 0;        }        else {            this.tupletBracket_displacementAtDepth[d] = 1.618;        };                if (expanded === true) {            var leastSubdLevel = this.leastSubdLevelAtDepth[d];            var clickHeight = clickHeightBySubdLevel(leastSubdLevel);            this.clickHeightAtDepth[d] = clickHeight;            this.tupletBracket_displacementAtDepth[d] += clickHeight;            this.tupletBracket_displacementAtDepth[d] += 1;                        if (withTempo === true && d < this.maxTupletDepth) {                this.tupletBracket_displacementAtDepth[d] += 1.618;            };        };    };};BeamGroup.prototype.flatten = function(Span, depth, s) {        // Check if we have already recursed downward, or if we have just started    if (typeof depth === "number") depth ++;    else depth = 0;        for (s = 0; s < Span.spans.length; s ++) {                var curSpan = Span.spans[s];            if (curSpan.type === "spanGroup") {                        this.idCount ++;            curSpan.id = this.idCount;                        // Recurse downward            this.flatten(curSpan, depth, s);        }        else if (curSpan.type === "rest" || curSpan.type === "event") {                    curSpan.depth = depth;            curSpan.id = Span.id;            this.flattened.push(curSpan);           };    };};BeamGroup.prototype.spanRecurse = function(    Span,     parentSpanGroup,     bracket,    depth,     s,    id) {        if (typeof depth === "number") {                depth ++;        this.curTupletDepth = depth;        /*// Only if tuplet (not if subdividable)        if (Span.spanSum_adj !== Span.beats_adj) {                        // Increment depth if NOT first instance            depth ++        };*/    }    else {                // Establish depth at zero if first instance        depth = 0;        this.curTupletDepth = depth;    };    //t.w("SPANRECURSE: Span.type: " + Span.type + ": " + Span.beats);        if (Span.type === "spanGroup") {                Span.durList = [];                // Quickly create durList from all spans        for (var s = 0; s < Span.spans.length; s ++) {                        curDur = Span.spans[s].beats            Span.durList.push(curDur);        };                // Create agogic prototype beatStructure        Span.beatStructure = new AgogicPrototype(Span.durList).compoundPrototype;        // Add new group for new level of embedding        var childSpanGroup = parentSpanGroup.groupItems.add();                if (this.withNumerics === true) {            // Draw tuplet bracket for this new spanGroup            this.tupletBracket(childSpanGroup, Span);                        var bracket = curTupletBracket;            this.newBracket = true;            // Check if first span is type: spanGroup or event/rest            if (Span.spans[0].type === "spanGroup") {                                // Draw arrow from higher current bracket to next-lower                bracket.arrow(                    this.x,                     curTupletBracket.altitude - this.stem_direction * 0.5 * this.g,                     this.stem_direction                );            }            else if (Span.spans[0].type === ("event" || "rest")) {                if (depth < this.maxTupletDepth) bracket.line(this.x, "begin");            };                        // Check if last span is type: spanGroup or event/rest            if (Span.spans.last().type === "spanGroup") {                //t.w("last span is spanGroup");            }            // this is gross, consider cleaning?            else if (Span.spans.last().type === ("event" || "rest")) {                ////t.w("last span is event");                if (depth < this.maxTupletDepth) {                    bracket.line(                        curTupletBracket.right - curTupletBracket.paddingRight,                        "end"                    );                };            };        };    };        // Iterate through list of Span.spans array    for (s = 0; s < Span.spans.length; s ++) {                if (s > 0) this.newBracket = false;        var curSpan = Span.spans[s];        //t.w("SPANRECURSE: curSpan.type: " + curSpan.type + ": " + curSpan.beats)        if (curSpan.type === "event" || curSpan.type === "rest") {            // Define horizontal space taken by event            var curBeat_width =                 (curSpan.beats / curSpan.subdivision) * 8 *                (curSpan.beatScale * curScore.beat_width);                        // ONLY SINGLE EVENT BEAMGROUP            if (this.amountEvents === 1) {                            // Declare childSpanGroup within parentSpanGroup                //var childSpanGroup = parentSpanGroup.groupItems.add();                                var min = 0;                var amount = Span.subdLevel_adj;                var direction = 1;                if (this.withMetrics === false) var amount = 1;                            // Call for beamlets as appropriate                this.beamlets(childSpanGroup, this.x, min, amount, direction);            }            // MULTI-EVENT BEAMGROUP            else if (this.amountEvents > 1) {                                // FIRST EVENT ------------------------------------------------                if (this.eventCount === 0) {                                        // Declare this.spanGroup                    //var childSpanGroup = parentSpanGroup.groupItems.add();                                                    // cur and next have attributes: id, depth, subdLevel                    var cur = this.flattened[this.eventCount];                    var next = this.flattened[this.eventCount + 1];                                        this.curTupletDepth = cur.depth;                                        ////t.w("firstEvent.depth: " + cur.depth);                                        cur.subdLevel = cur.subdLevel_adj;                    next.subdLevel = next.subdLevel_adj;                    if (this.withMetrics === true) {                        var beamMin = 0;                        var beamAmount = [                            cur.subdLevel, next.subdLevel                        ].numSort()[0];                        var beamPointAmount = [                            cur.subdLevel, next.subdLevel                        ].numSort()[0];                    }                    else if (this.withMetrics === false) {                        var beamMin = 0;                        var beamAmount = 0;                        var beamPointAmount = 0;                    };                                        // Declare beams as necessary                                       this.beams(childSpanGroup, beamMin, beamAmount);                                        // Call for the drawing of beamPoints as necessary                    this.beamPoints(this.x, beamPointAmount);                                        if (this.withMetrics === true) {                        var beamlet_direction = 1;                                            // Add beamlets as necessary                        if (cur.subdLevel > next.subdLevel) {                                                        // Static beamlet_direction for first event                            this.beamlet_direction = 1;                                                        var beamletMin = next.subdLevel + 1;                            var beamletAmount = cur.subdLevel - beamletMin;                                                        // Call for the drawing of beamlets as appropriate                            this.beamlets(                                childSpanGroup,                                this.x,                                 beamletMin,                                 beamletAmount,                                 beamlet_direction                            );                        };                    };                }                // MIDDLE EVENT -----------------------------------------------                else if (                                        // bypass if only 2 events                    this.amountEvents > 2 &&                                        // not first event                    this.eventCount > 0 &&                                         // not last event                    this.eventCount < this.amountEvents - 1 &&                    // this beamGroup shows metrical time                    this.withMetrics === true) {                                        var prev2 = this.flattened[this.eventCount - 2];                    var prev = this.flattened[this.eventCount - 1];                    var cur = this.flattened[this.eventCount];                    var next = this.flattened[this.eventCount + 1];                                        this.curTupletDepth = cur.depth;                                        // Clean up reference points                    if (this.eventCount > 2) {prev2.subdLevel = prev2.subdLevel_adj}                        //t.w("prev2.subdLevel: " + prev2.subdLevel);                    prev.subdLevel = prev.subdLevel_adj;                    cur.subdLevel = cur.subdLevel_adj;                    next.subdLevel = next.subdLevel_adj;                    // Orders current and adjacent subdivision levels, lo-to-hi                    var subdOrdered = [                        cur.subdLevel,                         prev.subdLevel,                         next.subdLevel                    ].numSort();                    // FIRST IN SPAN ID ---------------------------------------                    if (cur.id !== prev.id && cur.id === next.id) {                        if (cur.depth < prev.depth &&                             this.newBracket === false) {                            // Draw dashed-line up to tupletBracket                            bracket.line(this.x, "reintroduce");                        };                                                // Set beamlet direction for new spanGroup                        this.beamlet_direction = 1;                                                // Before redeclaring beams, continue last spanGroup                        var beamPointAmount = [                            prev.subdLevel, cur.subdLevel                        ].numSort()[0];                        if (this.eventCount > 2 &&                            prev2.subdLevel <= cur.subdLevel) {                            beamPointAmount --;                        };                        //if (cur.subdLevel >= prev.subdLevel) beamPointAmount ++;                        //t.w("beamPointAmount1: " + beamPointAmount);                        //var beamPointAmount = prev.subdLevel;                        this.beamPoints(this.x - this.beam_padding, beamPointAmount);                                                // for testing                        var beamMin = 0;                        var beamAmount = [                            cur.subdLevel, next.subdLevel                        ].numSort()[0];                        this.beams(childSpanGroup, beamMin, beamAmount);                                                // BEAM POINTS ----------------------------------------                        /*var beamPointAmount = [                            cur.subdLevel, next.subdLevel                        ].numSort()[0];*/                        // Add beamPoints as necessary                        this.beamPoints(this.x, beamAmount);                                                // BEAMLETS -------------------------------------------                        if (cur.subdLevel > next.subdLevel) {                                                        var beamletMin = next.subdLevel + 1;                            var beamletAmount = cur.subdLevel - beamletMin;                                                    this.beamlets(                                childSpanGroup,                                 this.x,                                 beamletMin,                                 beamletAmount                            );                        };                    }                                        // CONTINUATION OF SPAN ID --------------------------------                    else if (cur.id === prev.id && cur.id === next.id) {                                                // Set beamlet direction depending on context                        if (next.beats < prev.beats) this.beamlet_direction = 1;                        else this.beamlet_direction = -1;                                                // BEAMS ----------------------------------------------                        if (next.subdLevel > prev.subdLevel) {                                            // Beam declaration amount                            var beamAmount = cur.subdLevel - prev.subdLevel;                                            if (cur.subdLevel > next.subdLevel) {                                beamAmount -= (cur.subdLevel - next.subdLevel);                            };                                            // Beam declaration begins just above previous                            var beamMin = prev.subdLevel + 1;                                                        // Declare beams                            this.beams(childSpanGroup, beamMin, beamAmount);                        };                                                // BEAM POINTS ----------------------------------------                        var beamPointAmount = cur.subdLevel;                                    if (cur.subdLevel > prev.subdLevel &&                             cur.subdLevel > next.subdLevel) {                            beamPointAmount -= (cur.subdLevel - subdOrdered[1]);                        };                                                ////t.w("beamPointAmount: " + beamPointAmount);                                                // Add beam points to appropriate beams                        this.beamPoints(this.x, beamPointAmount);                                                // BEAMLETS -------------------------------------------                        var beamletMin = subdOrdered[1] + 1;                        var beamletAmount = cur.subdLevel - beamletMin;                                                // Add beamlets as necessary                        this.beamlets(                            childSpanGroup,                             this.x,                             beamletMin,                             beamletAmount                        );                      }                                                                                                    // LAST IN SPAN ID ----------------------------------------                    else if (cur.id === prev.id && cur.id !== next.id) {                                                // Set beamlet direction for last event spanGroup                        this.beamlet_direction = -1;                                                // BEAM POINTS ----------------------------------------                        if (this.withMetrics === false) {                            beamPointAmount = 1;                        }                        else {                            var beamPointAmount = [                                cur.subdLevel, prev.subdLevel                            ].numSort()[0];                        }                        this.beamPoints(this.x, beamPointAmount);                                                // BEAMLETS -------------------------------------------                        if (this.withMetrics === true) {                            var beamletMin = prev.subdLevel + 1;                            var beamletAmount = cur.subdLevel - beamletMin;                            this.beamlets(                                childSpanGroup,                                 this.x,                                 beamletMin,                                 beamletAmount                            );                        };                    }                    // SINGLE SPAN ID -----------------------------------------                    else if (cur.id !== prev.id && cur.id !== next.id) {                                                if (cur.depth < prev.depth &&                             this.newBracket === false) {                                                        bracket.line(this.x, "reintroduce");                        };                                                // Before redeclaring beams, continue last spanGroup                        var beamPointAmount = [                                prev.subdLevel,                                cur.subdLevel,                                next.subdLevel                        ].numSort()[0];                                                if (cur.subdLevel === prev.subdLevel) {                            beamPointAmount = prev.subdLevel;                        };                                                //var beamPointAmount = prev.subdLevel;                        this.beamPoints(this.x - .225*this.g, beamPointAmount);                                                // Set beamlet diretion for single event spanGroup                        this.beamlet_direction = 1;                                                // BEAMS ----------------------------------------------                        var beamMin = 0;                        var beamAmount = subdOrdered[2];                                                this.beams(childSpanGroup, beamMin, beamAmount);                                                // BEAM POINTS ----------------------------------------                        var beamPointAmount = cur.subdLevel;                        this.beamPoints(this.x, beamPointAmount);                                                // BEAMLETS -------------------------------------------                        // for now just beamlets                        var beamletMin = 0;                        var beamletAmount = cur.subdLevel;                                                //this.beamlets(this.x, beamletMin, beamletAmount);                    };                }                // LAST EVENT -------------------------------------------------                else if (this.eventCount === this.amountEvents - 1) {                    //t.w("LAST EVENT");                    // Static beamlet direction for last event                    this.beamlet_direction = -1;                                        // Current and adjacent subdivision levels                    var prev = this.flattened[this.eventCount - 1];                    var cur = this.flattened[this.eventCount];                    this.curTupletDepth = cur.depth;                                        if (cur.depth < prev.depth) {                        // Draw dashed-line up to tupletBracket                        bracket.line(this.x, "reintroduce");                    };                                        prev.subdLevel = prev.subdLevel_adj;                    cur.subdLevel = cur.subdLevel_adj;                    // IF SINGLE SPAN EVENT AND LAST EVENT                    if (cur.id !== prev.id) {                        //this.beamlet_direction = 1;                                                // Add beam points to prev beams                        var beamPointAmount = prev.subdLevel;                        this.beamPoints(this.x - this.beam_padding, beamPointAmount);                        // Declare beams as necessary                        var beamMin = 0;                        // Choose the lesser of the current and adjacent subdLevels                        var beamAmount = [                            cur.subdLevel, prev.subdLevel                        ].numSort()[0];                                                // Declare beams as necessary                                           this.beams(childSpanGroup, beamMin, beamAmount);                        var beamPointAmount = beamAmount;                        this.beamPoints(this.x, beamPointAmount);                        /*this.beamPoints(                            this.right - this.beam_padding,                             beamPointAmount                        );*/                    };                    // Establish amount of beams in need of drawing                    var beamPointAmount = cur.subdLevel;                                        if (cur.subdLevel > prev.subdLevel &&                        cur.id === prev.id) {                        var beamPointAmount = prev.subdLevel;                        var beamletMin = prev.subdLevel + 1;                        var beamletAmount = cur.subdLevel - prev.subdLevel - 1;                                                if (this.withMetrics === true) {                            // Add beamlets as necessary                            this.beamlets(                                childSpanGroup,                                 this.x,                                 beamletMin,                                 beamletAmount                            );                        };                    };                                        if (this.withMetrics === false) {                        beamPointAmount = 0;                    };                    // Add beam points to appropriate beams                    this.beamPoints(this.x, beamPointAmount);                };            };            ////t.w("curSpan.type: " + curSpan.type);                    // If substantive event            if (curSpan.type === "event") {                for (var e = 0; e < curSpan.events.length; e ++) {                    var curEvent = curSpan.events[e];                    var curType = curEvent.type;                    var curPlayer = curEvent.player;                    var pitchINFO = curEvent.pitchINFO;                    //t.w(curSystem.stavesByPlayer[curPlayer]);                    var curGraph = curSystem.stavesByPlayer[curPlayer][curType];                    curGraph.pitch(this.x, pitchINFO);                    t.w(curEvent.player + ": " + curEvent.type);                };                //var stemEnd = curGraph.top;                                // RHYTHM TESTING ONLY!                //curGraph.event(this.x);                //this.stem(childSpanGroup, this.x, stemEnd)                /*var pitchINFO = this.testPitches(1);                //t.w("pitchINFO: " + pitchINFO);                curGraph.pitch(this.x, pitchINFO);                var stemEnd;                if (this.stem_direction > 0) stemEnd = curGraph.minNoteheadY;                else stemEnd = curGraph.maxNoteheadY;                */                // for testing only                /*this.stem(                                        childSpanGroup,                     this.x,                    stemEnd                );*/                // TESTING ONLY!                //curGraph.linePoints(this.x);            }            // If rest            else if (curSpan.type === "rest") {                                // Add stemlet                this.stemlet(childSpanGroup, this.x, cur.subdLevel);                                // Add points to current graphs                curGraph.rest(this.x);            };                    if (cur.beats % 3 === 0 && this.withMetrics === true) {                    this.augDot(                        childSpanGroup,                         this.x,                        this.altitude - this.stem_direction * 2 * this.g                    );                };                        // Change all items in group to current color !!!            // perhaps make conditional, also, make possible for individual            // groups within groups not currently present            var darkColor, lightColor;            if (this.withMetrics === false || this.withNumerics === false) {                    darkColor = gray[50];                    lightColor = gray[33];            }            else {                darkColor = tupletColor[cur.depth].darkColor;                lightColor = tupletColor[cur.depth].lightColor;            };            // Set color for all items in tupletSpanID group            for (var i = 0; i < childSpanGroup.pathItems.length; i ++) {                childSpanGroup.pathItems[i].strokeColor = darkColor;                  childSpanGroup.pathItems[i].fillColor = darkColor;            };            // Advance position            this.x += curBeat_width;            this.eventCount ++;                }        else if (curSpan.type === "spanGroup") {                    // RECURSE, pass subdivision values            if (curSpan.spanSum_adj !== curSpan.beats_adj) {                                // Call for the drawing of the tuplet bracket, and related                //this.tupletBracket(curSpan);                                // Increment current tupletDepth for vertical positioning                //this.curTupletDepth ++;            };                    // Recurse downward            this.spanRecurse(curSpan, childSpanGroup, bracket, depth, s, id);        };      };};BeamGroup.prototype.slash = function() {    var slash = this.beamGroup.pathItems.add();    var slash_displace = 1.2 * this.g;    if (this.withMetrics === false || this.withNumerics === false) {        color = gray[75];    }    else {        var color = tupletColor[0].darkColor;    };        slash.setEntirePath([        // Outside point        [            this.left - 0.5 * slash_displace,            this.altitude - this.stem_direction * slash_displace        ],        // Top point        [            this.left + slash_displace,            this.altitude + this.stem_direction * 0.5 * slash_displace        ]    ]);    slash.strokeWidth = 0.125 * this.g;    slash.strokeColor = color;    slash.filled = false;}BeamGroup.prototype.restLine = function() {}BeamGroup.prototype.testPitches = function(amountPitches) {    //var amountPitches = Math.floor(Math.random()*(maxAmount-1) + 2);    var types = ["ord", "harmonic"];    //var amountPitches = Math.round(Math.random()*2 + 1);    var amountPitches = 1;    var pitchINFO = {};    for (var p = 0; p < amountPitches; p ++) {        var randomPitch = Math.floor(Math.random()*100)/4 + 60;        var randomType = types[Math.floor(Math.random()*types.length)];        //t.w("randomType: " + randomType)        //t.w("randomPitch: " + randomPitch);        pitchINFO[randomPitch] = {};        pitchINFO[randomPitch].type = randomType;        pitchINFO[randomPitch].color = gray[50];    };    /*var randFingeringChoice = Math.floor(Math.random()*FING_FL_C.length);    var randFingering = FING_FL_C[randFingeringChoice].pitches;    var pitchINFO = {};    for (var p = 0; p < randFingering.length; p ++) {        var randomType = types[Math.round(Math.random()*types.length)];        var randomPitch = randFingering[p];        pitchINFO[randomPitch] = {};        pitchINFO[randomPitch].type = randomType;    };*/    return pitchINFO;}BeamGroup.prototype.beams = function(group, min, amount) {    // Declare referenceable beam objects    for (var level = min; level <= min + amount; level ++) {        this.beam[level] = group.pathItems.add();        this.beam[level].strokeWidth = this.beam_strokeWidth;        this.beam[level].strokeColor = this.strokeColor;        this.beam[level].filled = false;    };};BeamGroup.prototype.beamPoints = function(x, amount) {        for (var level = 0; level <= amount; level ++) {        var beamPoint = this.beam[level].pathPoints.add();        beamPoint.anchor = [            x,            this.altitude - level*this.beam_displacement*this.stem_direction        ];        beamPoint.leftDirection = beamPoint.anchor;        beamPoint.rightDirection = beamPoint.anchor;    };};BeamGroup.prototype.beamlets = function(group, x, min, amount, direction) {        this.beamlet_length = 0.5 * this.g;        // for testing only    var stemWidth_adjust = 0;    // Declare referenceable beam objects    for (var level = min; level <= min + amount; level ++) {        this.beamlet[level] = 'beamlet' + level;        this.beamlet[level] = group.pathItems.add();        this.beamlet[level].name = "BEAMLET";                this.beamlet[level].setEntirePath([            [                // Horizontal placement                x + stemWidth_adjust,                                // Vertical placement                this.altitude - level*this.beam_displacement*this.stem_direction            ],            [                // Horizontal placement                x + this.beamlet_length*this.beamlet_direction,                                // Vertical placement                this.altitude - level*this.beam_displacement*this.stem_direction            ]        ]);                this.beamlet[level].strokeWidth = this.beam_strokeWidth;        this.beamlet[level].filled = false;    };};BeamGroup.prototype.stem = function(group, x, y) {        var stem = group.pathItems.add();    // Define dimensions of stem    stem.setEntirePath ([        [            x,            this.altitude + .5*this.stem_direction*this.beam_strokeWidth        ],        [            x,            y        ]    ]);        // Set attributes of line    stem.strokeWidth = .0618*this.g; // for testing only!    //stem.strokeColor = tupletColor[this.curTupletDepth].darkColor;    stem.filled = false;};BeamGroup.prototype.stemlet = function(group, x, cur) {    //t.w("STEMLET: cur: " + cur);    var stemlet_length = (this.beam_displacement * cur) + 0.618 * this.g;    var stemlet = group.pathItems.add();        // Define dimensions of stemlet    stemlet.setEntirePath([        [            x,            this.altitude + this.stem_direction * 0.5 * this.beam_strokeWidth        ],        [            x,            this.altitude - this.stem_direction*stemlet_length        ]    ]);        // Set attributes for line    stemlet.strokeWidth = .0618*this.g; // for testing only    stemlet.strokeColor = this.strokeColor;    stemlet.filled = false;};BeamGroup.prototype.augDot = function(group, x, y) {        var diameter = 0.2 * this.g;    var displacement = 0.5 * this.g;        var augDot = group.pathItems.ellipse(                y + (0.5 * diameter),        x + displacement - (0.5 * diameter),        diameter,        diameter    );        augDot.strokeWidth = 0;};BeamGroup.prototype.tupletBracket = function(group, Span) {        ////t.w("tupletBracket; Span.beatStructure: " + Span.beatStructure);        var n = Span.spanSum_adj;    var d = Span.beats_adj;        var subdivision = Span.subd_adj;        //var beatStructure = Span.beatStructure;    ////t.w("BEAM GROUP: Span.beatStructure" + Span.beatStructure);    var beatStructure = Span.beatStructure;                  var subdScale = Span.beats_adj/Span.beats;    var subdForBeams = Span.subd_adj * subdScale;    var amountBeams = subdToLevel(subdForBeams);    var beatScale = Span.beatScale;         ////t.w(".tupletBracket; beatScale: " + beatScale);    var tempoScale = Span.tempoScale;    var tempo = 60 * tempoScale;        ////t.w("tupletBracket; tempo: " + tempo)         var left = this.x;    var width = (Span.beats/Span.subdivision) * 8 *                     Span.beatScale * curScore.beat_width;    // Default tupletBracket altitude_displacement from beams    if (this.isExpanded === false) var altitude_displacement = 0.5;    else var altitude_displacement = 0;    for (var depth = this.maxTupletDepth; depth >= this.curTupletDepth; depth --) {        altitude_displacement += this.tupletBracket_displacementAtDepth[depth];    };    var altitude = this.altitude +         (this.stem_direction * altitude_displacement * this.g);                var dir_vert = this.stem_direction;        // Call for the drawing of a new tuplet bracket    var tupletBracket = new TupletBracket(        group,        n,        d,        beatStructure,        subdivision,        amountBeams,        beatScale,        tempoScale,        tempo,        left,        width,        altitude,        dir_vert    );};BeamGroup.prototype.interrupt = function() {        // What information is needed? Interrupting/interrupted.        // Dashed lines (), hooks, hash-lines (black)};