#include "TupletBracketGraphic.js"function MetronomeMarking(x, y, g, tempo, subdivision, depth, group) {        this.x = x;    this.y = y;    this.g = g;    this.tempo = tempo;    this.height = 2 * this.g;    this.subdivision = subdivision;    this.depth = depth;        this.lightColor = tupletColor[depth].lightColor;    this.darkColor = tupletColor[depth].darkColor;        this.graphicWidth = 0.5 * this.g;    this.padding = 0.3 * this.g;        // Add group to add items    this.group = group.groupItems.add();    // Add background before anything, though wait to define dimensions    this.background = this.group.pathItems.add();        // Draw text    this.text();    this.drawBackground();        // Draw tuplet bracket graphic    this.tupletBracketGraphic();        // Draw bracket    this.bracket();}MetronomeMarking.prototype.drawBackground = function() {    this.background.setEntirePath([        [            // top left            this.x - (0.618 * 0.5 * this.textWidth),            this.y + this.height        ],        [            this.x + 0.5*this.textWidth + 2.5*this.padding + this.graphicWidth,            this.y + this.height        ],        [            this.x + 0.5*this.textWidth + 2.5*this.padding + this.graphicWidth,            this.y - 0.2 * this.g        ],        [            this.x - (0.618 * 0.5 * this.textWidth),            this.y - 0.2 * this.g        ]    ]);    this.background.stroked = false;    this.background.fillColor = white;    this.background.closed = true;}MetronomeMarking.prototype.text = function() {        var tempoRaw = this.tempo;    var tempoRounded = Math.round(tempoRaw);        var textSize = 1.875 * this.g;    var textScale = 0.5 * textSize;    var font = app.textFonts.getByName("Baskerville-SemiBold");    var color = this.darkColor;        this.textWidth = tempoRounded.toString().length * textScale;    this.amountOnesInTempoRounded = 0;    var tracking = 0;    for (var t = 0; t < tempoRounded.toString().length; t ++) {        if (tempoRounded.toString()[t] === "1") {            this.amountOnesInTempoRounded ++;            tracking -= 33;        };    };    var tempoText = this.group.textFrames.add();    tempoText.contents = tempoRounded;    tempoText.top = this.y + (1.3 * textSize);    tempoText.left = this.x;    tempoText.textRange.paragraphAttributes.justification = Justification.CENTER;    tempoText.textRange.characterAttributes.size = textSize;    tempoText.textRange.characterAttributes.fillColor = color;    tempoText.textRange.characterAttributes.textFont = font;    tempoText.textRange.characterAttributes.tracking = tracking;        // If tempo is fractional, draw ca. indication    if (tempoRounded !== tempoRaw) this.ca();};MetronomeMarking.prototype.ca = function() {        var textSize = 0.8 * this.g;    var textScale = 0.382 * textSize;    var font = app.textFonts.getByName("Baskerville");    var color = this.darkColor;    var left = (        this.x -         (0.5 * this.textWidth) -         (0.5 * this.padding)    );    if (this.amountOnesInTempoRounded > 0) left += 0.25 * this.g;    var caText = this.group.textFrames.add();    caText.contents = "ca.";    caText.top = this.y + (3.2 * this.g);    caText.left = left;    caText.textRange.paragraphAttributes.justification = Justification.RIGHT;    caText.textRange.characterAttributes.size = textSize;    caText.textRange.characterAttributes.fillColor = color;    caText.textRange.characterAttributes.textFont = font;}MetronomeMarking.prototype.tupletBracketGraphic = function() {        var amountBeams = subdToLevel(this.subdivision);        // Draw tupletBracketGraphic    var tupletBracketGraphic = new TupletBracketGraphic(        this.x + (0.5 * (this.textWidth + this.graphicWidth)) + this.padding,        this.y + (1 * this.g),        this.g,        1, // always positive direction?        amountBeams,        this.group    );};MetronomeMarking.prototype.bracket = function() {        var bracket = this.group.pathItems.add();    this.top = this.y + this.height;    this.bottom = this.y;    this.left = this.x - (0.382 * this.textWidth);    this.right = this.x + (0.5*this.textWidth) + (2.5*this.padding) + this.graphicWidth;        bracket.setEntirePath([        [            // Bottom, just left-of-center            this.left,            this.bottom        ],        [            // Bottom, right             this.right,            this.bottom        ],        [            // Top, right            this.right,            this.top        ]    ]);        bracket.strokeWidth = 0.15 * this.g;    bracket.strokeColor = this.lightColor;    bracket.filled = false;    bracket.strokeJoin = StrokeJoin.BEVELENDJOIN;    bracket.strokeCap = StrokeCap.ROUNDENDCAP;    var textLeftBoundary = (        curTupletBracket.center -         curTupletBracket.textWidths[0] -         (1.75 * curTupletBracket.graphicAdjust)    );    // if within center text region, no square, adjust lineEnd, horiz line    if (this.right > textLeftBoundary) {        var textLeftPadding = 0.2 * this.g;        this.group.translate(textLeftBoundary - this.right - textLeftPadding);    };};