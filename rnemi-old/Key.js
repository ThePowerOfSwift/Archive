function Key() {}// Shared methods (state types) for all keysKey.prototype.active = function() {		this.key.strokeWidth = curDiagram.strokeWidth;	this.key.strokeColor = black;	this.key.fillColor = gray[50];}Key.prototype.idle = function() {		this.key.strokeWidth = curDiagram.strokeWidth;	this.key.strokeColor = gray[66];	this.key.fillColor = white;}Key.prototype.trill = function() {		// COPY CURRENT SHAPE?; strokeColor, fillColor	// strokeColor, fillColor	// re-call current shape at displaced curX?	// initiate trill tail?}function CircleKey(x, y, d) {		// Inherit attributes and methods from parent Key object	this.f = curDiagram.f;	Key.call(this);	this.x = x;	this.y = y;	this.d = d;		// Set dimensions of circle	this.key = fingeringDiagramGroup.pathItems.ellipse(			y + .5*d,		x - .5*d,		d,		d	);}// Inherit attributes and methods from parent Key objectCircleKey.prototype = new Key();CircleKey.prototype.half = function() {		this.key.strokeWidth = curDiagram.strokeWidth;	this.key.strokeColor = black;	this.key.fillColor = white;		this.halfCircle = fingeringDiagramGroup.pathItems.add();		// Top-left point	var point1 = this.halfCircle.pathPoints.add();	point1.anchor = [this.x - .5*this.d, this.y];	point1.leftDirection = [this.x - .5*this.d, this.y - .28*this.d];	point1.rightDirection = point1.anchor;	// Top-right point	var point2 = this.halfCircle.pathPoints.add();	point2.anchor = [this.x + .5*this.d, this.y];	point2.leftDirection = point2.anchor;	point2.rightDirection = [this.x + .5*this.d, this.y - .28*this.d];	// Bottom midde, curve	var point3 = this.halfCircle.pathPoints.add();	point3.anchor = [this.x, this.y - .5*this.d];	point3.leftDirection = [this.x + .28*this.d, this.y - .5*this.d];	point3.rightDirection = [this.x - .28*this.d, this.y - .5*this.d];	this.halfCircle.strokeWidth = this.f = curDiagram.strokeWidth;	this.halfCircle.strokeColor = black;	this.halfCircle.fillColor = gray[50];	this.halfCircle.closed = true;	this.halfCircle.rotate(45, true, false, false, false, Transformation.TOP);	}CircleKey.prototype.trill_half = function() {	// 2nd circle, half circle, strokeColor, fillColor	// only available for CircleKeys?}function OvalKey(x, y, width, height, angle) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		// Define dimensions of oval key	this.key = fingeringDiagramGroup.pathItems.ellipse(				y + .5*height,		x - .5*width,		width,		height	);		// Rotate as necessary	this.key.rotate(angle); }// Inherit attributes and methods from parent keyOvalKey.prototype = new Key();function TearDropKey(x, y, width, height, angle) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Sharp point (always on left, before rotation)	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = point1.anchor;	point1.rightDirection = point1.anchor;		// Rounded point (always on right, before rotation)	var point2 = this.key.pathPoints.add();	point2.anchor = [x + width    		, y];	point2.leftDirection = [x + width, y + height];	point2.rightDirection = [x + width, y - height];		// Rotate	this.key.rotate(angle);		this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;	this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}// Inherit attributes and methods from parent keyTearDropKey.prototype = new Key();function PillKey(x, y, width, height) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);	// Define dimensions of pill key	this.key = fingeringDiagramGroup.pathItems.roundedRectangle(			y + .5*height,		x - .5*width,		width,		height,		.1*this.f,		.1*this.f	);};// Inherit attributes and methods from parent keyPillKey.prototype = new Key();function flBKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Point, sharp	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = [x - .1*this.f, y + .75*this.f];	point1.rightDirection = point1.anchor;		// Right smooth	var point2 = this.key.pathPoints.add();	point2.anchor = [x, y + 1.15*this.f];	point2.leftDirection = [x + .15*this.f, y + .8*this.f];	point2.rightDirection = [x - .3*this.f, y + 1.8*this.f];		// Left smooth	var point3 = this.key.pathPoints.add();	point3.anchor = [x - .65*this.f, y + 1*this.f];	point3.leftDirection = [x - .9*this.f, y + 1.45*this.f];	point3.rightDirection = [x - .4*this.f, y + .6*this.f];        this.key.strokeWidth = 1;    this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;	this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;};flBKey.prototype = new Key();// Inherit attributes and methods from parent keyfunction flBflatKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Point, sharp	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = [x - .3*this.f, y + .6*this.f];	point1.rightDirection = point1.anchor;		// Right smooth	var point2 = this.key.pathPoints.add();	point2.anchor = [x - .45*this.f, y + 1*this.f];	point2.leftDirection = [x, y + .8*this.f];	point2.rightDirection = [x - .9*this.f, y + 1.15*this.f];		// Left smooth	var point3 = this.key.pathPoints.add();	point3.anchor = [x - .9*this.f, y + .4*this.f];	point3.leftDirection = [x - 1.25*this.f, y +.65*this.f];	point3.rightDirection = [x - .6*this.f, y + .2*this.f];        this.key.strokeWidth = 1;    this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;};flBflatKey.prototype = new Key();// Inherit attributes and methods from parent keyfunction flGsharpKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Bottom left, corner	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = point1.anchor;	point1.rightDirection = point1.anchor;		// Right, smooth	var point2 = this.key.pathPoints.add();	point2.anchor = [x + 1*this.f, y + .3*this.f];	point2.leftDirection = [x + .75*this.f, y - .05*this.f];	point2.rightDirection = [x + 1.35*this.f, y + .8*this.f];		// Middle, nook	var point3 = this.key.pathPoints.add();	point3.anchor = [x + .25*this.f, y + .25*this.f];	point3.leftDirection = [x + .8*this.f, y + 1.65*this.f];	point3.rightDirection = point3.anchor;		// Top left, corner 	var point4 = this.key.pathPoints.add();	point4.anchor = [x, y + .25*this.f];	point4.leftDirection = point4.anchor;	point4.rightDirection = point4.anchor;        this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}flGsharpKey.prototype = new Key();// Inherit attributes and methods from parent keyfunction flDsharpKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Bottom left half-corner	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = [x, y + 1.25*this.f];	point1.rightDirection = point1.anchor;		// Bottom right corner	var point2 = this.key.pathPoints.add();	point2.anchor = [x + 1.5*this.f, y];	point2.leftDirection = point2.anchor;	point2.rightDirection = point2.anchor;		// Top right half-corner	var point3 = this.key.pathPoints.add();	point3.anchor = [x + 1.5*this.f, y + .15*this.f];	point3.leftDirection = point3.anchor;	point3.rightDirection = [x + 1.15*this.f, y + .15*this.f];        this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}// Inherit attributes and methods from parent keyflDsharpKey.prototype = new Key();function flCsharpKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Bottom right corner	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = point1.anchor;	point1.rightDirection = point1.anchor;		// Bottom left half-corner	var point2 = this.key.pathPoints.add();	point2.anchor = [x - .2*this.f, y];	point2.leftDirection = point2.anchor;	point2.rightDirection = [x - .2*this.f, y + .3*this.f];        	// Top right half-corner	var point3 = this.key.pathPoints.add();	point3.anchor = [x, y + 1*this.f];	point3.leftDirection = [x - 1.2*this.f, y + 1*this.f];	point3.rightDirection = point3.anchor;        this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}// Inherit attributes and methods from parent keyflCsharpKey.prototype = new Key();function clGsharpKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);			this.key = fingeringDiagramGroup.pathItems.add();		// Bottom, curved	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = [x - .3*this.f, y - .1*this.f];	point1.rightDirection = [x + .4*this.f, y + .15*this.f];		// Top, small radius	var point2 = this.key.pathPoints.add();	point2.anchor = [x - .1*this.f, y + 1.85*this.f];	point2.leftDirection = [x + .2*this.f, y + 1.55*this.f];	point2.rightDirection = [x - .15*this.f, y + 1.9*this.f];		// Top-left	var point3 = this.key.pathPoints.add();	point3.anchor = [x - .25*this.f, y + 1.75*this.f];	point3.leftDirection = [x - .25*this.f, y + 1.9*this.f];	point3.rightDirection = [x - .25*this.f, y + 1.6*this.f];		// Left contour	var point4 = this.key.pathPoints.add();	point4.anchor = [x - .2*this.f, y + 1.05*this.f];	point4.leftDirection = [x, y + 1.6*this.f];	point4.rightDirection = [x - .4*this.f, y + .4*this.f];		this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}// Inherit attributes and methods from parent keyclGsharpKey.prototype = new Key();function clLeftEKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);    	this.key = fingeringDiagramGroup.pathItems.add();		// Bottom right corner	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = point1.anchor;	point1.rightDirection = point1.anchor;		// Top right, smooth, edge	var point2 = this.key.pathPoints.add();	point2.anchor = [x, y + 1.6*this.f];	point2.leftDirection = [x + .0125*this.f, y + 1.25*this.f];	point2.rightDirection = [x - .05*this.f, y + 2.1*this.f];		// Left contour	var point3 = this.key.pathPoints.add();	point3.anchor = [x - .5*this.f, y + 1.35*this.f];	point3.leftDirection = [x - .4875*this.f, y + 1.8*this.f];	point3.rightDirection = [x - .5*this.f, y + .85*this.f];		// Left nook	var point4 = this.key.pathPoints.add();	point4.anchor = [x - .2*this.f, y + .25*this.f];	point4.leftDirection = [x - .4*this.f, y + .7*this.f];	point4.rightDirection = [x - .185*this.f, y + .175*this.f];		// Bottom-left corner	var point5 = this.key.pathPoints.add();	point5.anchor = [x - .2*this.f, y];	point5.leftDirection = point5.anchor;	point5.rightDirection = point5.anchor;		this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}// Inherit attributes and methods from parent keyclLeftEKey.prototype = new Key();function clLeftFsharpKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Bottom left corner	var point1 = this.key.pathPoints.add();	point1.anchor = [x, y];	point1.leftDirection = point1.anchor;	point1.rightDirection = point1.anchor;		// Top left, smooth, edge	var point2 = this.key.pathPoints.add();	point2.anchor = [x, y + 1.2*this.f];	point2.leftDirection = [x, y + .9*this.f];	point2.rightDirection = [x, y + 1.7*this.f];		// Right contour	var point3 = this.key.pathPoints.add();	point3.anchor = [x + .5*this.f, y + .95*this.f];	point3.leftDirection = [x + .5*this.f, y + 1.45*this.f];	point3.rightDirection = [x + .5*this.f, y + .55*this.f];		// Right nook	var point4 = this.key.pathPoints.add();	point4.anchor = [x + .2*this.f, y + .2*this.f];	point4.leftDirection = [x + .3*this.f, y + .35*this.f];	point4.rightDirection = [x + .1875*this.f, y + .15*this.f];		// Bottom-right corner	var point5 = this.key.pathPoints.add();	point5.anchor = [x + .2*this.f, y];	point5.leftDirection = point5.anchor;	point5.rightDirection = point5.anchor;		this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}// Inherit attributes and methods from parent keyclLeftFsharpKey.prototype = new Key();function clLeftGsharpKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Bottom left corner	var point1 = this.key.pathPoints.add();	point1.anchor = [x - .075*this.f, y];	point1.leftDirection = point1.anchor;	point1.rightDirection = point1.anchor;		// Left nook	var point2 = this.key.pathPoints.add();	point2.anchor = [x - .1*this.f, y + .15*this.f];	point2.leftDirection = [x - .25*this.f, y + .4*this.f];	point2.rightDirection = [x - .075*this.f, y + .1*this.f];		// Left curve	var point3 = this.key.pathPoints.add();	point3.anchor = [x - .2*this.f, y + .8*this.f];	point3.leftDirection = [x - .2125*this.f, y + .6*this.f];	point3.rightDirection = [x - .1875*this.f, y + 1*this.f];		// Top	var point4 = this.key.pathPoints.add();	point4.anchor = [x, y + 1.15*this.f];	point4.leftDirection = [x - .1*this.f, y + 1.15*this.f];	point4.rightDirection = [x + .1*this.f, y + 1.15*this.f];		// Right curver	var point5 = this.key.pathPoints.add();	point5.anchor = [x + .2*this.f, y + .8*this.f];	point5.leftDirection = [x + .2125*this.f, y + .6*this.f];	point5.rightDirection = [x + .1875*this.f, y + 1*this.f];		// Right nook	var point6 = this.key.pathPoints.add();	point6.anchor = [x + .1*this.f, y + .15*this.f];	point6.leftDirection = [x + .25*this.f, y + .4*this.f];	point6.rightDirection = [x + .075*this.f, y + .1*this.f];		// Bottom right corner	var point7 = this.key.pathPoints.add();	point7.anchor = [x + .075*this.f, y];	point7.leftDirection = point7.anchor;	point7.rightDirection = point7.anchor;		this.key.closed = true;    this.key.strokeCap = StrokeCap.ROUNDENDCAP;    this.key.strokeJoin = StrokeJoin.ROUNDENDJOIN;}// Inherit attributes and methods from parent keyclLeftGsharpKey.prototype = new Key();function clThumbDKey(x, y) {		// Inherit attributes and methods from parent key	this.f = curDiagram.f;	Key.call(this);		this.key = fingeringDiagramGroup.pathItems.add();		// Left Point	var point1 = this.key.pathPoints.add();	point1.anchor = [x - .3*this.f, y];	point1.leftDirection = [x - .3*this.f, y - .15*this.f];	point1.rightDirection = [x - .3*this.f, y + .15*this.f];		// Top point	var point2 = this.key.pathPoints.add();	point2.anchor = [x + .2*this.f, y + .3*this.f];	point2.leftDirection = [x + .05*this.f, y + .35*this.f];	point2.rightDirection = [x + .35*this.f, y + .25*this.f];		// Bottom point	var point3 = this.key.pathPoints.add();	point3.anchor = [x + .2*this.f, y - .3*this.f];	point3.leftDirection = [x + .35*this.f, y - .25*this.f];	point3.rightDirection = [x + .05*this.f, y - .35*this.f];		this.key.closed = true;}// Inherit attributes and methods from parent keyclThumbDKey.prototype = new Key();