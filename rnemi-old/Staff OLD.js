#include "arrayMethods.js"#include "conversions.js"#include "colors.js"//#include "ClefPref.js"#include "Notehead.js"//#include "DEFAULTS.js"#include "PitchSpelling.js"#include "AccidentalCollision.js"function Staff(context, top, left, g, type, transposition) {        curGraph = this;        this.context = context || testDoc;    this.graphType = "staff";    this.type = type || "treble";    this.transposition = transposition || 0;    this.initialClef = true;    this.prevTransposition = 0;    this.left = left || 36;    this.g = g || 5;    this.top = top || 400;    this.bottom = this.top - 4*this.g;    this.middle = this.top - 2*this.g;    this.staffLine = [];        /*this.transpose_line_displacement = .618*this.g;    this.transpose_label_top = 0;    this.transpose_exclamation_top = 0;        this.nullSymbol_ellipse_diameter = .8*this.g;    this.nullSymbol_strokeWidth = .17*this.g;*/        this.restLine_strokeWidth = .5*this.g;    this.restLine_length = .66*this.g;    this.restLine_displacement = 3/2*this.restLine_strokeWidth;    this.restLine_staffDisplacement = .85*this.g;    this.rest_color = orange_dark;        this.stem_strokeWidth = .05*this.g // RELATE TO BEAM GROUP!        this.staffLine_strokeWidth = .05*this.g;    this.staffLine_strokeColor = gray[50];        this.ledgerLine_length = 1.75*this.g;        this.augDot_diameter = .382*this.g;    this.augDot_displacement = 1*this.g;        this.staff = this.context.groupItems.add();    // Declare lines    this.lines();    // Draw clef immediately    this.clef(this.left);        this.middleCByType = {                "treble": this.bottom - 1*this.g,        "alto": this.top - 2*this.g,        "tenor": this.top - 1*this.g,        "bass": this.top + 1*this.g    };        this.initialMiddleC = this.middleCByType[this.type];    // Initial clef and transposition    //this.transpose(this.left, this.transposition);}Staff.prototype.clef = function(x) {    var top = this.top + 0.618 * this.g;    var bottom = this.bottom - 0.618 * this.g;    var clef = new Clef(this.context, x, top, bottom, this.g, this.type, 0);    this.linePoints(x);};Staff.prototype.lines = function() {        // Declare staffLine properties    for (var l = 0; l < 5; l ++) {                this.staffLine[l] = 'staffLine' + l;        this.staffLine[l] = this.staff.pathItems.add();                this.staffLine[l].stroked = true        this.staffLine[l].strokeWidth = this.staffLine_strokeWidth        this.staffLine[l].strokeColor = this.staffLine_strokeColor        this.staffLine[l].filled = false    };};Staff.prototype.ledgerLines = function(curX, below, above) {        // Draw ledgerLines below staff    for (var l = 0; l < below; l ++) {                var ledgerLine = testDoc.pathItems.add();        ledgerLine.stroked = true;        ledgerLine.strokeWidth = 1.25*this.staffLine_strokeWidth;        ledgerLine.strokeColor = gray[50];        ledgerLine.filled = false;        ledgerLine.setEntirePath([            [                curX - .5*this.ledgerLine_length,                this.bottom - l*this.g - 1*this.g            ],            [                curX + .5*this.ledgerLine_length,                this.bottom - l*this.g - 1*this.g            ]        ]);    }        // Draw ledgerLines above staff    for (var l = 0; l < above; l ++) {                var ledgerLine = testDoc.pathItems.add();        ledgerLine.stroked = true;        ledgerLine.strokeWidth = 1.25*this.staffLine_strokeWidth;        ledgerLine.strokeColor = gray[50];        ledgerLine.filled = false;        ledgerLine.setEntirePath([            [                curX - .5*this.ledgerLine_length,                this.top + l*this.g + 1*this.g            ],            [                curX + .5*this.ledgerLine_length,                this.top + l*this.g + 1*this.g            ]        ]);    }};Staff.prototype.linePoints = function(curX) {        // Add line points (after rests, etc)        for (var l = 0; l < 5; l ++) {                var staffLinePoint = this.staffLine[l].pathPoints.add();        staffLinePoint.anchor = [curX, this.top - l*this.g]        staffLinePoint.leftDirection = staffLinePoint.anchor        staffLinePoint.rightDirection = staffLinePoint.anchor           };};Staff.prototype.pitch = function(x, pitchINFO) {    // pitchINFO is {}    // {"45.75": { "type": "ord", "color": "gray[50]" } }        // ROUND EVERYTHING TO 1/4    var pitchesRounded = [];    for (var pitch in pitchINFO) {        parsedPitch = parseFloat(pitch);        var midi = Math.round(parsedPitch*4)/4;        pitchesRounded.push(midi);    };    // Sort pitches numerically    pitchesRounded.numSort();    // for testing only!    this.middleC = this.initialMiddleC;    var maxNoteheadY, minNoteheadY;    var pitchSpelling = new PitchSpelling(pitchesRounded);    var spelledPitches = pitchSpelling.spelledPitches;    var noteheads = [];    var accidentals = [];        for (var pitch in spelledPitches) {        var coarse = spelledPitches[pitch].coarse;        var fine = spelledPitches[pitch].fine;        var step = spelledPitches[pitch].step;        var octavesFromMiddleC = Math.floor((pitch - 60) / 12);        var vertDisplace = octavesFromMiddleC * 3.5 * this.g;        var noteheadY = vertDisplace + this.middleC + (0.5 * this.g * step);        var accidentalX = x - (1.2 * this.g);        var noteheadType = pitchINFO[pitch].type;        var color = pitchINFO[pitch].color;        // Draw notehead and accidental as appropriate        var notehead = new Notehead(this, x, noteheadY, this.g, noteheadType, color);        noteheads.push(notehead);        var accidental = new Accidental(this, accidentalX, noteheadY, this.g, coarse, fine);        accidentals.push(accidental);        // Set max and min notehead Y values to initial        if (! maxNoteheadY) {            maxNoteheadY = noteheadY;             minNoteheadY = noteheadY;        };        else {            if (noteheadY > maxNoteheadY) {                maxNoteheadY = noteheadY;            }            else if (noteheadY < minNoteheadY) {                minNoteheadY = noteheadY;            };        };        this.minNoteheadY = minNoteheadY;        this.maxNoteheadY = maxNoteheadY;     };     noteheads.sort (function(a,b) {         return a.staffPosition - b.staffPosition     });     accidentals.sort (function(a,b) {         return a.staffPosition - b.staffPosition     });    var collision = new AccidentalCollision(accidentals);    //$.writeln(">>> " + pitchesRounded);    // Check if 2 on same line    for (var n = 0; n < noteheads.length - 1; n ++) {        var curNotehead = noteheads[n];        var nextNotehead = noteheads[n + 1];        var curAccidental = accidentals[n];        var nextAccidental = accidentals[n + 1];        // Check collision of two bodies        var curBody = curAccidental.dimensions.body.boundingShape;        var nextBody = nextAccidental.dimensions.body.boundingShape;                /*if (polygonCollision(curBody, nextBody)) {            $.writeln("COLLISION: cur: ["+ curAccidental.coarse +                       "," + curAccidental.fine + "], [" + nextAccidental.coarse +                       "," + nextAccidental.fine + "]"            );        };*/        /*// IT IS IN HERE THAT POLYGON OVERLAP TESTING WILL OCCUR!        for (var zone in curAccidental.dimensions) {            if (zone === "body") {                var boundingShape = curAccidental.dimensions.body.boundingShape                for (var p = 0; p < boundingShape.length; p ++) {                    var point = boundingShape[p];                    $.writeln("point:x: " + point[0] + ": x: " + point[1]);                };            };        };*/        if (nextNotehead.staffPosition === curNotehead.staffPosition + 0.5 ||            curNotehead.staffPosition === nextNotehead.staffPosition) {            curNotehead.x -= 0.5 * this.g;            nextNotehead.x += 0.5 * this.g;            curAccidental.move(-0.5 * this.g, 0);            nextAccidental.move(- 0.5 * this.g, 0);            // Adjust width of ledger lines in range!        };     }    for (var n = 0; n < noteheads.length; n ++) {        var curNotehead = noteheads[n];        var curAccidental = accidentals[n];        curNotehead.draw();        curAccidental.draw(testDoc);    }    this.linePoints(x);    var ledgerLine_below = 0;    var ledgerLine_above = 0;    if (this.minNoteheadY <= this.bottom - 1*this.g) {        var ledgerLine_below = Math.floor(            Math.abs(this.minNoteheadY - this.bottom)/this.g);    };    if (this.maxNoteheadY >= this.top + 1*this.g) {        var ledgerLine_above = Math.floor((this.maxNoteheadY - this.top)/this.g);    };    // Draw ledgerLines as necessary    this.ledgerLines(x, ledgerLine_below, ledgerLine_above);     /*var pitchMean = (pitchesRounded[0] + pitchesRounded[pitchesRounded.length - 1])/2        curInstrumentType = instrGraphs[instr].type;    curInstrumentInstrument = instrGraphs[instr].instrument;        /*if (curInstrumentInstrument == "bass") {                for (var c = 0; c < ClefPref[curInstrumentInstrumenttrumentType][curInstrumentInstrument].preferredClefs[curGraph].length; c ++) {                     var potentialClef = ClefPref[curInstrumentType][curInstrumentInstrument].preferredClefs[curGraph][c];                        if (pitchMean <= potentialClef[3] && potentialClef[2] <= pitchMean) {                                var newClef = potentialClef;            };        };        this.type = newClef[0];        this.transpose(curX, newClef[1])    }    else if (curInstrumentInstrument == "concert") {                this.transpose(curX, ClefPref["flute"]["concert"].default[1])        this.type = ClefPref["flute"]["concert"].default[0]        this.middleC = this.middleCByType[this.type]    };*/    /*this.highestPitchY = midiToGSpace(        this.g,         this.middleC,         pitchesRounded[pitchesRounded.length - 1]    )[0];        this.lowestPitchY = midiToGSpace(        this.g,        this.middleC,        pitchesRounded[0]    )[0];*/            // Add points to continue staff lines    //this.linePoints(curX);        // Draw noteheads, with accidentals, articulations, etc    /*for (var item = 0; item < pitchINFO.length; item ++) {                var midi = Math.round(pitchINFO[item].pitch*4)/4;        var type = pitchINFO[item].type        // Draw notehead        var notehead = new Notehead(curX, this.middleC, this.g, midi, type);        var accidental = new Accidental()    };*/};Staff.prototype.rest = function(curX) {        // Add line points    this.linePoints(curX);        // Declare lines    this.lines();        // Stemlet    //curBeamGroup.stemlet();        /*// Draw Dashed line    var dashedLine = BEAM_ITEMS.pathItems.add();    dashedLine.name = "Dashed Line";    dashedLine.stroked = true;    dashedLine.strokeWidth = 2*this.stem_strokeWidth;    dashedLine.strokeColor = this.rest_color;    dashedLine.strokeDashes = [.25*this.g];    dashedLine.filled = false;        if (curBeamGroup.level < 0) {                var restLine_altitude = this.top + this.restLine_staffDisplacement;    }    else if (curBeamGroup.level > 0) {                var restLine_altitude = this.bottom - this.restLine_staffDisplacement;    };    dashedLine.setEntirePath([        [            curX,             curBeamGroup.beam_altitude +                 (curBeamGroup.stem_direction*curBeamGroup.stemletLength +                 curBeamGroup.stem_direction*.185*this.g)        ],        [            curX,             restLine_altitude -                 (curBeamGroup.stem_direction*this.restLine_staffDisplacement +                 .382*this.g)        ]    ]);    // Solid connecting line    var solidLine = beamGroup.pathItems.add();    solidLine.name = "Solid Line"    solidLine.stroked = true;    solidLine.strokeColor = this.rest_color;    solidLine.strokeWidth = 2*this.stem_strokeWidth;    solidLine.filled = false;    solidLine.setEntirePath([        [            curX,             restLine_altitude - curBeamGroup.stem_direction*                (this.restLine_staffDisplacement + .125*this.g)         ],        [               curX,            restLine_altitude + curBeamGroup.stem_direction*                this.restLine_displacement*(curEvent.curSubdivision - 1)        ]    ]);        // Draw Rest lines    for (var restSubd = 0; restSubd < curEvent.curSubdivision; restSubd ++) {                var restLine = BEAM_ITEMS.pathItems.add();        restLine.stroked = true;        restLine.strokeWidth = this.restLine_strokeWidth;        restLine.filled = false        restLine.strokeColor = this.rest_color;        restLine.setEntirePath([            [                curX - .5*this.restLine_length,                restLine_altitude + restSubd*curBeamGroup.stem_direction*                    this.restLine_displacement            ],            [                curX + .5*this.restLine_length,                restLine_altitude + restSubd*curBeamGroup.stem_direction*                    this.restLine_displacement            ]        ]);     };        if (curEvent.durationAbs % 3 == 0) {                var rest_augDot = BEAM_ITEMS.pathItems.ellipse(            this.top - 1.5*this.g + .5*this.augDot_diameter,            curX + this.augDot_displacement - .5*this.augDot_diameter,            this.augDot_diameter,            this.augDot_diameter        );                rest_augDot.stroked = false;        rest_augDot.filled = true;        rest_augDot.fillColor = this.rest_color;    };*/};Staff.prototype.transpose = function(curX, transposition) {        var curX = curX - this.clef_displacement;        /*if (this.initialClef === false) {                       for (var prevLines = 0; prevLines < this.staffLine.length; prevLines ++) {            $.writeln("length: " + this.staffLine[prevLines].pathPoints.length)            var lastPathPoints = this.staffLine[prevLines].pathPoints;            $.writeln("staffLine: " + lastPathPoints[lastPathPoints.length - 1].anchor)                        // Move last pathPoints back before clef            //lastPathPoints[lastPathPoints.length - 1].anchor[0] -= .618*this.g            //this.staffLine[prevLines].anchor[0] -= .618*this.g        };                //this.lines();    }*/    // Redeclare transposition    this.transposition = transposition;            // If initial clef on page    if (this.initialClef === true) {        // Redeclare lines        this.lines();                // Add linePoints on new lines        this.linePoints(curX);                // Draw clef        this.clef(curX, this.type);    }    // If not initial clef on page    else if (this.initialClef !== true) {                if (this.type !== this.prevType ||            this.transposition !== this.prevTransposition) {            // Add linePoints just before clef            this.linePoints(curX - .618*this.g);                // Redeclare lines            this.lines();                // Add linePoints on new lines            this.linePoints(curX);                // Draw clef            this.clef(curX, this.type);         }        // If no clef/transposition necessary        else if (this.type === this.prevType &&                 this.transposition === this.prevTransposition) {                                this.linePoints(curX + this.clef_displacement);        }    }        // Establish if the baseline should be drawn    var drawLine;    // Draw line    var line_width = 1.125*this.g    if (this.transposition < 0) {        var transpose_direction = -1;        var reference = this.bottom;        this.transpose_label_top = this.bottom - .125*this.g;        this.transpose_exclamation_top = this.bottom - .25*this.g;        drawLine = true;    }    else {        var transpose_direction = 1;        var reference = this.top;        this.transpose_label_top = this.top + 2.9*this.g;        this.transpose_exclamation_top = this.top + 2.4*this.g;        drawLine = true;    };    if (this.transposition == 0 &&         this.initialClef == false &&         this.prevTransposition < 0) {        var transpose_direction = -1;        var reference = this.bottom;        this.transpose_label_top = this.bottom - .125*this.g;        this.transpose_exclamation_top = this.bottom - .25*this.g;        drawLine = true;        }    if (this.transposition == 0 &&             this.initialClef == false &&             this.prevTransposition > 0) {        var transpose_direction = 1;        var reference = this.top;        this.transpose_label_top = this.top + 2.9*this;        this.transpose_exclamation_top = this.top + 2.4*this.g;        drawLine = true;            };    if (this.initialClef == true && this.transposition === 0) {        drawLine = false;    };    /*if (this.initialClef === false &&        this.type !== this.prevType) {                drawLine = false;    };*/    if (this.initialClef === false &&        this.type === this.prevType &&        this.transposition === this.prevTransposition) {                    drawLine = false;    }    if (this.initialClef === false &&        this.transposition === 0 &&        this.prevTransposition === 0) {                    drawLine = false;    }    if (drawLine == true) {        // Draw transposition label line        var line = clef.pathItems.add();        line.setEntirePath([            [                  curX - .5*line_width,                 reference + transpose_direction*this.transpose_line_displacement],            [                curX + .5*line_width,                reference + transpose_direction*this.transpose_line_displacement]        ]);        line.stroked = true;        line.strokeWidth = this.clef_line_strokeWidth;        line.strokeColor = this.clef_strokeColor;        line.filled = false;        // ONLY IF != 0, draw text, otherwise, draw null symbol        if (this.transposition != 0) {            this.transpose_label(curX);        }        // Draw null symbol        else if (this.transposition == 0 &&                 this.prevTransposition !== 0) {            if (this.prevTransposition < 0) {                var transpose_direction = -1;            }            else {                var transpose_direction = 1;            };            var nullSymbol = clef.groupItems.add();            // Draw nullSymbol Line            var nullSymbol_line = nullSymbol.pathItems.add();            nullSymbol_line.setEntirePath([                [                    curX - .8*this.g,                    reference + transpose_direction*(.85 + .618)*this.g                ],                [                    curX + .8*this.g,                    reference + transpose_direction*(.85 + .618)*this.g                ]            ]);            nullSymbol_line.strokeWidth = this.nullSymbol_strokeWidth;            nullSymbol_line.strokeColor = gray[50];            nullSymbol_line.filled = false;            nullSymbol_line.rotate(45);            // Draw nullSymbol Ellipse            var nullSymbol_ellipse = nullSymbol.pathItems.ellipse(                reference + transpose_direction*(.85 + .618)*this.g +                     .5*this.nullSymbol_ellipse_diameter,                    curX - .5*this.nullSymbol_ellipse_diameter,                    this.nullSymbol_ellipse_diameter,                    this.nullSymbol_ellipse_diameter            );            nullSymbol_ellipse.strokeWidth = this.nullSymbol_strokeWidth;            nullSymbol_ellipse.strokeColor = gray[50];             nullSymbol_ellipse.filled = false;         };        if (this.initialClef == false &&            this.transposition != this.prevTransposition) {            this.transpose_exclamation(curX);        }    };    // Adjust transposition of Staff Object    var transpose_adjust = {        "-36":-21, "-24":-14, "-12":-7, "0":0, "12":7, "24":14, "36":21    };        this.middleC = this.middleCByType[this.type] -                     transpose_adjust[this.transposition]*.5*this.g;                                // Switch initial clef to FALSE    this.initialClef = false;    this.prevType = this.type;    this.prevTransposition = this.transposition;};Staff.prototype.transpose_label = function(curX) {        var transpose_label_font = app.textFonts.getByName("AvenirNextCondensed-DemiBold");        var transpose_labelAdjust = {                "-36": 22, "-24": 15, "-12": 8, "0": 0, "12": 8, "24": 15, "36": 22    };        // Draw transposition label text    var transpose_label = clef.textFrames.add();    transpose_label.contents = transpose_labelAdjust[this.transposition];    transpose_label.top = this.transpose_label_top;    transpose_label.left = curX;    transpose_label.textRange.characterAttributes.textFont = transpose_label_font;    transpose_label.textRange.characterAttributes.size = 8.5;    transpose_label.textRange.characterAttributes.fillColor = gray[50];    transpose_label.textRange.paragraphAttributes.justification = Justification.CENTER;};Staff.prototype.transpose_exclamation = function(curX) {        var transpose_exclamation_font = app.textFonts.getByName("AvenirNextCondensed-Medium");        // Draw transposition label exclamation mark    var transpose_exclamation = clef.textFrames.add();    transpose_exclamation.contents = "!";    transpose_exclamation.top = this.transpose_exclamation_top;    transpose_exclamation.left = curX - .9375*this.g;    transpose_exclamation.textRange.characterAttributes.textFont = transpose_exclamation_font;    transpose_exclamation.textRange.characterAttributes.size = 13;    transpose_exclamation.textRange.characterAttributes.fillColor = magenta;    transpose_exclamation.textRange.paragraphAttributes.justification = Justification.CENTER;}