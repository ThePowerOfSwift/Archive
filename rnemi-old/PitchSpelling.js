#include "arrayMethods.js"#include "accidentalList.js"function PitchSpelling(pitchList) {    this.amountSpelled = 0;    this.roundPitches(pitchList, 4);    this.spelledPitches = {};        //$.writeln("this.pitchList: " + this.pitchList);    if (this.amountPitches === 0) {        return undefined;    }    else if (this.amountPitches === 1) {        this.singlePitch();    }    else if (this.amountPitches > 1) {         this.createDyadList();        this.findObjectiveSpellings();        this.searchDyads();    };    //this.print();}PitchSpelling.prototype.commitPitch = function(pitch, spelling) {    this.spelledPitches[pitch] = spelling;    this.amountSpelled ++;    if (spelling.fine !== 0) this.prevailingFine = spelling.fine;};PitchSpelling.prototype.roundPitches = function(pitchList, divisor) {    // Divisor: division of semi-tone (4: 1/8th-tone, 2: 1/4-tone)    this.pitchList = [];    for (var p = 0; p < pitchList.length; p ++) {        var pitch = pitchList[p];        var roundedPitch = Math.round(pitch * divisor) / divisor;        this.pitchList.push(roundedPitch);    };    this.amountPitches = this.pitchList.length;};PitchSpelling.prototype.createDyadList = function() {    this.dyadList = [];    for (var p = 0; p < this.pitchList.length; p ++) {        for (var pp = p + 1; pp < this.pitchList.length; pp ++) {                        var pitchesSorted = [                this.pitchList[p],                this.pitchList[pp]            ].numSort();            var dyad = {};            dyad.p0 = {};            dyad.p0.pitch = pitchesSorted[0];            dyad.p0.pitchClass = (pitchesSorted[0]) % 12;            dyad.p0.spellings = SpellingsByPitchClass[dyad.p0.pitchClass];            dyad.p1 = {};            dyad.p1.pitch = pitchesSorted[1];            dyad.p1.pitchClass = (pitchesSorted[1]) % 12;            dyad.p1.spellings = SpellingsByPitchClass[dyad.p1.pitchClass];            dyad.interval = pitchesSorted[1] - pitchesSorted[0];            dyad.complexity = intervalComplexity(dyad.interval);            this.dyadList.push(dyad);        };    };    // Sort this.dyadList by from least to greatest complexity    this.dyadList.sort( function(a,b) {return a.complexity - b.complexity} );};PitchSpelling.prototype.singlePitch = function() {    var pitch = this.pitchList[0];    var pitchClass = pitch % 12;    if (SpellingsByPitchClass[pitchClass].length === 1) {        var singleSpelling = SpellingsByPitchClass[pitchClass][0];        this.commitPitch(pitch, singleSpelling);    }    else {        var potentialSpellings = SpellingsByPitchClass[pitchClass];        potentialSpellings.sort( function(a,b) {            return b.priority - a.priority        });        var spelling = potentialSpellings[0];        this.commitPitch(pitch, spelling);    };}PitchSpelling.prototype.findObjectiveSpellings = function() {    for (var p = 0; p < this.pitchList.length; p ++) {                var pitch = this.pitchList[p];        var pitchClass = pitch % 12;                if (SpellingsByPitchClass[pitchClass].length === 1) {            var spelling = SpellingsByPitchClass[pitchClass][0];            //$.writeln("objectively spelled: commitPitch: " + pitch);            this.commitPitch(pitch, spelling);        };    };};PitchSpelling.prototype.searchDyads = function() {        var d = 0;    while (this.amountSpelled < this.pitchList.length) {                if (this.amountSpelled === 0) this.noneObjectivelySpelled();        var curDyad = this.dyadList[d];        if (curDyad.p0.pitch in this.spelledPitches &&            curDyad.p1.pitch in this.spelledPitches) {            // Both spelled, pass        }        else if (curDyad.p0.pitch in this.spelledPitches ||            curDyad.p1.pitch in this.spelledPitches) {                        ////$.writeln("one spelled");            this.oneSpelled(curDyad, d);        }        else {            //$.writeln("neither spelled");            this.neitherSpelled(curDyad, d);        };        if (this.amountSpelled === this.pitchList.length) break;        d ++;    };};PitchSpelling.prototype.noneObjectivelySpelled = function() {    //$.writeln("noneObjectivelySpelled");    var dyadPitchList = [this.dyadList[0].p0, this.dyadList[0].p1];    for (var p = 0; p < 2; p ++) {        var curPitch = {};        curPitch.pitch = dyadPitchList[p];        curPitch.complexity = pitchComplexity(curPitch);    };    dyadPitchList.sort ( function(a,b) {        return b.complexity - a.complexity    });    var refPitch = dyadPitchList[0].pitch;    var refPitchClass = refPitch % 12;    var refPotentialSpellings = SpellingsByPitchClass[refPitchClass];    refPotentialSpellings.sort( function(a,b) {        return b.priority - a.priority    });    var refSpelling = refPotentialSpellings[0];    //$.writeln("none objectively spelled: commitPitch: " + refPitch);    this.commitPitch(refPitch, refSpelling);    if (refSpelling.fine !== 0) this.prevailingFine = refSpelling.fine;};PitchSpelling.prototype.oneSpelled = function(dyad, d) {    var pitch0 = dyad.p0.pitch;    var pitch1 = dyad.p1.pitch;    t.w("one spelled: p0: " + pitch0 + "; p1: " + pitch1);    if (pitch0 in this.spelledPitches) {        var spelled = pitch0;        var unspelled = pitch1;    }    else if (pitch1 in this.spelledPitches) {        var spelled = pitch1;        var unspelled = pitch0;    };    var spelled_resolution = this.pitchToResolution(spelled);    var unspelled_resolution = this.pitchToResolution(unspelled);    var spelled_coarse = this.spelledPitches[spelled].coarse;    var spelled_coarseDirection = this.coarseToDirection(spelled_coarse);    var spelled_coarseResolution = this.coarseToResolution(spelled_coarse);    var spelled_fine = this.spelledPitches[spelled].fine;    var spelled_step = this.spelledPitches[spelled].step;    var unspelledPitchClass = unspelled % 12;    var potentialSpellings = SpellingsByPitchClass[unspelledPitchClass];    // Step preservation (basic interval preservation) is of primary importance    var stepPreserved = [];    // Iterate over potentialSpellings object    for (var p = 0; p < potentialSpellings.length; p ++) {        var curSpelling = potentialSpellings[p];                // Adjust for mod 7 interval-step issues        if (spelled < unspelled && curSpelling.step < spelled_step) {            curSpelling_step_adj = curSpelling.step + 7;             spelled_step_adj = spelled_step;        }        else if (unspelled < spelled && spelled_step < curSpelling.step) {            spelled_step_adj = spelled_step + 7;            curSpelling_step_adj = curSpelling.step;        }        else {            curSpelling_step_adj = curSpelling.step;            spelled_step_adj = spelled_step;        }        var stepOrdered = [spelled_step_adj, curSpelling_step_adj].numSort();                // Find step of potential dyad spelling        var curStep = stepOrdered[1] - stepOrdered[0];                // Establish bounds for a valid preservance of interval-step        var minInterval = StepToIntervalRange[curStep%7][0];        var maxInterval = StepToIntervalRange[curStep%7][1];                // Check if interval-step is preserved: first level of refinement        if ((dyad.interval)%12 >= minInterval &&             (dyad.interval)%12 <= maxInterval) {                            stepPreserved.push(curSpelling);        };    };    if (stepPreserved.length === 0) {                t.w("NO STEP PRESERVED");        t.w("spelled_resolution: " + spelled_resolution + "; unspelled_resolution: " + unspelled_resolution);        // Very close interval        if (dyad.interval % 12 < 1 || dyad.interval === 11.75) {                        // Search for coarse mismatch            var coarseMatch = false;            for (var i = 0; i < potentialSpellings.length; i++) {                var spelling = potentialSpellings[i];                var spelling_coarse = spelling.coarse;                if (spelled_coarse !== spelling_coarse) {                    //$.writeln("no step preserved: very close interval: commitPitch: " + unspelled);                    this.commitPitch(unspelled, spelling);                    if (spelling.fine !== 0) this.prevailingFine = spelling.fine;                    coarseMatch = true;                    break;                };            };            // No coarseMatch            if (coarseMatch === false) {                // Rescan potentialSpellings for 1/2-tone resolution                for (var i = 0; i < potentialSpellings.length; i ++) {                    var spelling = potentialSpellings[i];                    if (spelling.coarse % 1 === 0) {                        //$.writeln("no step preserved: 1/2-step resolution: commitPitch: " + unspelled);                        this.commitPitch(unspelled, spelling);                        if (spelling.fine !== 0) {                            this.prevailingFine = spelling.fine;                        };                    };                };            };        }        else if (spelled_resolution === 1 && unspelled_resolution === 4) {            t.w("spelled_resolution: " + spelled_resolution +                "; unspelled_resolution: " + unspelled_resolution            );             t.w("give up: commit highest priority spelling");            var sortedByPriority = SpellingsByPitchClass[unspelledPitchClass]                .sort( function(a,b) { return a.priority - b.priority }             );            var priority = SpellingsByPitchClass[unspelledPitchClass][0];            this.commitPitch(unspelled, priority);                    }        // Both pitches are 1/8th-tone resolution        else if (spelled_resolution === 4 && unspelled_resolution === 4) {             //$.writeln("both 1/8th tone")            // Search for fineMatch            for (var i = 0; i < potentialSpellings.length; i ++) {                var spelling = potentialSpellings[i];                var spelling_fine = spelling.fine;                if (spelled_fine === spelling_fine) {                    //$.writeln("no step preserved: both 1/8-tone fineMatch: " + unspelled);                    this.commitPitch(unspelled, spelling);                    this.prevailingFine = spelling_fine;                };            };        }            else if (spelled_resolution === 2 && unspelled_resolution === 2) {            //$.writeln("BOTH 1/4-tone: " + spelled_resolution + ", " + unspelled_resolution);            // Search for coarse match                        // Check for coarse match!            var coarseMatch = false;            for (var i = 0; i < potentialSpellings.length; i ++) {                var spelling = potentialSpellings[i];                var spelling_coarse = spelling.coarse;                if (spelled_coarse === spelling_coarse) {                    //$.writeln("no step preserved: coarseMatch: commitPitch: " + unspelled);                    this.commitPitch(unspelled, spelling);                    this.prevailingFine = spelling.fine;                    coarseMatch = true;                    break;                };            };            // No coarseMatch            if (coarseMatch === false) {                // Rescan for coarseResolution match                for (var i = 0; i < potentialSpellings.length; i ++) {                    var spelling = potentialSpellings[i];                    var spelling_coarseResolution = this.coarseToResolution(                        spelling.coarse                    );                    if (spelled_coarseResolution === spelling_coarseResolution) {                        //$.writeln("no step preserved: coarse_resolution match: commitPitch: " + unspelled);                        this.commitPitch(unspelled, spelling);                    };                };            };        }        else if (spelled_resolution === 2 && unspelled_resolution === 4) {                //$.writeln("spelled: 1/4-tone; unspelled: 1/8th-tone");            // Check for coarse match!            var coarseMatch = false;            for (var i = 0; i < potentialSpellings.length; i ++) {                var spelling = potentialSpellings[i];                var spelling_coarse = spelling.coarse;                if (spelled_coarse === spelling_coarse) {                    //$.writeln("no step preserved: coarseMatch: commitPitch: " + unspelled);                    this.commitPitch(unspelled, spelling);                    this.prevailingFine = spelling.fine;                    coarseMatch = true;                    break;                };            };            // No coarseMatch            if (coarseMatch === false) {                // Rescan for coarseResolution match                for (var i = 0; i < potentialSpellings.length; i ++) {                    var spelling = potentialSpellings[i];                    var spelling_coarseResolution = this.coarseToResolution(                        spelling.coarse                    );                    if (spelled_coarseResolution === spelling_coarseResolution) {                        //$.writeln("no step preserved: coarse_resolution match: commitPitch: " + unspelled);                        this.commitPitch(unspelled, spelling);                    };                };            };        }        else if (spelled_resolution === 2 & unspelled_resolution === 1) {            // Check from coarseDirection match            for (var i = 0; i < potentialSpellings.length; i ++) {                var spelling = potentialSpellings[i];                var spelling_coarseDirection = coarseToDirection(                    spelling.coarse                );                if (spelled_coarseDirection === spelling_coarseDirection) {                    //$.writeln("coarseDirection match!")                    this.commitPitch(unspelled, spelling);                };            };        }        else if (spelled_resolution === 1 && unspelled_resolution === 4) {                        // Check for coarse match            var coarseMatch = false;            for (var i = 0; i < potentialSpellings.length; i ++) {                var spelling = potentialSpellings[i];                var spelling_coarse = spelling.coarse;                if (spelled_coarse === spelling_coarse) {                    this.commitPitch(unspelled, spelling);                    coarseMatch = true;                    break;                };                };            if (coarseMatch === false) {                // Rescan to check for coarse resolution match                for (var i = 0; i < potentialSpellings.length; i ++) {                    var spelling = potentialSpellings[i];                    var spelling_coarseResolution = this.coarseToResolution(                        spelling.coarse                    );                    if (spelled_coarseResolution === spelling_coarseResolution) {                                                this.commitPitch(unspelled, spelling);                    };                };                            }            else {                t.w("give up: commit highest priority spelling");                var sortedByPriority = SpellingsByPitchClass[unspelledPitchClass]                    .sort( function(a,b) { return a.priority - b.priority }                 );                var priority = SpellingsByPitchClass[unspelledPitchClass][0];                this.commit(unspelled, priority);            };        }        else {            t.w("give up: commit highest priority spelling");            var sortedByPriority = SpellingsByPitchClass[unspelledPitchClass]                .sort( function(a,b) { return a.priority - b.priority }             );            var priority = SpellingsByPitchClass[unspelledPitchClass][0];            this.commit(unspelled, priority);        }    }    else if (stepPreserved.length === 1) {            var singleSpelling = stepPreserved[0];        // Check resolution of unspelled pitch        if (unspelled_resolution === 4) {            // Has a prevailingFine been initiated?            if (this.prevailingFine) {                // Check for a prevailing fine match                if (singleSpelling.fine === this.prevailingFine) {                    //$.writeln("one step preserved: prevailing fineMatch: " + unspelled);                    this.commitPitch(unspelled, singleSpelling);                }                else {                    // Rescan through potential spellings and re-choose!                    for (var i = 0; i < potentialSpellings.length; i ++) {                        var spelling = potentialSpellings[i];                        if (spelling.fine === this.prevailingFine) {                            //$.writeln("one step preserved: prevailing fineMatch (gave up on stepPreserved): commitPitch: " + unspelled);                            this.commitPitch(unspelled, spelling);                        };                    };                };            }            // If no prevailingFine as of yet            else {                //$.writeln("one step preserved: no prevailingFine yet: commitPitch: " + unspelled);                this.commitPitch(unspelled, singleSpelling);                this.prevailingFine = singleSpelling.fine;            };        }        // Unspelled pitch has a 1/4-tone or lower resolution        else if (unspelled_resolution <= 2) {            //$.writeln("one step preserved: low res: " + unspelled);            this.commitPitch(unspelled, singleSpelling);        };    }    // Multiple step-preserving spelling options    else if (stepPreserved.length > 1) {        //$.writeln("MULTIPLE STEP PRESERVED");        // Unspelled pitch has 1/8th-tone resolution        if (unspelled_resolution === 4) {            // If prevailingFine is hovering            if (this.prevailingFine) {                                // Scan stepPreserved list for prevailingFine match                for (var i = 0; i < stepPreserved.length; i ++) {                                        var spelling = stepPreserved[i];                    if (spelling.fine === this.prevailingFine) {                        //$.writeln("multi step preserved: prevailing fineMatch: commitPitch: " + unspelled);                        this.commitPitch(unspelled, spelling);                    };                };            }            // No prevailingFine yet, search for coarse match             else if (! this.prevailingFine){                //$.writeln("NO PREVAILING FINE")                var coarseMatch = false;                for (var i = 0; i < stepPreserved.length; i ++) {                       //$.writeln(stepPreserved[i].coarse);                    var spelling = stepPreserved[i];                    if (spelling.coarse === spelled_coarse) {                        //$.writeln("multi step preserved: no prevailingFine: coarseMatch: commitPitch: " + unspelled);                        this.commitPitch(unspelled, spelling);                                                // Set prevailingFine to this spelling.fine                        if (spelling.fine !== 0) this.prevailingFine = spelling.fine;                        // We found something!                        coarseMatch = true;                        break;                    };                };                // If no coarse match, settle for a lowest resolution coarse                if (coarseMatch === false) {                    //$.writeln("NO COARSE MATCH")                    for (var i = 0; i < stepPreserved.length; i ++) {                                                var spelling = stepPreserved[i];                        if (spelling.coarse % 1 === 0) {                            //$.writeln("multi step preserved: coarseResolution match: commitPitch: " + unspelled);                            this.commitPitch(unspelled, spelling);                                                        // Set prevailingFine to this spelling.fine                            if (spelling.fine !== 0) {                                this.prevailingFine = spelling.fine;                            };                        };                    };                };            };        }        // Currently makes a static "priority"-choice for 1/4-tone unspelled, meh        else if (unspelled_resolution === 2) {            var stepPreservedOrdered = stepPreserved.sort (function(a,b) {                return b.priority - a.priority            })            var prioritySpelling = stepPreservedOrdered[0];            //$.writeln("multi step preserved: 1/4-tone: priority: commitPitch: " + unspelled);            this.commitPitch(unspelled, prioritySpelling);        }        // Unspelled has 1/2-tone resolution        else if (unspelled_resolution === 1) {            // Search for coarseDirection match            for (var i = 0; i < stepPreserved.length; i ++) {                var spelling = stepPreserved[i];                var spelling_coarseDirection = this.coarseToDirection(                    spelling.coarse                );                if (spelled_coarseDirection === spelling_coarseDirection) {                    //$.writeln("multi step preserved: low res coarseDirection: commitPitch: " + unspelled);                    this.commitPitch(unspelled, spelling);                    if (spelling.fine !== 0) this.prevailingFine = spelling.fine;                };            };        };    };};PitchSpelling.prototype.pitchToResolution = function(pitch) {    var resolution;    if (pitch % 1 === 0) resolution = 1;    else if (pitch % 0.5 === 0) resolution = 2;    else if (pitch % 0.25 === 0) resolution = 4;    return resolution; };PitchSpelling.prototype.coarseToResolution = function(coarse) {    var resolution = Math.abs(coarse);    return resolution}PitchSpelling.prototype.coarseToDirection = function(coarse) {    var direction;    if (coarse === 0) direction = 0;    else if (coarse > 0) direction = 1;    else if (coarse < 0) direction = -1;    return direction; };PitchSpelling.prototype.neitherSpelled = function(dyad, d) {    //$.writeln("neither spelled")    if (dyad.attempted) {                //$.writeln("previously attempted");        var refPitch = dyad.p0.pitch;        var refPitchClass = refPitch % 12;        var refPotentialSpellings = SpellingsByPitchClass[refPitchClass];        refPotentialSpellings.sort(             function(a,b) { return b.priority - a.priority }        );        var refSpelling = refPotentialSpellings[0];        this.commitPitch(refPitch, refSpelling);    }    else {        //$.writeln("first attempt");        dyad.attempted = true;        this.dyadList.push(dyad);    };};PitchSpelling.prototype.print = function() {    ////$.writeln("this.pitchList: " + this.pitchList);    //$.writeln("amountPitches: " + this.pitchList.length);    //$.writeln("amountSpelled: " + this.amountSpelled);    for (var p in this.spelledPitches) {        var spelling = this.spelledPitches[p];        $.writeln(p + ": " + spelling.coarse + ", " + spelling.fine +                   "; step: " + spelling.step);    };};