#include "PitchSpelling.js"#include "AccidentalCollision.js"#include "Accidental.js"#include "Notehead.js"#include "Clef.js"#include "ClefAndTranspositionByInstrumentID.js"function Staff(Instrument, graphID) {        this.Instrument = Instrument;    this.graphID = graphID;    this.instrumentID = this.Instrument.performerID;    this.Performer = this.Instrument.Performer;    this.performerID = this.Performer.performerID;    this.primaryPerformerID = this.Instrument.primaryPerformerID;    this.System = this.Performer.System;    this.beatWidth = this.System.beatWidth;    this.scaleByRole(); // set this.g based on Primary or Supplementary Role    this.height = 4 * this.g;    /*this.top = top || 400;    this.left = left || 400;    this.g = g || 5;    this.bottom = this.top - 4 * this.g;    this.middle = (this.top + this.bottom) / 2;    this.type = type || "treble";    this.transposition = transposition || 0;*/        // FOR TESTING ONLY!!!!    this.top = 0;    this.clefHasChanged = false;    this.transpositionHasChanged = false;    this.manageInitialClefAndTransposition();    this.graphicalDimensions();}Staff.prototype.scaleByRole = function() {    if (this.performerID === this.primaryPerformerID) {        if (this.Instrument.amountGraphs.length === 1) { this.g = 5; }        else {             if (this.graphID === "fingered") { this.g = 5; }            else if (this.performerID === "FL" && this.graphID === "sounding") {                this.g = 5;            }            else { this.g = 0.618 * 5; };        };    } else { this.g = 0.618 * 5; };}Staff.prototype.graphicalDimensions = function() {    this.staffLineStrokeColor = gray[66];    this.staffLineStrokeWidth = 0.05 * this.g;    this.ledgerLineStrokeWidth = 1.25 * this.staffLineStrokeWidth;    this.ledgerLineLength = 1.75 * this.g;    this.clefDisplace = 0.2 * this.beatWidth;    this.newClefStaffLinesDisplace = 0.618 * this.g;}Staff.prototype.rest = function(x) {    this.linePoints(x);    this.lines();}Staff.prototype.draw = function() {    this.graphItemContext = this.System.graphItemContext;    this.infoItemContext = this.System.infoItemContext;    this.clefs = [];    this.middle = this.top - 0.5 * this.height;    this.bottom = this.top - this.height;    this.lines();    //this.clef(this.left, this.clefType, this.transposition);};Staff.prototype.getHeightForLayout = function() {    this.yMax = this.top;     this.yMin = this.top - 4 * this.g;    for (var b = 0; b < this.System.beamGroups.length; b ++) {        var beamGroup = this.System.beamGroups[b];        for (var e = 0; e < beamGroup.flattened.length; e ++) {            var event = beamGroup.flattened[e];            if (event.type === "event") {                for (var c = 0; c < event.components.length; c ++) {                    var performerID = event.components[c].performerID;                    var instrumentID = event.components[c].instrumentID;                    var graphID = event.components[c].graphID;                    if (                        performerID === this.performerID &&                        instrumentID === this.instrumentID &&                        graphID === this.graphID                    ) {                        var pitchINFO = event.components[c].pitchINFO;                        var pitchesRounded = [];                        for (var pitch in pitchINFO) {                            var parsedPitch = parseFloat(pitch);                            var roundedPitch = Math.round(parsedPitch * 4) / 4;                            pitchesRounded.push(roundedPitch);                        };                        pitchesRounded.numSort();                        var meanPitch = pitchesRounded.avg();                        this.manageClefAndTransposition(meanPitch);                        var pitchSpelling = new PitchSpelling(pitchesRounded);                        var spelledPitches = pitchSpelling.spelledPitches;                        for (var pitch in spelledPitches) {                            var pitchObj = spelledPitches[pitch];                            var vertDisplace = this.getSpacesFromMiddleC(                                pitch, pitchObj                            ) * this.g;                            var y = this.middleC + vertDisplace;                            if (y > this.yMax) this.yMax = y;                            if (y < this.yMin) this.yMin = y;                        };                    };                };            };        };    };    this.graphDisplaceFromTop = this.yMax;    this.graphDisplaceFromBottom = this.top - 4 * this.g - this.yMin;    this.totalHeight = this.yMax - this.yMin;    return this.totalHeight;};Staff.prototype.manageInitialClefAndTransposition = function() {    var info = new ClefAndTranspositionByInstrumentID(this.instrumentID);    this.clefType = info.initialClef;    this.transposition = info.initialTransposition;    this.middleC = this.middleCByClefAndTransposition(        this.clefType, this.transposition    );};Staff.prototype.manageClefAndTransposition = function(meanPitch) {    var info = new ClefAndTranspositionByInstrumentID(this.instrumentID);    var clefType = info.byMeanPitch(meanPitch).clef;    var transposition = info.byMeanPitch(meanPitch).transposition;    // If we are drawing, do the real thing!    if (this.clefs) {        if (clefType !== this.clefType || this.clefs.length === 0) {            this.clefType = clefType;            this.clefHasChanged = true;            this.transposition = transposition;            this.transpositionHasChanged = true;            this.clef(this.x, this.clefType, this.transposition);        };    }    // If we are just measuring for height, just adjust middleC!    else {        this.clefType = clefType;        this.transposition = transposition    };        this.middleC = this.middleCByClefAndTransposition(        this.clefType, this.transposition    );};Staff.prototype.getSpacesFromMiddleC = function(pitch, spellingObj) {    var octaveDisplace = (Math.floor((pitch - 60) / 12)) * 3.5;    var stepDisplace = spellingObj.step * 0.5;    var spacesFromMiddleC = octaveDisplace + stepDisplace;    return spacesFromMiddleC;}Staff.prototype.middleCByClefAndTransposition = function(clef, transposition) {    var middleCByClef = {        "bass": this.top + 1 * this.g,        "alto": this.top - 2 * this.g,        "treble": this.top - 5 * this.g    };    var middleC = middleCByClef[clef];    middleC += transposition * 3.5 * this.g;    return middleC;};Staff.prototype.managePitches = function(x, pitchINFO) {    this.x = x;    this.noteheads = [];    this.accidentals = [];    this.pitchesRounded = [];    for (var pitch in pitchINFO) {        var parsedPitch = parseFloat(pitch);        var roundedPitch = Math.round(parsedPitch * 4) / 4;        this.pitchesRounded.push(roundedPitch);    };    this.pitchesRounded.numSort();    this.meanPitch = this.pitchesRounded.avg();    this.manageClefAndTransposition(this.meanPitch);    this.maxNoteheadY = undefined;    this.minNoteheadY = undefined;    var pitchSpelling = new PitchSpelling(this.pitchesRounded);    var spelledPitches = pitchSpelling.spelledPitches;    for (var pitch in spelledPitches) {        var pitchObj = spelledPitches[pitch];        var vertDisplace = this.getSpacesFromMiddleC(pitch, pitchObj) * this.g;        var y = this.middleC + vertDisplace;        var type = pitchINFO[pitch].type;        var notehead = new Notehead(this, x, y, type);        this.noteheads.push(notehead);        if (!this.maxNoteheadY || y > this.maxNoteheadY) this.maxNoteheadY = y;        if (!this.minNoteheadY || y < this.minNoteheadY) this.minNoteheadY = y;        var coarse = pitchObj.coarse;        var fine = pitchObj.fine;        var aX = this.x - (1.2 * this.g);        var accidental = new Accidental(this, aX, y, coarse, fine);        this.accidentals.push(accidental);    };    this.manageLedgerLines();    this.noteheads.sort( function(a,b) { return a.y - b.y; } );    this.accidentals.sort( function(a,b) { return a.y - b.y; } );    this.resolveUnisonsAndSeconds();    // Do testing for unison / second instances here ---    var collision = new AccidentalCollision(this.accidentals);    for (var n = 0; n < this.noteheads.length; n ++) {        this.noteheads[n].draw(this.infoItemContext);        this.accidentals[n].draw(this.infoItemContext);    };    this.linePoints(x);};Staff.prototype.resolveUnisonsAndSeconds = function() {    for (var ai = 0, bi = ai + 1; ai < this.noteheads.length -1; ai ++) {        var a = this.noteheads[ai];        var b = this.noteheads[bi];        if (a.y === b.y || a.y === b.y - 0.5 * this.g) {            var Δa = this.stemDirection === 1 ? 0.45 * this.g : 0.5 * this.g;            var Δb = this.stemDirection === 1 ? 0.5 * this.g : 0.45 * this.g;            a.x -= Δa;            b.x += Δb;            this.accidentals[ai].move(-0.5 * this.g, 0);            this.accidentals[bi].move(-0.5 * this.g, 0);        };    };    };Staff.prototype.manageLedgerLines = function() {    var above = 0, below = 0;    if (this.maxNoteheadY >= this.top + this.g) {        var above = Math.round(            Math.floor(this.maxNoteheadY - this.top) / this.g        );    }    if (this.minNoteheadY <= this.bottom - this.g) {        var below = Math.abs(Math.round(            Math.ceil(this.minNoteheadY - this.bottom) / this.g        ));    };    this.ledgerLines(this.x, above, below);};Staff.prototype.lines = function() {    this.staffLine = [];    for (var i = 0; i < 5; i ++) {        this.staffLine[i] = this.graphItemContext.pathItems.add();        this.staffLine[i].strokeWidth = this.staffLineStrokeWidth;        this.staffLine[i].strokeColor = this.staffLineStrokeColor;        this.staffLine[i].filled = false;    };};Staff.prototype.linePoints = function(x) {    for (var i = 0; i < 5; i ++) {        var y = this.top - (i * this.g);        var staffLinePoint = this.staffLine[i].pathPoints.add();        staffLinePoint.anchor = [x, y];        staffLinePoint.rightDirection = staffLinePoint.anchor;        staffLinePoint.leftDirection = staffLinePoint.anchor;    };};Staff.prototype.ledgerLines = function(x, above, below) {    var yRefList = [this.top + this.g, this.bottom - this.g];    var dYList = [1,-1];    var dirList = [above, below];    for (var d = 0; d < 2; d ++) {        var amount = dirList[d];        for (var i = 0; i < amount; i ++) {            var x0 = x - 0.5 * this.ledgerLineLength;            var x1 = x + 0.5 * this.ledgerLineLength;            var y = yRefList[d] + (dYList[d] * i * this.g);            var ledgerLine = this.graphItemContext.pathItems.add();            ledgerLine.setEntirePath([[x0, y],[x1, y]]);            ledgerLine.strokeWidth = this.ledgerLineStrokeWidth;            ledgerLine.strokeColor = this.staffLineStrokeColor;            ledgerLine.filled = false;        };    };};Staff.prototype.clef = function(x, type, transposition) {    var x = x - this.clefDisplace;    if (this.clefs.length > 0) {          this.linePoints(x - this.newClefStaffLinesDisplace);    };    this.lines();    this.linePoints(x);    var clef = new Clef(this, x, type, transposition);    this.clefs.push(clef);};