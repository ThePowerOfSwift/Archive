function TupletBracketLigature(TupletBracket, x) {    // lineContext is group: lowest in Z-order of parent BeamGroup    // connectorContext is TupletBracket.graphicalContext    // Establish the things    this.TupletBracket = TupletBracket;    this.BeamGroup = this.TupletBracket.BeamGroup;    this.beamAltitude = this.BeamGroup.altitude;    this.beamWidth = this.BeamGroup.beamWidth;    this.bracketAltitude = this.TupletBracket.altitude;    this.bracketHeight = this.TupletBracket.bracketHeight;    this.tupletDepth = this.TupletBracket.tupletDepth;    this.stemDirection = this.TupletBracket.stemDirection;        this.x = x;    this.g = this.TupletBracket.g;    this.vertDisplace = 0.2 * this.g;    this.strokeWidth = this.TupletBracket.strokeWidth;    this.beamRef = this.beamAltitude + (this.stemDirection*0.5*this.beamWidth);    this.beamEnd = this.beamRef + (this.stemDirection * this.vertDisplace);    this.bracketOutside = (        this.bracketAltitude + (this.stemDirection * this.bracketHeight)    );    this.bracketInside = (        this.bracketAltitude - (this.stemDirection * this.vertDisplace)    );    this.lineContext = this.BeamGroup.ligatureContext;    this.connectorContext = this.TupletBracket.graphicalContext;    this.color = tupletColor[this.tupletDepth].lightColor;}TupletBracketLigature.prototype.begin = function(beamEnd) {    // shorten line with arrow slightly to avoid protrusion    var beamEnd = this.beamEnd + (        this.stemDirection * this.vertDisplace    );    var bracketEnd = this.bracketInside;    var isDashed = false;    var arrowTip = this.beamEnd;        this.line(beamEnd, bracketEnd, isDashed);    this.arrow(arrowTip, this.stemDirection);}TupletBracketLigature.prototype.end = function() {    // shorten line with arrow slightly to avoid protrusion    var beamEnd = this.beamEnd;    var bracketEnd = this.bracketInside - this.stemDirection * this.vertDisplace;    var isDashed = false;    var arrowTip = bracketEnd + (this.stemDirection * this.vertDisplace);        this.line(beamEnd, bracketEnd, isDashed);    this.arrow(arrowTip, -this.stemDirection);}TupletBracketLigature.prototype.reintroduce = function() {    // shorten line with arrow slightly to avoid protrusion    var beamEnd = this.beamEnd + (this.stemDirection * this.vertDisplace);    var bracketEnd = this.bracketOutside - this.stemDirection * 0.309 * this.g;    var isDashed = true;    var arrowTip = this.beamEnd;    // If reintroducing     if (this.checkForMiddleCollision()) {        bracketEnd -= this.stemDirection * 0.691 * this.g;        this.truncatingLine(bracketEnd);    }    else { this.circle(); };    this.line(beamEnd, bracketEnd, isDashed);    this.arrow(arrowTip, this.stemDirection);}TupletBracketLigature.prototype.line = function(beamEnd, bracketEnd, isDashed) {        var line = this.lineContext.pathItems.add();    line.setEntirePath([        [ this.x , bracketEnd ],        [ this.x , beamEnd ]    ]);    line.strokeWidth = this.strokeWidth;    line.strokeColor = this.color;    line.filled = false;    if (isDashed) line.strokeDashes = [ 0.2 * this.g ];}TupletBracketLigature.prototype.arrow = function(tip, direction) {    var width = 0.5 * this.g;    var height = 0.618 * this.g;    var concavity = 0.15 * this.g;    var points = [        [ this.x - (direction * 0.5 * width), tip + (direction * height) ],        [ this.x , tip ],        [ this.x + (direction * 0.5 * width), tip + (direction * height)],        [ this.x , tip + (direction * (height - concavity)) ]    ];    var arrow = this.connectorContext.pathItems.add();    arrow.setEntirePath(points);    arrow.closed = true;    arrow.stroked = false;    arrow.fillColor = this.color;};TupletBracketLigature.prototype.circle = function() {    var height = 0.618 * this.g;    var top = this.bracketOutside + (0.5 * height);    var left = this.x - (0.5 * height);    var circle = this.connectorContext.pathItems.ellipse(        top, left, height, height    );    circle.strokeWidth = this.strokeWidth;    circle.strokeColor = this.color;    circle.fillColor = white;};TupletBracketLigature.prototype.truncatingLine = function(y) {    var width = 0.875 * this.g;    var line = this.lineContext.pathItems.add();    line.setEntirePath([        [ this.x - (0.5 * width), y],        [ this.x + (0.5 * width), y]    ]);    line.strokeWidth = this.strokeWidth;    line.strokeColor = this.color;    line.filled = false;};TupletBracketLigature.prototype.checkForMiddleCollision = function() {    var center = this.TupletBracket.center;    var textWidths = this.TupletBracket.textWidths;    var graphicAdjust = this.TupletBracket.graphicAdjust;    var leftBound = center - (textWidths[0] + 1.75 * graphicAdjust);    var rightBound = center + (textWidths[1] + (1.75 * graphicAdjust));    if (this.x > leftBound && this.x < rightBound) {        return true;    };    return false;}