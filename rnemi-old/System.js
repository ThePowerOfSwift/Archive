#include "Measure.js"#include "Performer.js"#include "BeamGroupVoice.js"#include "rhythmTreeToSpanGroup.js" // for testing only!function System(Page, measureStart) {        // Establish the things    this.Page = Page;    this.primaryPerformerID = this.Page.primaryPerformerID;    this.performerOrder = this.Page.performerOrder;    this.top = this.Page.top - this.Page.margin;    this.left = this.Page.left + this.Page.margin;    this.g = this.Page.g;    this.beatWidth = this.Page.beatWidth;    this.measureList = this.Page.measureList;    this.measureStart = measureStart || 0;    this.setBeatIndex();        this.maxSystemRight = this.Page.maxSystemRight;    this.padLeft = 0.25 * 72; // make this variable at some point    this.instrumentDisplace = 0.125 * 72;    this.primaryPerformerG = 5;    this.supplementalPerformerScale = 0.75;    this.performerPad = 0.2 * 72;    this.timeSignatureHeight = 25;    this.measureNumberHeight = 10;    this.genericPad = 0.382 * this.g;    // Establish / do things with Ensemble-level PitchSpelling    // Do the things upon initialization    this.setMeasureRange();    this.manageVoices();    this.managePerformersForLayout();};System.prototype.setGraphicalContext = function(graphicalContext) {    this.graphicalContext = graphicalContext.layers.add();    this.graphicalContext.name = "System " + this.id;    this.layoutItemContext = this.graphicalContext.layers.add();    this.layoutItemContext.name = "LayoutItems";    this.graphItemContext = this.graphicalContext.layers.add();    this.graphItemContext.name = "GraphItems";    this.beamItemContext = this.graphicalContext.layers.add();    this.beamItemContext.name = "BeamItems";    this.infoItemContext = this.graphicalContext.layers.add();    this.infoItemContext.name = "InfoItems";};System.prototype.drawMeasures = function() {    for (var m = 0; m < this.measures.length; m ++) {        this.measures[m].draw(this.layoutItemContext);        if (m === this.measures.length - 1) {            var measure = this.measures[m];            var x = measure.left + measure.width;            this.measures[m].barline(x, "systemEnd");            // add line points to all present graphs?            for (var p = 0; p < this.performers.length; p ++) {                var graphs = this.performers[p].instruments[0].graphsByID;                for (var graphID in graphs) {                    if (graphID !== "cue") graphs[graphID].linePoints(x);                };            };        };    };};System.prototype.managePerformersForLayout = function() {    this.performersByPerformerID = {};    this.performers = [];     for (var p = 0; p < this.performersPresentByID.length; p ++) {        var performerID = this.performersPresentByID[p];        var performer = new Performer(this, performerID);        this.performers.push(performer);        this.performersByPerformerID[performerID] = performer;    };};System.prototype.repositionPerformers = function() {    this.height = 0;    var performerTop = this.top;    for (var p = 0; p < this.performers.length; p ++) {        //// this.testLine(performerTop)        var performer = this.performers[p];        performer.top = performerTop;        performer.left = this.left;        performer.repositionInstruments();        performer.testRect();        performerTop -= performer.height + this.performerPad;        var pad = p > 0 ? this.performerPad : 0;        this.height += performer.height + pad;    };};System.prototype.getHeightForLayout = function() {    var genericPad = 0.05 * 72;    // Add height for timeSignature (static)    // Add genericPad    this.voicePad = 0.125 * 72;        this.height = 0;    // Add height for each Performer    for (var p = 0; p < this.performers.length; p ++) {        var performer = this.performers[p];        var height = performer.getHeightForLayout();        var pad = p > 0 ? this.performerPad : 0;        this.height += height/* + pad;*/    };    // Add heights for each BeamGroupVoice    for (var v = 0; v < this.voices.length; v ++) {        var voice = this.voices[v];        var dynamicHeight = 2.36 * voice.g; // static now for testing, disgusting        var height = (            voice.beamHeight +             voice.bracketDisplace * voice.g +             voice.bracketHeight +            voice.displaceFromGraph +            dynamicHeight // gross, make variable later        );        var pad = v > 0 ? this.voicePad : 0;        this.height += height + pad;    };    this.height += this.measureNumberHeight;    this.height += this.timeSignatureHeight;    this.height += 2.5 * this.genericPad // this is the worst thing ever done    // THIS IS COMPENSATING FOR THINGS NOT ADDING UP AS THEY SHOULD MUST CHANGE!    return this.height;};System.prototype.manageVoices = function() {        this.beamGroups = [];    this.performersPresentByID = [];    this.voices = []; // organized by performersPresent    for (var m = this.measureStart; m <= this.measureEnd; m ++) {        var measure = this.measureList[m];        var spanGroups = measure.spanGroups;        for (var s = 0; s < spanGroups.length; s ++) {            var spanGroup = spanGroups[s];            var curBeatIndex = spanGroup.beatIndex - this.beatIndex;            var beamGroup = new BeamGroup(spanGroup);            var events = beamGroup.flattened;            beamGroup.performersPresentByID = [];            for (var e = 0; e < events.length; e ++) {                var event = events[e];                var components = event.components;                for (var c = 0; c < components.length; c ++) {                    var component = components[c];                    var performerID = component.performerID;                    // If necessary, add to beamGroup.performersPresent;                    if (!beamGroup.performersPresentByID.contains(performerID)) {                        beamGroup.performersPresentByID.push(performerID);                        beamGroup.performersPresentByID.sort();                    };                    // If necessary, add to this system.performersPresent;                    if (!this.performersPresentByID.contains(performerID)) {                        this.performersPresentByID.push(performerID);                        this.performersPresentByID.sort();                    };                };            };            this.beamGroups.push(beamGroup);        };    };    // Check for unique performer combinations to create unique voices    for (var b = 0; b < this.beamGroups.length; b ++) {        var beamGroup = this.beamGroups[b];        if (this.voices.length === 0) { this.newVoiceWithBeamGroup(beamGroup); }        else {            var match = false;            for (var v = 0; v < this.voices.length; v ++) {                var voice = this.voices[v];                if (voice.performersPresentByID.equals(                    beamGroup.performersPresentByID                )) {                    match = true;                    voice.beamGroups.push(beamGroup);                    break;                };            };            if (match === false) this.newVoiceWithBeamGroup(beamGroup);        };    };    // Once each of the voices have been pregnated with beamGroups: manageStrata    for (var v = 0; v < this.voices.length; v ++) {        this.voices[v].manageStrata();    };};System.prototype.repositionAllForDrawing = function() {    // for testing!! but this is a nice start    for (var v = 0; v < this.voices.length; v ++) {        var voice = this.voices[v];        voice.left = this.left;    };    this.setMaxAmountPerformersInVoices();    if (this.maxAmountPerformersInVoices === 1) {         this.singleVoicePerPerformer();     }    else if (this.maxAmountPerformersInVoices > 1) {        // more complex action needed    }};System.prototype.singleVoicePerPerformer = function() {    // create beamGroupVoice object with keys: performerID    this.createVoiceByPerformerID();    // Need to get info re: yMax, yMin of performer for initAltitude    var performerTop = this.top - (        this.measureNumberHeight + this.timeSignatureHeight + this.genericPad    );    for (var pID = 0; pID < this.performerOrder.length; pID ++) {        // this.testLine(performerTop);        var performerID = this.performerOrder[pID];        for (var p = 0; p < this.performers.length; p ++) {            var performer = this.performers[p];            if (performerID === performer.performerID) {                var voice = this.voiceByPerformerID[performerID];                voice.setDimensionsForLayout();                // Primary performer: stems up, voice below "fingered" graph                if (performerID === this.primaryPerformerID) {                    voice.initStemDirection = -1;                    // Add voice components here (probably somewhere cleaner later)                    var voiceHeight = (                        voice.displaceFromGraph +                         voice.beamHeight                    );                    voice.initAltitude = (                        performerTop -                         performer.height -                         voiceHeight                    );                    // this.testLine(voice.initAltitude);                    voice.dynamicStratum = new DynamicStratum(voice);                    voice.dynamicStratum.g = 0.618 * this.g;                    var dynamicHeight = voice.dynamicStratum.getHeightForLayout();                    var dynamicPad = voice.dynamicStratum.g;                    voice.dynamicStratum.altitude = performerTop - (                        voiceHeight +                         voice.bracketDisplace * voice.g +                        voice.bracketHeight +                        performer.height +                         dynamicPad +                         0.5 * dynamicHeight                    );                    // this.testLine(voice.dynamicStratum.altitude);                    performer.top = performerTop;                    performer.left = this.left;                    performer.repositionInstruments();                                    }                // Supplementary performer: stems down; voice above "sounding"                else {                    var voiceHeight = voice.bracketDisplace * voice.g;                    voice.initStemDirection = 1;                    voice.initAltitude = performerTop - voiceHeight;                                        // Add voice components here (probably somewhere cleaner later)                    var voiceHeight = (                        voice.beamHeight +                         voice.bracketDisplace * voice.g +                         voice.bracketHeight +                        voice.displaceFromGraph                    );                    var initAltitude = performerTop - voiceHeight;                    performer.top = performerTop - voiceHeight;                    // this.testLine(performer.top);                    performer.left = this.left;                    performer.repositionInstruments();                    voice.dynamicStratum = new DynamicStratum(voice);                    voice.dynamicStratum.g = 0.618 * 0.618 * this.g;                    var dynamicHeight = voice.dynamicStratum.getHeightForLayout();                    var dynamicPad = 2 * voice.dynamicStratum.g;                    voice.dynamicStratum.altitude = performerTop - (                        voiceHeight +                         performer.height +                         dynamicHeight +                         dynamicPad                    );                    // this.testLine(voice.dynamicStratum.altitude);                };                voice.repositionStrata();                                for (var i = 0; i < performer.instruments.length; i ++) {                    var instrument = performer.instruments[i];                    var graphOrder = instrument.graphOrder;                    for (var g = 0; g < graphOrder.length; g ++) {                        if (graphOrder[g] in instrument.graphsByID) {                            var graph = instrument.graphsByID[graphOrder[g]];                            graph.draw(this.graphItemContext);                        };                    };                };                performer.draw(this.graphItemContext);                // proceed downward                var voiceHeight = (                    voice.beamHeight +                     voice.bracketDisplace * voice.g +                    voice.bracketHeight +                     voice.displaceFromGraph                );                var dynamicHeight = voice.dynamicStratum.height;                var dynamicPad = 0.5 * voice.dynamicStratum.g;                performerTop -= (                    performer.height + voiceHeight + this.performerPad +                    dynamicHeight/* + dynamicPad*/                );            };        };    };};System.prototype.createVoiceByPerformerID = function() {    this.voiceByPerformerID = {};    for (var v = 0; v < this.voices.length; v ++) {        var voice = this.voices[v];        var performerID = voice.performersPresentByID;        this.voiceByPerformerID[performerID] = voice;    };};System.prototype.setMaxAmountPerformersInVoices = function() {    this.maxAmountPerformersInVoices;    for (var v = 0; v < this.voices.length; v ++) {        var voice = this.voices[v];        var amountPerf = voice.performersPresentByID.length;        if (!this.maxAmountPerformersInVoices ||             amountPerf > this.maxAmountPerformersInVoices        ) {            this.maxAmountPerformersInVoices = amountPerf;        };    };};System.prototype.newVoiceWithBeamGroup = function(beamGroup) {    var voice = new BeamGroupVoice(this);    voice.performersPresentByID = beamGroup.performersPresentByID;    voice.beamGroups = [ beamGroup ];    this.scaleVoiceByRole(voice);    this.voices.push(voice);};System.prototype.setMeasureRange = function() {    this.measures = [];    this.measureIndex = this.measureStart;    this.width = 0;    // Clean up situation with initial system > performer > instrument > graph pad    var measureLeft = this.left + this.padLeft + 0.5 * this.instrumentDisplace;    while (        measureLeft < this.maxSystemRight &&         this.measureIndex < this.measureList.length    ) {        this.addMeasure(measureLeft);        measureLeft += this.measures.last().width;        this.measureIndex ++;    };    // This feels dirty and of type: symptom-treatment    if (this.measures.length === 0) {         this.measureEnd = this.measureList.length - 1;    } else { this.measureEnd = this.measures.last().index; };    this.measureRange = [this.measureStart, this.measureEnd];};System.prototype.addMeasure = function(measureLeft) {    var measure = new Measure(        this, measureLeft, this.top, this.measureIndex    );    if (measureLeft + measure.width <= this.maxSystemRight) {        this.measures.push(measure);        this.width += measure.width;    };};System.prototype.breakHash = function(x) {    var xDir = [-1,1,1,-1];    var yDir = [1,1,-1,-1];    var slope = 0.1618;    var length = 0.33 * 72;    var slope = 0.1618;    var width = 0.04 * 72;    var displace = 0.75 * width;    var y = this.top - this.height - 0.382 * this.Page.systemPad;    for (var i = -1; i < 2; i += 2) {        var points = [];        for (var p = 0; p < 4; p ++) {            var xDisplace = (i * xDir[p]) * 0.5 * length;            var yDisplace = (slope * xDisplace) + i * yDir[p] * 0.5 * width;            var pX = x + xDisplace;            var pY = y + yDisplace + i * displace;            points.push([pX, pY]);        };        var bar = this.layoutItemContext.pathItems.add();        bar.setEntirePath(points);        bar.closed = true;        bar.stroked = false;        bar.fillColor = gray[20];    };}System.prototype.scaleVoiceByRole = function(voice) {    // Set scaling of BeamGroupVoice // Stratum // BeamGroup based on Role    if (voice.performersPresentByID.contains(this.primaryPerformerID)) {        voice.g = this.primaryPerformerG;    }     else {         voice.g = this.supplementalPerformerScale * this.primaryPerformerG;     };};System.prototype.setBeatIndex = function() {    this.beatIndex = 0;    for (var m = 0; m < this.measureStart; m ++) {        var beats = this.measureList[m].beats;        var subdivision = this.measureList[m].subdivision;        this.beatIndex += (beats / subdivision) * 8;    };}System.prototype.testBeamGroups = function() {    for (var v = 0; v < this.voices.length; v ++) {        var voice = this.voices[v];        voice.testBeamGroups();    };};System.prototype.testLine = function(y) {    var left = this.Page.left;    var right = this.Page.right;    var line = this.layoutItemContext.pathItems.add();    line.setEntirePath([[left, y],[right, y]]);    line.strokeWidth = 0.25;    line.strokeColor = green_dark;    line.filled = false;    //line.locked = true;};System.prototype.testRect = function() {        var rect = this.layoutItemContext.pathItems.rectangle(        this.top, this.left, this.width, this.height    );    rect.strokeWidth = 0.618;    rect.strokeDashes = [3];    rect.strokeColor = red_dark;    rect.filled = false;    //rect.fillColor = red_light;    rect.opacity = 33;    rect.locked = true;};