#include "TupletBracketGraphic.js"function TupletBracket(    group,     n,     d,     beatStructure,    subdivision,    amountBeams,    beatScale,    tempoScale,    tempo,    left,     width,    altitude,     dir_vert) {        curTupletBracket = this;    this.g = curBeamGroup.g;        this.n = n;    this.d = d;        this.subdivision = subdivision;    this.amountBeams = amountBeams;    this.beatStructure = beatStructure;        //$.writeln("TupletBracket; this.beatStructure: " + this.beatStructure);        this.left = left;    this.altitude = altitude;    this.height = 0.85*this.g;    this.width = width;    this.right = this.left + this.width;    this.center = this.left + .5*this.width;        this.depth = curBeamGroup.curTupletDepth;    this.beatScale = beatScale * (d / n);    this.tempoScale = tempoScale * (n / d);    this.tempo = (60 * this.tempoScale); // make variable        this.tupletBracketGroup = group.groupItems.add();        this.strokeWidth = .0809*this.g;        // Default padding    this.paddingRight = .5*this.g;            // Vertical direction (stems-down = +1, stems-up = -1)    this.dir_vert = dir_vert;       this.graphic();    this.text();    this.bracket();        // Draw metronome, adjust things (not yet, getting there);    if (curBeamGroup.isExpanded === true) this.metronome();}TupletBracket.prototype.incomplete = function() {        // SOMETHING HERE AT SOME POINT};TupletBracket.prototype.text = function() {        var text = [this.n, this.d];    var textSize = 1.5*this.g;    var textScale = .382*textSize;    var font = app.textFonts.getByName("AvenirNextCondensed-Regular");    var color = tupletColor[curBeamGroup.curTupletDepth].darkColor;        // Create array for [n, d] text adjust    this.textWidths = [];        //this.textTop = [3*this.g, 1.5*this.g];    this.textTop = {                "-1": 1.45*this.g,        "1": 1.45*this.g    };        this.dir_horiz = [1, -1];        var textDisplacement = [];    var justify = [Justification.RIGHT, Justification.LEFT];        // Iterate through both numbers    for (var t = 0; t < 2; t ++) {                var tupletText = this.tupletBracketGroup.textFrames.add();        tupletText.contents = text[t];        tupletText.top =             this.altitude +             this.dir_vert*this.height +             this.textTop[this.dir_vert];        tupletText.left = this.center - this.dir_horiz[t]*this.graphicAdjust;        tupletText.textRange.paragraphAttributes.justification = justify[t];        tupletText.textRange.characterAttributes.size = textSize;        tupletText.textRange.characterAttributes.fillColor = color;        tupletText.textRange.characterAttributes.textFont = font;                var width = text[t].toString().length*textScale;        this.textWidths.push(width);    };};TupletBracket.prototype.graphic = function() {        // Call method to draw TupletBracketGraphic    var tupletBracketGraphic = new TupletBracketGraphic(        this.center,        this.altitude + (this.dir_vert * (this.height - 0.1 * this.g)),        this.g,        this.dir_vert,        this.amountBeams,        this.tupletBracketGroup    );    // Throw out into the object space for reference (this should be cleaned)    this.graphicWidth = 0.5*this.g;    this.graphicPadding = 0.382*this.g;    this.graphicAdjust = .5*this.graphicWidth + this.graphicPadding;};TupletBracket.prototype.bracket = function() {        var xRef = [this.left, this.left + this.width - this.paddingRight];    var yRef = this.altitude;        var color = tupletColor[this.depth].lightColor;    //var color = gray[50];        var angleRight = 0.2*this.g;    // Iterate through both sides of bracket    for (var b = 0; b < 2; b ++) {                var lengths = [                0.5*this.width - this.graphicAdjust - this.graphicPadding                - this.textWidths[b],                            0.5*this.width - this.graphicAdjust - this.textWidths[b] -                this.graphicPadding - this.paddingRight        ];                var bracket = this.tupletBracketGroup.pathItems.add();                var points = [            [                xRef[b],                 yRef            ],            [                xRef[b] - b*angleRight,                 yRef + this.dir_vert*this.height            ],            [                xRef[b] + this.dir_horiz[b]*lengths[b],                 yRef + this.dir_vert*this.height            ]        ];                // Iterate through three points        for (var p = 0; p < 3; p ++) {                        var point = bracket.pathPoints.add();            point.anchor = points[p];            point.leftDirection = point.anchor;            point.rightDirection = point.anchor;        };                bracket.strokeWidth = this.strokeWidth;        bracket.strokeColor = color;        bracket.filled = false;    };};TupletBracket.prototype.dashed = function() {        // SOMETHING};TupletBracket.prototype.arrow = function(x, tip, direction) {        var width = 0.5 * this.g;    var height = 0.618 * this.g;    var concavity = 0.15 * this.g;        var color = tupletColor[curBeamGroup.curTupletDepth].lightColor;    //var color = gray[50];        var arrow = curBeamGroup.lineGroup.pathItems.add();        arrow.setEntirePath([        [            x - direction * 0.5 * width,            tip + direction * height        ],        [            x,            tip        ],        [            x + direction * 0.5 * width,            tip + direction * height        ],        [            x,            tip + direction * (height - concavity)          ]    ]);        arrow.stroked = false;    arrow.fillColor = color    arrow.closed = true;};TupletBracket.prototype.circle = function(x) {        var height = 0.618 * this.g;        var color = tupletColor[curBeamGroup.curTupletDepth].lightColor    //var color = gray[50];        var circle = this.tupletBracketGroup.pathItems.ellipse(            this.altitude + (this.dir_vert*this.height) + (0.5 * height),        x - 0.5 * height,        height,        height    );    circle.strokeWidth = this.strokeWidth;    circle.strokeColor = color;    circle.fillColor = white;};TupletBracket.prototype.horizLine = function(x, y) {        var color = tupletColor[curBeamGroup.curTupletDepth].lightColor;    var width = 0.875 * this.g;        var line = curBeamGroup.lineGroup.pathItems.add();        line.setEntirePath([        [x - (0.5 * width), y],        [x + (0.5 * width), y]    ]);    line.strokeWidth = this.strokeWidth;    line.strokeColor = color;    line.filled = false;};TupletBracket.prototype.line = function(x, type) {        var color = tupletColor[this.depth].lightColor;    //var color = gray[50];        var line = curBeamGroup.lineGroup.pathItems.add();        var displace = 0.1618 * this.g;    var beamWidth_displace = 0.5 * curBeamGroup.beam_strokeWidth;        var lineBegin = this.altitude - this.dir_vert * displace;        var lineEnd = curBeamGroup.altitude +         this.dir_vert * (displace + (2 * beamWidth_displace));        if (type === "begin") {        // inward arrow, solid        var arrowTip = curBeamGroup.altitude +             this.dir_vert * (displace + beamWidth_displace);                var arrowDirection = this.dir_vert;    }    else if (type === "end") {              // outward arrow, solid        var arrowTip = this.altitude - this.dir_vert * displace;        var arrowDirection = -1 * this.dir_vert;    }    else if (type === "reintroduce") {                var lineBegin = this.altitude + this.dir_vert * this.height;        // if within center text region, no square, adjust lineEnd, horiz line        if (            x > this.center - (                this.textWidths[0] +                 1.75 * this.graphicAdjust               ) &&            x < this.center + (                this.textWidths[1] +                1.75 * this.graphicAdjust            )        ) {            //  Adjust lineBegin            lineBegin -= this.dir_vert * 0.95 * this.g;                        // Draw horizontal line to ease feel of centered activity            this.horizLine(x, lineBegin);        }        // If not within center region        else {                        // Draw square on tuplet bracket            this.circle(x);        }        // inward arrow, solid        var arrowTip = curBeamGroup.altitude +             this.dir_vert * (displace + beamWidth_displace);                var arrowDirection = this.dir_vert;                // SOMETHING with dashes and square with white fill        line.strokeDashes = [0.2 * this.g];    }        line.setEntirePath([        [x, lineBegin],        [x, lineEnd]    ]);        line.strokeWidth = this.strokeWidth;    line.strokeColor = color;    line.filled = false;        this.arrow(x, arrowTip, arrowDirection);}TupletBracket.prototype.metronome = function() {        // left, altitude, g, agogicPrototype, depth, group    this.agogicPrototype = {                "beatStructure": this.beatStructure,        "subdivision": levelToSubd(this.amountBeams), // digusting        "beatScale": this.beatScale,        "tempoScale": this.tempoScale,        "tempo": this.tempo    };    var paddingVert = 0.382;    var clickHeight = curBeamGroup.clickHeightAtDepth[this.depth];        var metronome = new Metronome(        this.left,        this.altitude - this.dir_vert * (paddingVert + 0.5 * clickHeight) * this.g,        this.g,        this.agogicPrototype,        this.depth,        this.tupletBracketGroup    );}