#include "BeamGroupStratum.js"#include "DynamicStratum.js"function BeamGroupVoice(System) {    this.System = System;    this.primaryPerformerID = this.System.primaryPerformerID;    this.beatIndex = this.System.beatIndex;    this.beatWidth = this.System.beatWidth;    this.left = this.System.left + this.System.padLeft;    this.strata = [];    this.g = 5;}BeamGroupVoice.prototype.repositionStrata = function() {    for (var s = 0; s < this.strata.length; s ++) {        var stratum = this.strata[s];        var beamHeight = stratum.greatestSubdLevel * stratum.beamDisplace;        var bracketDisplace = stratum.bracketDisplaceAtDepth[0];        var bracketHeight = stratum.bracketHeight;        stratum.altitude = this.initAltitude;        stratum.stemDirection = this.initStemDirection;    };};BeamGroupVoice.prototype.setDimensionsForLayout = function() {    var displace = 0;    //var fromGraph = this.stratumArrangement === "stacking" ? this.g : 2*this.g;    this.beamHeight = 0;    this.bracketDisplace = 0;    this.bracketHeight = 0;    this.displaceFromGraph = 0;    for (var s = 0; s < this.strata.length; s ++) {        var stratum = this.strata[s];        this.beamHeight += stratum.greatestSubdLevel * stratum.beamDisplace;        this.bracketDisplace += stratum.bracketDisplaceAtDepth[0];        this.bracketHeight += stratum.bracketHeight;        this.displaceFromGraph += this.g;    };    this.bracketDisplace += 0.5 * this.g;};BeamGroupVoice.prototype.manageStrata = function() {        this.amountBeamGroupsDistributed = 0;    this.beamGroupsDistributed = [];    this.stratumIndices;    this.floatingIndices = [];    if (this.beamGroups.length === 1) {        this.stratumIndices = [[0]];    }    else {        for (var ai = 0; ai < this.beamGroups.length - 1; ai ++) {            for (var bi = ai + 1; bi < this.beamGroups.length; bi ++) {                var a = this.beamGroups[ai];                var beginA = a.beatIndex;                var endA = beginA + a.widthInBeats;                var b = this.beamGroups[bi];                var beginB = b.beatIndex;                var endB = beginB + b.widthInBeats;            };        }        for (var ai = 0; ai < this.beamGroups.length - 1; ai ++) {            for (var bi = ai + 1; bi < this.beamGroups.length; bi ++) {                if (!this.beamGroupsDistributed.contains(ai) ||                    !this.beamGroupsDistributed.contains(bi)                ){                    var relationship = this.compareBeamGroups(ai, bi);                    this[relationship](ai, bi);                };            };         };    };    // CLEAN THIS UP FOR GODS SAKE    // at a more refined state, check for collisions here: this is cheating    if (!this.stratumIndices) {        this.stratumIndices = [];        this.stratumIndices[0] = this.floatingIndices;    }    else if (this.floatingIndices.length > 0) {        for (var f = 0; f < this.floatingIndices.length; f ++) {            this.stratumIndices[0].push(this.floatingIndices[f]);        };    };    for (var s = 0; s < this.stratumIndices.length; s ++) {        t.w(this.stratumIndices[s]);    };    // At this point, all strata have been organized; now create them!    for (var s = 0; s < this.stratumIndices.length; s ++) {        var stratum = new BeamGroupStratum(this);        this.stratumIndices[s].numSort();        stratum.beamGroups = [];        var start = this.stratumIndices[s][0];        var end = this.stratumIndices[s].last();        for (var i = start; i <= end; i ++) {            var beamGroup = this.beamGroups[i];            beamGroup.setStratum(stratum);            stratum.beamGroups.push(beamGroup);        };        stratum.manageBeamGroups();        this.strata.push(stratum);    };    this.setDimensionsForLayout();};BeamGroupVoice.prototype.none = function(ai, bi) {    if (!this.beamGroupsDistributed.contains(ai) &&        !this.floatingIndices.contains(ai)    ) { this.floatingIndices.push(ai); }    if (!this.beamGroupsDistributed.contains(bi) &&        !this.floatingIndices.contains(bi)    ) { this.floatingIndices.push(bi); };}BeamGroupVoice.prototype.chain = function(ai, bi) {        if (!this.stratumIndices) {        if (this.floatingIndices.contains(ai)) {            this.floatingIndices.remove(ai);        };        if (this.floatingIndices.contains(bi)) {            this.floatingIndices.remove(bi);        };        this.stratumIndices = [[ai,bi]];        this.beamGroupsDistributed.push(ai,bi);    }    else {        // check if one of the chain pair memebers already placed        var matchFound = false;        var s = 0;        var m, u;        while (s < this.stratumIndices.length) {            var stratum = this.stratumIndices[s];            if (stratum.contains(ai) && !stratum.contains(bi)) {                // ai match                m = ai, u = bi;                matchFound = true;                break;            }            else if (stratum.contains(bi) && !stratum.contains(ai)) {                // bi match                m = bi; u = ai;                matchFound = true;                break;            };            s ++;        };        if (matchFound === false) {            // add the chain pair to floatingIndices            if (!this.floatingIndices.contains(ai)) {                this.floatingIndices.push(ai);            };            if (!this.floatingIndices.contains(bi)) {                this.floatingIndices.push(bi);            };        }        else {            // check if there is overlapping between unmatched and already placed            var overlapping = true;            var stratum = this.stratumIndices[s];            for (var i = 0; i < stratum.length; i ++) {                var cur = stratum[i];                var relationship = this.compareBeamGroups(m, cur);                if (relationship === "overlap") {                    overlapping = true;                    break;                }                else if (relationship !== "overlap") {                    overlapping = false;                    break;                };            };            if (overlapping) { this.overlap(ai, bi); }            else if (!overlapping) {                if (this.floatingIndices.contains(u)) {                    this.floatingIndices.remove(u);                };                stratum.push(u);                this.beamGroupsDistributed.push(u);            };        };    };};BeamGroupVoice.prototype.overlap = function(ai, bi) {    if (!this.stratumIndices) {        if (this.floatingIndices.contains(ai)) {            this.floatingIndices.remove(ai);        };        if (this.floatingIndices.contains(bi)) {            this.floatingIndices.remove(bi);        };        this.stratumIndices = [[ai],[bi]];         this.beamGroupsDistributed.push(ai, bi);    }    else {        var m, u;        for (var s = 0; s < this.stratumIndices.length; s ++) {            var stratum = this.stratumIndices[s];            if (stratum.contains(ai) && !stratum.contains(bi)) {                m = ai; u = bi;             }            else if (stratum.contains(bi) && !stratum.contains(ai)) {                m = bi; u = ai;             };        };        // Check if possible to chain unmatched value to any present stratum        var overlapping = true;        for (var s = 0; s < this.stratumIndices.length; s ++) {            var stratum = this.stratumIndices[s]            var chainable = false;            for (var i = 0; i < stratum.length; i ++) {                var cur = stratum[i];                var relationship = this.compareBeamGroups(cur, u);                t.w("relationship: " + relationship);                if (relationship === "overlap") {                     chainable = false;                    break;                 }                else if (relationship === "chain") { chainable = true; }            };            if (chainable) {                if (this.floatingIndices.contains(u)) {                    this.floatingIndices.remove(u);                };                stratum.push(u);                this.beamGroupsDistributed.push(u);                overlapping = false;                break;            };        };        // Create whole new stratum        if (overlapping) {            if (this.floatingIndices.contains(u)) {                this.floatingIndices.remove(u);            };            this.stratumIndices.push([u]);            this.beamGroupsDistributed.push(u);        };    };};BeamGroupVoice.prototype.compareBeamGroups = function(ai, bi) {        // returns either "chain", "overlap", or "none"    var relationship;    var a = this.beamGroups[ai];    var beginA = a.beatIndex;    var endA = beginA + a.widthInBeats;    var b = this.beamGroups[bi];    var beginB = b.beatIndex;    var endB = beginB + b.widthInBeats;    if (endA === beginB || endB === beginA) { return "chain"; }    else if (         (beginA >= beginB && beginA <= endB) ||         (endA >= beginB && endA <= endB)    ) { return "overlap"; }     else { return "none"; };};BeamGroupVoice.prototype.getHeightForLayout = function() {    this.stratumPad = 0.125 * 72;    this.height = 0;    for (var s = 0; s < this.strata.length; s ++) {        var pad = s > 0 ? this.stratumPad : 0;        var height = this.strata[s].getHeightForLayout();        this.height += height + pad;    };    return this.height;};BeamGroupVoice.prototype.testBeamGroups = function() {    this.graphicalContext = this.System.graphicalContext;    for (var s = 0; s < this.strata.length; s ++) {        this.strata[s].testBeamGroups();    };};