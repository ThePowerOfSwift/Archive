#include "colors.js"function Accidental(Graph, x, y, coarse, fine) {    // Dimensional attributes    this.Graph = Graph;    this.x = x || 400;    this.y = y || 400;    this.g = this.Graph.g;    // Semantic attributes    this.coarse = coarse;    this.fine = fine;    this.fineDirection = this.fineToDirection(this.fine);    this.coarseDirection = this.coarseToDirection(this.coarse);    this.type = this.coarseToType(coarse);    this.graphicalDimensions();    // Establish the initial dimensions of this accidental, without drawing    this[this.type](fine);    this.getBoundingDimensions();};Accidental.prototype.graphicalDimensions = function() {    // Graphical attributes    this.color = black; // Variable later    this.boundingPadding = 0.1 * this.g;    this.midWidth = 0.4125 * this.g;    this.thinLine_width = 0.0625 * this.g;    this.thickLine_width = 0.309 * this.g;    this.thickLine_slope = 0.25;    this.arrow_width = 1.5 * this.midWidth;    this.arrow_height = 0.4 * this.g;    this.arrow_thickness = 0.1382 * this.g;    this.dimensions = {};    this.dimensions.body = {};    this.dimensions.body.components = [];    this.dimensions.columns = [];    this.xMax = 0;    this.xMin = 0;    this.yMax = 0;    this.yMin = 0;};Accidental.prototype.draw = function(graphicalContext) {    this.accidentalGroup = graphicalContext.groupItems.add();    // Add all components as necessary to this group    for (var zone in this.dimensions) {        if (zone === "body") {            for (var c = 0; c < this.dimensions.body.components.length; c ++) {                var curComponent = this.dimensions.body.components[c];                for (var component in curComponent) {                    var properties = curComponent[component];                                        // Draw this component with these properties                    this[component](properties);                };            };        }        else if (zone === "columns") {            for (var c = 0; c < this.dimensions.columns.length; c ++) {                var curColumn = this.dimensions.columns[c];                var curComponent = curColumn.components;                for (var component in curComponent) {                    var properties = curComponent[component];                                        // Draw this component with these properties                    this[component](properties);                };            };        }        else if (zone === "arrow") {            for (var component in this.dimensions.arrow.components) {                var properties = this.dimensions.arrow.components[component];                // Draw this component with these properties                this[component](properties);            };        };    };};Accidental.prototype.move = function(dx, dy) {    // Change all x val    for (var zone in this.dimensions) {                if (zone === "body") {            // Change bounding shape            var boundingShape = this.dimensions.body.boundingShape;            for (var p = 0; p < boundingShape.length; p ++) {                this.dimensions.body.boundingShape[p][0] += dx;                this.dimensions.body.boundingShape[p][1] += dy;            };            // Change dimensions of body shape            for (var c = 0; c < this.dimensions.body.components.length; c ++) {                for (var component in this.dimensions.body.components[c]) {                    this.dimensions.body.components[c][component].x += dx;                };            };        }        else if (zone === "columns") {            for (var c = 0; c < this.dimensions.columns.length; c ++) {                // Change bounding shape                var boundingShape = this.dimensions.columns[c].boundingShape;                for (var p = 0; p < boundingShape.length; p ++) {                    this.dimensions.columns[c].boundingShape[p][0] += dx;                    this.dimensions.columns[c].boundingShape[p][1] += dy;                };                for (var component in this.dimensions.columns[c].components) {                    this.dimensions.columns[c].components[component].x += dx;                };            };        }        else if (zone === "arrow") {            var boundingShape = this.dimensions.arrow.boundingShape;            for (var p = 0; p < boundingShape.length; p ++) {                this.dimensions.arrow.boundingShape[p][0] += dx;                this.dimensions.arrow.boundingShape[p][1] += dy;            };            this.dimensions.arrow.components.arrow.x += dx;        };    };}// BASIC ACCIDENTAL TYPES -----------------------------------------------------Accidental.prototype.natural = function() {    // Thick line attributes    var length = this.midWidth + this.thinLine_width;    var width = this.thickLine_width;    var vert_displace = 0.382 * this.g;    var slope = this.thickLine_slope;    if (this.fine !== 0) {        var x = this.x - this.fineDirection * 0.5 * this.midWidth;        var tip = this.y + this.fineDirection * 1.95 * this.g;        var direction = this.fineDirection;        this.arrow_dimensions(x, tip, direction);    };    // Push dimensional attributes of both pairs of thick / thin lines    for (var i = -1; i < 2; i += 2) {        var x = this.x + (i * 0.5 * this.midWidth);        var y0 = this.y + (i * 0.5 * this.g);        var y1 = this.y - (i * ((0.5 + 0.618) * this.g));        if (this.fineDirection === -1*i) {            y1 = this.y + this.fineDirection * 1.85 * this.g;        };        this.thinLine_dimensions(x, y0, y1);        var y = this.y + (i * vert_displace);        this.thickLine_dimensions(y, length);    };    var pad = this.boundingPadding;    // Vertices of body bounding shape    var vertices = [        [            // top left            this.x - 0.5 * (this.midWidth + this.thinLine_width),            this.y + vert_displace + (slope*(-0.5*length)) + (0.5*width) + pad        ],        [            // top right            this.x + 0.5 * (this.midWidth + this.thinLine_width),            this.y + vert_displace + (slope*(0.5*length)) + (0.5*width) + pad        ],        [            // bottom right            this.x + 0.5 * (this.midWidth + this.thinLine_width),            this.y - vert_displace + (slope*(0.5*length)) - (0.5*width) - pad        ],        [            // bottom left            this.x - 0.5 * (this.midWidth + this.thinLine_width),            this.y - vert_displace + (slope*(-0.5*length)) - (0.5*width) - pad        ]    ];    this.dimensions.body.maxDimensions = this.maxDimensions(vertices);    this.boundingDimensions(vertices);    // Push bounding shape of wholy body up to this.dimensions    this.dimensions.body.boundingShape = vertices;};Accidental.prototype.sharp = function(fine) {    var length = 1.618 * this.midWidth;    var width = this.thickLine_width;    var vert_displace = 0.382 * this.g;    var slope = this.thickLine_slope;    if (this.fine !== 0) {        var x = this.x + (0.5 * this.midWidth);        var tip = this.y + this.fineDirection * 1.95 * this.g;        var direction = this.fineDirection;        this.arrow_dimensions(x, tip, direction);    };    for (var i = -1; i < 2; i += 2) {        var x = this.x + (i * (0.5 * this.midWidth));        var y0 = this.y + (i * (1 * this.g)) + (i * (0.05 * this.g));        var y1 = this.y - (i * (1 * this.g)) + (i * (0.05 * this.g));        if (this.fineDirection === 1 && i === 1) {            y0 = this.y + this.fineDirection * 1.85 * this.g;        }        else if (this.fineDirection === -1 && i === 1) {            y1 = this.y + this.fineDirection * 1.85 * this.g;        };        this.thinLine_dimensions(x, y0, y1);        var y = this.y + (i * vert_displace);        this.thickLine_dimensions(y, length);    };    var vertices = [        [            // top left            this.x - 0.5 * length,            this.y + 0.5 * this.g + (slope * (-0.5 * length)) + (0.5 * width)        ],        [            // top right            this.x + 0.5 * length,            this.y + 0.5 * this.g + (slope * ( 0.5 * length)) + (0.5 * width)         ],        [            // bottom right            this.x + 0.5 * length,            this.y - 0.5 * this.g + (slope * ( 0.5 * length)) - (0.5 * width)         ],        [            // bottom left            this.x - 0.5 * length,            this.y - 0.5 * this.g + (slope * (-0.5 * length)) - (0.5 * width)        ]    ];    this.dimensions.body.maxDimensions = this.maxDimensions(vertices);    this.dimensions.body.boundingShape = vertices;}Accidental.prototype.flat = function(fine) {    if (this.fine !== 0) {        var x = this.x - (0.5 * this.midWidth);        if (this.fineDirection === -1) {            var tip = this.y - 1.625 * this.g;        }        else if (this.fineDirection === 1) {            var tip = this.y + 2.125 * this.g;        }        var direction = this.fineDirection;        this.arrow_dimensions(x, tip, direction);    };    var x = this.x - 0.5 * this.midWidth;    var y0 = this.y + (1.618 * this.g);    var y1 = this.y - (0.618 * this.g);    if (this.fineDirection === 1) {        y0 = this.y + 2 * this.g;    }    else if (this.fineDirection === -1) {        y1 = this.y - 1.5 * this.g;    }    this.thinLine_dimensions(x, y0, y1);    var x = this.x - 0.5 * this.midWidth + 0.5 * this.thinLine_width;    var y = this.y - 0.618 * this.g;    var direction = this.coarseDirection;    this.curve_dimensions(x, y, direction);}Accidental.prototype.quarterSharp = function(fine) {    var length = 1.618 * this.midWidth;    var width = this.thickLine_width;    var slope = this.thickLine_slope;    if (this.fine !== 0) {        var x = this.x;        var tip = this.y + this.fineDirection * 1.618 * this.g;        var direction = this.fineDirection;        this.arrow_dimensions(x, tip, direction);    };    var y0 = this.y + (0.5 + 0.618) * this.g;    var y1 = this.y - (0.5 + 0.618) * this.g;    if (this.fineDirection === 1) {        y0 = this.y + 1.5 * this.g;    }    else if (this.fineDirection === -1) {        y1 = this.y - 1.5 * this.g;    };    this.thinLine_dimensions(this.x, y0, y1);    this.thickLine_dimensions(this.y, length);    var vertices = [        [            // top left            this.x - 0.5 * length,            this.y + (slope * (-0.5 * length)) + (0.5 * width)        ],        [            // top right            this.x + 0.5 * length,            this.y + (slope * ( 0.5 * length)) + (0.5 * width)         ],        [            // bottom right            this.x + 0.5 * length,            this.y + (slope * ( 0.5 * length)) - (0.5 * width)         ],        [            // bottom left            this.x - 0.5 * length,            this.y + (slope * (-0.5 * length)) - (0.5 * width)        ]    ];    this.dimensions.body.maxDimensions = this.maxDimensions(vertices);    this.dimensions.body.boundingShape = vertices;}Accidental.prototype.quarterFlat = function(fine) {    if (this.fine !== 0) {        var x = this.x + (0.5 * this.midWidth);        if (this.fineDirection === -1) {            var tip = this.y - 1.625 * this.g;        }        else if (this.fineDirection === 1) {            var tip = this.y + 2.125 * this.g;        }        var direction = this.fineDirection;        this.arrow_dimensions(x, tip, direction);    };    var x = this.x + 0.5 * this.midWidth;    var y0 = this.y + (1.618 * this.g);    var y1 = this.y - (0.618 * this.g);    if (this.fineDirection === 1) {        y0 = this.y + 2 * this.g;    }    else if (this.fineDirection === -1) {        y1 = this.y - 1.5 * this.g;    }    this.thinLine_dimensions(x, y0, y1);    var x = this.x + 0.5*this.midWidth - 0.5 * this.thinLine_width;    var y = this.y - 0.618 * this.g;    var direction = this.coarseDirection;    this.curve_dimensions(x, y, direction);}// COMPONENTS -----------------------------------------------------------------Accidental.prototype.thinLine = function(properties) {        // Takes in properties: { x, y0, y1 };    var x = properties.x;    var y0 = properties.y0;    var y1 = properties.y1;    var line = this.accidentalGroup.pathItems.rectangle(        y1,        x - 0.5 * this.thinLine_width,        this.thinLine_width,        y1 - y0    );    line.stroked = false;    line.fillColor = this.color;    line.closed = true;};Accidental.prototype.thinLine_dimensions = function(x, y0, y1) {    var thin = {};    thin.components = {};    thin.components.thinLine = {};    thin.components.thinLine.x = x;    thin.components.thinLine.y0 = y0;    thin.components.thinLine.y1 = y1;    // Push bounding polygon up to this.dimensions    var boundingShape = this.thinLine_boundingPolygon(x, y0, y1);    thin.boundingShape = boundingShape;    // Push dimensional attributes up to this.dimensions    this.dimensions.columns.push(thin);}Accidental.prototype.thinLine_boundingPolygon = function(x, y0, y1) {    var vertices = [        [x - 0.5 * this.thinLine_width, y1],        [x + 0.5 * this.thinLine_width, y1],        [x + 0.5 * this.thinLine_width, y0],        [x - 0.5 * this.thinLine_width, y0]    ];    // For testing only!    //this.drawPolygon(vertices);    return vertices;}Accidental.prototype.thickLine = function(properties) {        // Takes in properties: { x, y, length};    var x = properties.x;    var y = properties.y;    var length = properties.length;    var width = this.thickLine_width;    var slope = this.thickLine_slope;    var line = this.accidentalGroup.pathItems.add();    line.setEntirePath([        [ x - 0.5 * length, y + (slope * (-0.5 * length)) + (0.5 * width) ],        [ x + 0.5 * length, y + (slope * ( 0.5 * length)) + (0.5 * width) ],        [ x + 0.5 * length, y + (slope * ( 0.5 * length)) - (0.5 * width) ],        [ x - 0.5 * length,  y + (slope * (-0.5 * length)) - (0.5 * width) ]    ]);    line.stroked = false;    line.fillColor = this.color;    line.closed = true;}Accidental.prototype.thickLine_dimensions = function(y, length) {    var thick = {};    thick.thickLine = {};    thick.thickLine.x = this.x;    thick.thickLine.y = y;    thick.thickLine.length = length;    this.dimensions.body.components.push(thick);}Accidental.prototype.curve = function(properties) {        // Takes in properties: { x, y, direction};    var x = properties.x;    var y = properties.y;    var direction = properties.direction;    var curve = this.accidentalGroup.pathItems.add();    var curvePoints = [        [            // top outside center            [ x, y + (1 * this.g) ],            [ x, y + (1 * this.g) ],            [ x + (direction * (0.2 * this.g)), y + (1.075 * this.g) ]        ],        [            // top outside right            [ x + (direction * (0.500 * this.g)), y + (0.95 * this.g) ],            [ x + (direction * (0.475 * this.g)), y + (1.10 * this.g) ],            [ x + (direction * (0.550 * this.g)), y + (0.65 * this.g) ]        ],        [            // bottom outside center            [ x, y ],            [ x + (direction * (0.2 * this.g)), y + (0.4 * this.g) ],            [ x, y ]        ],        [            // bottom inside center            [ x, y + (0.21 * this.g) ],            [ x, y + (0.21 * this.g) ],            [ x, y + (0.21 * this.g) ]        ],        [            // top inside right            [ x + (direction * (0.250 * this.g)), y + (0.85 * this.g) ],            [ x + (direction * (0.325 * this.g)), y + (0.60 * this.g) ],            [ x + (direction * (0.200 * this.g)), y + (1.00 * this.g) ]        ],        [            [ x, y + (0.875 * this.g) ],            [ x, y + (0.875 * this.g) ],            [ x, y + (0.875 * this.g) ]        ]    ];    for (var p = 0; p < curvePoints.length; p ++) {        var curPoint = curvePoints[p];        var point = curve.pathPoints.add();        point.anchor = curPoint[0];        point.leftDirection = curPoint[1];        point.rightDirection = curPoint[2];    };    curve.stroked = false;    curve.fillColor = this.color;    curve.closed = true;}Accidental.prototype.curve_dimensions = function(x, y, direction) {    this.dimensions.body = {};    this.dimensions.body.components = [];    var curveObj = {};    curveObj.curve = {};    curveObj.curve.x = x;    curveObj.curve.y = y;    curveObj.curve.direction = direction;    this.dimensions.body.components.push(curveObj);        this.curve_boundingPolygon(x, y, direction);}Accidental.prototype.curve_boundingPolygon = function(x, y, direction) {    var vertices = [        [            // top center            x - direction * this.thinLine_width,            y + 1.05*this.g + this.boundingPadding        ],        [            // top outside            x + direction*1.25*this.midWidth,            y + 1.05*this.g + this.boundingPadding        ],        [            // mid outside            x + direction*1.309*this.midWidth,            y + 0.618 * this.g        ],        [            // bottom outside            x - direction * this.thinLine_width,            y - this.boundingPadding        ]    ];    this.dimensions.body.maxDimensions = this.maxDimensions(vertices);    this.dimensions.body.boundingShape = vertices;    // For testing only!    //this.drawPolygon(vertices);}Accidental.prototype.arrow = function(properties) {        // Takes in properties: { x, tip, direction};    var x = properties.x;    var tip = properties.tip;    var direction = properties.direction;    var width = this.arrow_width;    var height = this.arrow_height;    var thickness = this.arrow_thickness;    var arrow = this.accidentalGroup.pathItems.add();        // Add points to arrow path    arrow.setEntirePath([                // top left        [ x - (0.5 * width), tip - (direction * (height - thickness)) ],        // top middle        [ x, tip ],        // top right        [ x + (0.5 * width), tip - (direction * (height - thickness)) ],            // bottom right        [ x + (0.5 * width), tip - (direction * height) ],          // bottom middle        [ x, tip - (direction * thickness) ],        // bottom left        [ x - (0.5 * width), tip - (direction * height) ]    ]);        arrow.stroked = false;    arrow.fillColor = this.color;    arrow.closed = true;}Accidental.prototype.arrow_dimensions = function(x, tip, direction) {    this.dimensions.arrow = {};    this.dimensions.arrow.components = {};    this.dimensions.arrow.components.arrow = {};    this.dimensions.arrow.components.arrow.x = x;    this.dimensions.arrow.components.arrow.tip = tip;    this.dimensions.arrow.components.arrow.direction = direction;    // Add boundingPolygon info the this.dimensions    this.arrow_boundingPolygon(x, tip, direction);}Accidental.prototype.arrow_boundingPolygon = function(x, tip, direction) {    var height = this.arrow_height;    var width = this.arrow_width;    var thickness = this.arrow_thickness;    var vertices = [                [             // top left            x - (0.5 * width) - this.boundingPadding,             tip - (direction * (height - thickness))         ],                [             // top middle            x,             tip + direction * 0.85 * this.boundingPadding        ],        [             // top right            x + (0.5 * width) + this.boundingPadding,             tip - (direction * (height - thickness))         ],        [            // bottom right            x + (0.5 * width) + this.boundingPadding,             tip - (direction * height)         ],        [             // bottom left            x - (0.5 * width) - this.boundingPadding,             tip - (direction * height)         ]    ];    this.dimensions.arrow.boundingShape = vertices;}// UTILITY METHODS ------------------------------------------------------------Accidental.prototype.maxDimensions = function(vertices) {    var xMin, xMax, yMin, yMax;    for (var p = 0; p < vertices.length; p ++) {        if (vertices[p][0] < xMin || ! xMin) xMin = vertices[p][0];        if (vertices[p][0] > xMax || ! xMin) xMax = vertices[p][0];        if (vertices[p][1] < yMin || ! yMin) yMin = vertices[p][1];        if (vertices[p][1] > yMax || ! yMax) yMax = vertices[p][1];    };    // Pass vertices along for global calculation    this.boundingDimensions(vertices);    return {        "xMin": xMin,        "xMax": xMax,        "yMin": yMin,        "yMax": yMax     };}Accidental.prototype.boundingDimensions = function(vertices) {    for (var p = 0; p < vertices.length; p ++) {        if (vertices[p][0] > this.xMax || !this.xMax) this.xMax = vertices[p][0];        if (vertices[p][0] < this.xMin || !this.xMin) this.xMin = vertices[p][0];        if (vertices[p][1] > this.yMax || !this.yMax) this.yMax = vertices[p][1];        if (vertices[p][1] < this.yMin || !this.yMin) this.yMin = vertices[p][1];    }}Accidental.prototype.coarseToType = function(coarse) {    // Converts coarse [num] to type [string]    var coarseToType = {                "-1": "flat",        "-0.5": "quarterFlat",        "0": "natural",        "0.5": "quarterSharp",        "1": "sharp"    };    return coarseToType[coarse];}Accidental.prototype.fineToDirection = function(fine) {    var direction;    if (fine === 0) direction = 0;    else if (fine > 0) direction = 1;    else if (fine < 0) direction = -1;     return direction;};Accidental.prototype.coarseToDirection = function(coarse) {    var direction;    if (Math.abs(coarse) === 0) direction = 0;    else if (Math.abs(coarse) === 1) direction = 1;    else if (Math.abs(coarse) === 0.5) direction = -1;     return direction;};Accidental.prototype.getBoundingDimensions = function() {    this.width = this.xMax - this.xMin;    this.height = this.yMax - this.yMin;};Accidental.prototype.drawAllPolygons = function() {    for (var zone in this.dimensions) {        if (zone === "body") {            vertices = this.dimensions.body.boundingShape;            this.drawPolygon(vertices);        }        else if (zone === "columns") {            for (var c = 0; c < this.dimensions.columns.length; c ++) {                vertices = this.dimensions.columns[c].boundingShape;                this.drawPolygon(vertices);            };        }        else if (zone === "arrow") {            vertices = this.dimensions.arrow.boundingShape;            this.drawPolygon(vertices);        };    };};Accidental.prototype.drawPolygon = function(vertices) {    var polygon = this.accidentalGroup.pathItems.add();    polygon.setEntirePath(vertices);    polygon.strokeWidth = 0.05;    polygon.strokeColor = orange_dark;    polygon.closed = true;    polygon.filled = false;}// TEST METHODS ---------------------------------------------------------------Accidental.prototype.testInfo = function() {    t.w("type: " + this.type + "; fine: " + this.fine);    for (var zone in this.dimensions) {        if (zone === "body") {            t.w("body");            for (var p = 0; p < this.dimensions.body.boundingShape.length; p ++) {                var point = this.dimensions.body.boundingShape[p];                t.w("point.x: " + point[0]);            };        };    };};Accidental.prototype.testDraw = function() {    var coarseList = [-1,-0.5,0,0.5,1];    var fineList = [-0.25, 0, 0.25];    var x = 75;    for (var c = 0; c < coarseList.length; c ++) {        var coarse = coarseList[c];        for (var f = 0; f < fineList.length; f ++) {            var fine = fineList[f];            var accidental = new Accidental(x, 400, 5, coarse, fine).draw(testDoc);            x += 10;        };    };};