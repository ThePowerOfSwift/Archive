//#include "../t.js"#include "../rhythmTreeToSpanGroup.js"#include "../NormalSequence.js"#include "MultiDepthRhythm.js"#include "../RegroupedRhythm.js"#include "../FING_FL_C.js"#include "../FING_CL_Bflat.js"#include "../AdjacentHarmonicEvent.js"#include "../Interpolation.js"function MeasureList(amount) {    this.amount = amount;    this.createMeasureList();    this.addSpanGroups();    //this.printInfo();    //t.w(JSON.stringify(this.measureList, null, "\t"));    return this.measureList;}MeasureList.prototype.addSpanGroups = function() {/*    var performerCombos = [        ["FL", "CL"],        ["FL", "VA"],        ["CL", "VA"],        ["FL", "CL", "VA"],        ["FL"],        ["CL"],        ["VA"]    ];*/    var beatIndex = 0;    for (var m = 0; m < this.measureList.length; m ++) {        var measure = this.measureList[m];        measure.beatIndex = beatIndex        measure.spanGroups = [];        // this is not ok, but nothing is        this.dynamicRange = measure.dynamicRange;        var subd = measure.subdivision;        var spanMin;        if (subd > 8) {             // spanMin = measure.beats < 10 ? 2 : 3;            spanMin = 2;        }        else { spanMin = 1; };        var spanMax = measure.beats > 12 ? 12 : measure.beats;        var spanMean = ((spanMax - spanMin) / 2) + spanMin;        if (spanMean > 8) spanMean = 8;         t.w("measure.subdivision: " + measure.subdivision +             "; beats: " + measure.beats);        t.w("spanMin: " + spanMin + "; spanMax: " + measure.beats +            "; spanMean: " + spanMean);        var spanWidths = new NormalSequence(            spanMin, spanMax, spanMean            ).wholeSeq("bySum", [measure.beats]        );        var cumulativeBeatWidth = 0;        for (performerID in measure.performerIDs) {            var spanWidthBegin = measure.performerIDs[performerID].spanWidthBegin;            var spanWidthEnd = measure.performerIDs[performerID].spanWidthEnd;            var spanWidthExp = measure.performerIDs[performerID].spanWidthExp;            var spanWidth_interp = new Interpolation(                0, spanWidthBegin, 1, spanWidthEnd, spanWidthExp            );            var locusBegin = measure.performerIDs[performerID].locusBegin;            var locusEnd = measure.performerIDs[performerID].locusEnd;            var locusExp = measure.performerIDs[performerID].locusExp;            var locus_interp = new Interpolation(                0, locusBegin, 1, locusEnd, locusExp            );            var measureBeatIndex = measure.beatIndex            for (var n = 0; n < spanWidths.length; n ++) {                var beats = spanWidths[n];                var subdivision = measure.subdivision;                var widthInBeats = (beats / subdivision) * 8;                var position = n / spanWidths.length;                var curLocus = locus_interp.point(position);                var randLocus = Math.random() < curLocus                     ? "relative"                     : "subdivideable"                var durList;                if (randLocus === "relative") {                    durList = new MultiDepthRhythm(beats, subdivision, 1);                    var spanGroup = new rhythmTreeToSpanGroup(                        beats, subdivision, durList                    );                    this.testComponents(spanGroup, performerID);                    spanGroup.beatIndex = measureBeatIndex                    spanGroup.widthInBeats = widthInBeats;                    measure.spanGroups.push(spanGroup);                }                else {                     durList = new MultiDepthRhythm(beats, subdivision)                        .subdivideable();                    var regrouped = new RegroupedRhythm(                        durList, beats, subdivision                    );                    var groupWidth = 0;                    for (var g = 0; g < regrouped.length; g ++) {                        var group = regrouped[g];                        t.w("group: " + group);                        var spanGroup = new rhythmTreeToSpanGroup(                            beats / regrouped.length, subdivision, group                        );                        this.testComponents(spanGroup, performerID);                        spanGroup.beatIndex = measureBeatIndex + groupWidth;                        spanGroup.widthInBeats = widthInBeats / regrouped.length;                        measure.spanGroups.push(spanGroup);                        groupWidth += ((beats/regrouped.length) / subdivision) * 8;                    };                };                cumulativeBeatWidth += widthInBeats;                measureBeatIndex += widthInBeats;            };        };        var measureWidthInBeats = (measure.beats / measure.subdivision) * 8;        beatIndex += measureWidthInBeats;        //beatIndex = measureBeatIndex;        /*for (var p = 0; p < performerIDs.length; p ++) {            var performerID = performerIDs[p];            var measureBeatIndex = measure.beatIndex;            for (var n = 0; n < spanWidths.length; n ++) {                var beats = spanWidths[n];                var subdivision = measure.subdivision;                var widthInBeats = (beats / subdivision) * 8;                var loci = ["relative", "subdivideable"];                var randLocusChoice = Math.floor(Math.random()*loci.length);                var randLocus = loci[randLocusChoice];*/                //var randLocus = "subdivideable";                /*var durList = new MultiDepthRhythm(                    beats, subdivision                )[randLocus]();*/                //var durList = new MultiDepthRhythm(beats, subdivision, 4);                /*var durList;                if (randLocus === "relative") {                    durList = new MultiDepthRhythm(beats, subdivision, 3);                    var spanGroup = new rhythmTreeToSpanGroup(                        beats, subdivision, durList                    );                    this.testComponents(spanGroup, performerID);                    spanGroup.beatIndex = measureBeatIndex                    spanGroup.widthInBeats = widthInBeats;                    measure.spanGroups.push(spanGroup);                }                else {                     durList = new MultiDepthRhythm(beats, subdivision)                        .subdivideable();                    var regrouped = new RegroupedRhythm(                        durList, beats, subdivision                    );                    var groupWidth = 0;                    for (var g = 0; g < regrouped.length; g ++) {                        var group = regrouped[g];                        t.w("group: " + group);                        var spanGroup = new rhythmTreeToSpanGroup(                            beats / regrouped.length, subdivision, group                        );                                                this.testComponents(spanGroup, performerID);                        spanGroup.beatIndex = measureBeatIndex + groupWidth;                        spanGroup.widthInBeats = widthInBeats / regrouped.length;                        measure.spanGroups.push(spanGroup);                        groupWidth += ((beats/regrouped.length) / subdivision) * 8;                    };                };                measureBeatIndex += widthInBeats;            };        };        beatIndex = measureBeatIndex;*/    };};MeasureList.prototype.addSpanWidths = function() {};MeasureList.prototype.testComponents = function(spanGroup, performerID, s) {    // if (performerID === "FL") this.randFluteEvent();    for (var s = 0; s < spanGroup.spans.length; s ++) {        if (spanGroup.spans[s].type === "spanGroup") {            this.testComponents(spanGroup.spans[s], performerID, s);        }        else if (spanGroup.spans[s].type === "event" || "rest") {            var event = spanGroup.spans[s];            event.components = [];            if (spanGroup.spans[s].type === "event") {                var method;                if (performerID === "FL") { method = "randFluteEvent"; }                else if (performerID === "CL") { method = "randClarinetEvent"; }                else if (performerID === "VA") { method = "randViolaEvent"; };                var component = this[method]();                for (var c = 0; c < component.length; c ++) {                    event.components.push(component[c]);                };            }            else if (spanGroup.spans[s].type === "rest") {                var component = this.restEvent();                event.components.push(component);            };        };                    /*var event = spanGroup.spans[s];            event.components = [];            var amountPitches = Math.floor(Math.random()*2 + 1);            var randPitches = [];            for (var p = 0; p < amountPitches; p ++) {                var randPitch = Math.floor(Math.random()*100)/4 + 52;                randPitches.push(randPitch);            };            var graphList = this.getGraphListByPerformerID(performerID);            for (var g = 0; g < graphList.length; g ++) {                var graphID = graphList[g];                var component = {};                component.performerID = performerID;                component.instrumentID = performerID;                component.graphID = graphID;                if (spanGroup.spans[s].type === "event") {                    component.pitchINFO = {};                    for (var p = 0; p < randPitches.length; p ++) {                        if (graphID === "sounding") {                            var pitch = randPitches[p];                            component.pitchINFO[pitch] = {};                        }                        else {                            var pitch = randPitches[p] + 2;                            component.pitchINFO[pitch] = {};                        };                    };                    var interps = ["linear", "swell", "static"];                    var randInterpChoice = Math.floor(Math.random()*interps.length);                    var randInterp = interps[randInterpChoice];                    //var randInterp = "static";                    if (s === 0) {                        var randDyn = Math.floor(Math.random()*4 + 2);                        var randDir = Math.random();                        if (randDir > 0) randDyn *= -1;                        var randSf = Math.random();                        if (randSf > 0.66) randDyn = randDyn.toString();                        component.dynamicINFO = {};                        component.dynamicINFO.marking = [randDyn];                        component.dynamicINFO.interp = randInterp;                    };                 }                else if (spanGroup.spans[s].type === "rest") {                    var randDyn = Math.floor(Math.random()*4 + 2);                    var randDir = Math.random();                    if (randDir > 0) randDyn *= -1;                    component.dynamicINFO = {};                    component.dynamicINFO.marking = [randDyn];                    // something                }                event.components.push(component);            };        };  */    };};MeasureList.prototype.addDynamicINFO = function() {}MeasureList.prototype.randViolaEvent = function() {    var scordOpenStrings = [46, 55, 61, 69];    var ordOpenStrings = [48, 55, 62, 69];    var harmonicEvent = new AdjacentHarmonicEvent(        scordOpenStrings, ordOpenStrings    );    var randPitch = Math.floor(Math.random()*100)/4 + 52;    //var randDyn = Math.floor(Math.random()*10) - 5;    var dynMin = this.dynamicRange[0];    var dynMax = this.dynamicRange[1];    var randDyn = Math.floor(Math.random()*(dynMax - dynMin + 1)) + dynMin;    if (randDyn === 1) randDyn += 1;    if (randDyn === -1) randDyn -= 1;    if (randDyn === 0) randDyn = -5;    var interps = ["linear", "swell", "static"];    var randInterpChoice = Math.floor(Math.random()*interps.length);    var randInterp = interps[randInterpChoice];    var fingeredComponent = {};    var soundingComponent = {};    fingeredComponent.performerID = "VA";    fingeredComponent.instrumentID = "VA";    fingeredComponent.graphID = "fingered";    soundingComponent.performerID = "VA";    soundingComponent.instrumentID = "VA";    soundingComponent.graphID = "sounding";    fingeredComponent.pitchINFO = harmonicEvent.fingeredPitchINFO;    /*fingeredComponent.pitchINFO = {};    fingeredComponent.pitchINFO[randPitch] = {};*/    soundingComponent.pitchINFO = harmonicEvent.soundingPitchINFO;    /*soundingComponent.pitchINFO = {};    soundingComponent.pitchINFO[randPitch] = {};*/    fingeredComponent.dynamicINFO = {};    fingeredComponent.dynamicINFO.marking = [randDyn];    fingeredComponent.dynamicINFO.interp = randInterp;    soundingComponent.dynamicINFO = {};    soundingComponent.dynamicINFO.marking = [randDyn];    soundingComponent.dynamicINFO.interp = randInterp;    return [fingeredComponent, soundingComponent];}MeasureList.prototype.randClarinetEvent = function() {    var randFingChoice = Math.floor(Math.random()*FING_CL_Bflat.length);    var randFing = FING_CL_Bflat[randFingChoice];    var fingering = randFing.fingering;    var fingeredPitches = randFing.pitch.fingered;    var soundingPitches = randFing.pitch.sounding;    var dynamics = randFing.dynamics;    var randDynChoice = Math.floor(Math.random()*randFing.dynamics.length);    var dynMin = this.dynamicRange[0];    var dynMax = this.dynamicRange[1];    var randDyn = Math.floor(Math.random()*(dynMax - dynMin + 1)) + dynMin;    //var randDyn = Math.floor(Math.random()*10) - 5;    if (randDyn === 1) randDyn += 1;    if (randDyn === -1) randDyn -= 1;    if (randDyn === 0) randDyn = -5;    var interps = ["linear", "swell", "static"];    var randInterpChoice = Math.floor(Math.random()*interps.length);    var randInterp = interps[randInterpChoice];    var fingeredComponent = {};    var soundingComponent = {};    fingeredComponent.performerID = "CL";    fingeredComponent.instrumentID = "CL";    fingeredComponent.graphID = "fingered";    soundingComponent.performerID = "CL";    soundingComponent.instrumentID = "CL";    soundingComponent.graphID = "sounding";    fingeredComponent.pitchINFO = {};    soundingComponent.pitchINFO = {};    fingeredComponent.dynamicINFO = {};    fingeredComponent.dynamicINFO.marking = [randDyn];    fingeredComponent.dynamicINFO.interp = randInterp;    soundingComponent.dynamicINFO = {};    soundingComponent.dynamicINFO.marking = [randDyn];    soundingComponent.dynamicINFO.interp = randInterp;    var pitches = [Math.floor(Math.random()*100)/4 + 60];    for (var p = 0; p < pitches.length; p ++) {        fingeredComponent.pitchINFO[pitches[p] + 2] = {};        soundingComponent.pitchINFO[pitches[p]] = {};    };    fingeredComponent.fingeringINFO = fingering;    soundingComponent.fingeringINFO = fingering;    return [fingeredComponent, soundingComponent];}MeasureList.prototype.randFluteEvent = function() {    var component = {};    component.performerID = "FL";    component.instrumentID = "FL";    component.graphID = "sounding";    var randFingChoice = Math.floor(Math.random()*FING_FL_C.length);    var randFing = FING_FL_C[randFingChoice];    var fingering = randFing.fingering;    var randDynChoice = randFing.dynamics.length;    //var randDyn = randFing.dynamics[randDynChoice];    //var randDyn = Math.floor(Math.random()*10) - 5;    var dynMin = this.dynamicRange[0];    var dynMax = this.dynamicRange[1];    var randDyn = Math.floor(Math.random()*(dynMax - dynMin + 1)) + dynMin;    if (randDyn === 1) randDyn += 1;    if (randDyn === -1) randDyn -= 1;    if (randDyn === 0) randDyn = -5;    var interps = ["linear", "swell", "static"];    var randInterpChoice = Math.floor(Math.random()*interps.length);    var randInterp = interps[randInterpChoice];    component.dynamicINFO = {};    component.dynamicINFO.marking = [randDyn];    component.dynamicINFO.interp = randInterp;    component.fingeringINFO = fingering;    //var pitches = randFing.pitch.sounding;    var pitches = [Math.floor(Math.random()*100)/4 + 60];    var fingering = randFing.fingering;    var dynamics = randFing.dynamics;    component.pitchINFO = {};    for (var p = 0; p < pitches.length; p ++) {        component.pitchINFO[pitches[p]] = {};    };    return [component];    // Sounding Graph event    // Diagram}MeasureList.prototype.restEvent = function() {    var randDyn = Math.floor(Math.random()*4 + 2);    var randDir = Math.random();    if (randDir > 0) randDyn *= -1;    component.dynamicINFO = {};    component.dynamicINFO.marking = [randDyn];    return [component];}MeasureList.prototype.getGraphListByPerformerID = function(performerID) {    var graphListByPerformerID = {        "FL": ["sounding"],        "VA": ["fingered", "sounding"],        "CL": ["fingered", "sounding"],    };    return graphListByPerformerID[performerID];};MeasureList.prototype.createMeasureList = function() {    var sections = [    {        // 19        "beatsList": [4,5,4,3,1,2],        "performers": {            "FL": {                "locus": [0,0,1],                "meanSpanWidthScale": [1,1,1]            },            "VA": {                "locus": [0,0,1],                "meanSpanWidthScale": [1,1,1]            },            "CL": {                "locus": [0,0,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [-4,-4]    },    {        "beatsList": [2],        "performers": {            // GP        }    },    {        // 90        "beatsList": [5,4,3,4,5,4,6,4,2,5,5.5,7,5,4,2.5,3,3.5,3,3.5,1.5,2.75,5,1.75],        "performers": {            "FL": {                "locus": [0,1,1],                "meanSpanWidthScale": [1,1,1]            },            "VA": {                "locus": [1,1,1],                "meanSpanWidthScale": [1,1,1]            },            "CL": {                "locus": [1,0,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [-4,1]    },    {        "beatsList": [1],        "performers": {            // GP        }    },    {        // 55        "beatsList": [2.75,4.5,5.5,4.25,6.75,6.25,5,4.5,1.5,5.5,3.5,3,2],        "performers": {            "FL": {                "locus": [1,0,1],                "meanSpanWidthScale": [1,1,1]            },            "VA": {                "locus": [0,1,1],                "meanSpanWidthScale": [1,1,1]            },        },        "dynamicRange": [-1,-1],    },    {        // 23        "beatsList": [2.5,2,1.5,4,4.5,4,4.5],        "performers": {            "FL": {                "locus": [0,1,1],                "meanSpanWidthScale": [1,1,1]            },            "VA": {                "locus": [0,0.5,1],                "meanSpanWidthScale": [1,1,1]            },            "CL": {                "locus": [1,0,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [2,-2]    },    {        // 20        "beatsList": [3,2.5,2,2.5,2,1,2.5,1,1.5,2],        "performers": {            "FL": {                "locus": [1,0.5,1],                "meanSpanWidthScale": [1,1,1]            },            "VA": {                "locus": [0.5,1,1],                "meanSpanWidthScale": [1,1,1]            },            "CL": {                "locus": [0,0.5,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [-3,3]    },    {        // 12        "beatsList": [2.5,1.5,2.25,3,2.75],        "performers": {            "VA": {                "locus": [1,0,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [5,-5]    },    {        // 44        "beatsList": [5,3,1,5.5,6,4,2,3,1.5,1.25,2.75,2,1.75,3,2.25],        "performers": {            "VA": {                "locus": [1,0,1],                "meanSpanWidthScale": [1,1,1]            },            "CL": {                "locus": [0,1,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [1,3]    },    {        "beatsList": [1.5],        "performers": {            // GP        }    },    {        "beatsList": [            7.25,7,3,3.25,5,5.25,3.5,3.25,2.75,4,3.5,5.75,6.25,4,3.25,3.75,6,4,1.25        ],        "performers": {            "FL": {                "locus": [0,0,1],                "meanSpanWidthScale": [1,1,1]            },            "VA": {                "locus": [0,0,1],                "meanSpanWidthScale": [1,1,1]            },            "CL": {                "locus": [0,0,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [-1,3]    },    {        "beatsList": [3],        "performers": {            // GP        }    },    {        "beatsList": [1.25,2,2.25,3,2.75,2.5,1.25],        "performers": {            "FL": {                "locus": [1,0,1],                "meanSpanWidthScale": [1,1,1]            },            "VA": {                "locus": [0.5,0.5,1],                "meanSpanWidthScale": [1,1,1]            },            "CL": {                "locus": [0,1,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [4,4]    },    {        "beatsList": [4],        "performers": {            // GP        }    },    {        "beatsList": [3,3.5,6.5,1.5,4.5,5,6,2,4],        "performers": {            "FL": {                "locus": [0,1,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [3,-5]    },    {        "beatsList": [1,3,7,2,4,5,2,3,4],        "performers": {            "CL": {                "locus": [0,0,1],                "meanSpanWidthScale": [1,1,1]            }        },        "dynamicRange": [1,-5]    }];        this.measureList = [];    for (var s = 0; s < sections.length; s ++) {        var section = sections[s];        var dynamicRange = section.dynamicRange;        var performers = section.performers;                // Cut section-level locus-trajectory to measure-level        // -- to be cut-up again on spanWidth level        var meanSpanWidthScale_interpByPerformerID = {};        var locus_interpByPerformerID = {};        for (var performerID in section.performers) {            // ITERATE THROUGH THESE LATER!!!!?!            var spanWidthBegin = section.performers[performerID].meanSpanWidthScale[0];            var spanWidthEnd = section.performers[performerID].meanSpanWidthScale[1];            var spanWidthExp = section.performers[performerID].meanSpanWidthScale[2];            var locusBegin = section.performers[performerID].locus[0];            var locusEnd = section.performers[performerID].locus[1];            var locusExp = section.performers[performerID].locus[2];            var locus_interp = new Interpolation(                0, locusBegin, 1, locusEnd, locusExp            );            var spanWidth_interp = new Interpolation(                0, spanWidthBegin, 1, spanWidthEnd, spanWidthExp            );            locus_interpByPerformerID[performerID] = locus_interp;            meanSpanWidthScale_interpByPerformerID[performerID] = spanWidth_interp;        };        var cumulativeBeatWidth = 0;        for (var m = 0; m < section.beatsList.length; m ++) {            /*t.w("Measure " + (this.measureList.length + 1) + " ==================");*/            var measure = {};            var adj = decimalToTimeSig(section.beatsList[m]);            var beats = adj[0];            var subdivision = adj[1];            // this is all digusting            var interpsBegin = cumulativeBeatWidth / section.beatsList.sum();            var interpsEnd = (                (cumulativeBeatWidth + section.beatsList[m]) /                  section.beatsList.sum()            );            measure.beats = beats;            measure.subdivision = subdivision;            measure.performerIDs = clone(performers); // oh god            for (performerID in measure.performerIDs) {                var locus_interp = locus_interpByPerformerID[performerID];                var locusBegin = locus_interp.point(interpsBegin);                var locusEnd = locus_interp.point(interpsEnd);                var locusExp = locus_interp.exp;                var spanWidth_interp =                     meanSpanWidthScale_interpByPerformerID[performerID];                var spanWidthBegin = spanWidth_interp.point(interpsBegin);                var spanWidthEnd = spanWidth_interp.point(interpsEnd);                var spanWidthExp = spanWidth_interp.exp;                measure.performerIDs[performerID].locusBegin = locusBegin;                measure.performerIDs[performerID].locusEnd = locusEnd;                measure.performerIDs[performerID].locusExp = locusExp;                measure.performerIDs[performerID].spanWidthBegin = spanWidthBegin;                measure.performerIDs[performerID].spanWidthEnd = spanWidthEnd;                measure.performerIDs[performerID].spanWidthExp = spanWidthExp;                //measure.performerIDs[performerID].test = 10;            };            measure.dynamicRange = dynamicRange;            /*t.w("LOCUS INFO CHECK TEST PRIOR TO PUSH ----------------");            t.w("Measure: " + (m + 1))            for (performerID in measure.performerIDs) {                t.w(performerID);                t.w(measure.performerIDs[performerID].begin);            };            t.w("LOCUS INFO CHECK TEST PRIOR TO PUSH DONE -----------");*/            this.measureList.push(measure);            cumulativeBeatWidth += section.beatsList[m];        };    };/*    t.w("LOCUS INFO CHECK TEST ======================");    for (var m = 0; m < this.measureList.length; m ++) {        var measure = this.measureList[m];        t.w("Measure " + (m + 1));        for (var performerID in measure.performerIDs) {            t.w(performerID);            t.w("measureCount: " + measure.count);            t.w(measure.performerIDs[performerID].begin);        };    };    t.w("LOCUS INFO CHECK TEST DONE =================");*/};MeasureList.prototype.printInfo = function() {    for (var m = 0; m < this.measureList.length; m ++) {        var measure = this.measureList[m];        t.w("Measure: " + m);        t.w("beats: " + measure.beats + "; subdivision: " + measure.subdivision);        t.w("SpanGroups: ");        for (var s = 0; s < measure.spanGroups.length; s ++) {            var spanGroup = measure.spanGroups[s];            for (var r = 0; r < spanGroup.spans.length; r ++) {                var span = spanGroup.spans[r];                t.w("span.type: " + span.type);                for (var c = 0; c < span.components.length; c ++) {                    var component = span.components[c];                    t.w("performerID: " + component.performerID);                    t.w("graphID: " + component.graphID);                    for (var pitch in component.pitchINFO) {                        t.w("pitch: " + pitch);                    };                };            };        };    };};