#include "../arrayMethods.js"#include "../conversions.js"#include "../BeamGroup.js"#include "../Metronome.js"//#include "../NormalSequence.js"#include "RhythmTestStaff.js"#include "RhythmTestInfo.js"#include "../Staff.js"#include "../json2.js"function RhythmTest(x, stem_direction, beats, subdivision, durList) {        // Needed for fully functional Span:    // type #    // beats #    // beats_adj #    // subd(ivision)    // subd_adj    // subdLevel_adj #    // beatScale #    // (spans) #        // Initiate initial parent Span, regardless of need for recursion    var parentSpan = {};    parentSpan.type = "spanGroup";    parentSpan.beats = beats;    parentSpan.subdivision = subdivision;    parentSpan.beatScale = 1;    parentSpan.tempoScale = 1;    parentSpan.spans = [];    parentSpan.durList = [];            // Recurse through rhythm tree to create fully functional Span for BeamGroup    // First pass    this.recurseTree(durList, parentSpan);        // Redefine     parentSpan.subd_adj = parentSpan.subdivision;        //$.writeln(parentSpan.subvision);    //$.writeln(parentSpan.subd_adj);        parentSpan.subdLevel_adj = valToSubdLevel(beats, parentSpan.subd_adj);        // Second pass for subd_adj, subdLevel_adj, beatScale, tempoScale    ////$.writeln("second pass");    this.completeSpan(parentSpan);    t.w("i am stringifying");    t.w(JSON.stringify(parentSpan, null, "\t"));            /*//var stem_direction = -1;    if (stem_direction === 1) altitudeRef = curGraph.top;    else altitudeRef = curGraph.bottom;    var altitude = altitudeRef + stem_direction * 25;    var isExpanded = false;    var withTempo = false;    var withMetrics = true;    var withNumerics = true;        // Draw new BeamGroup with appropriate info    var beamGroup = new BeamGroup(        parentSpan,        this.x, altitude, stem_direction,        isExpanded, withTempo, withMetrics, withNumerics    );*/};RhythmTest.prototype.recurseTree = function(durList, parentSpan, depth, d, sum) {        // Check if we have already recursed downward, or if we have just started    if (typeof depth === "number") {                // increment depth if NOT first instance        depth ++    }    else {                // establish depth at zero if first instance        depth = 0    };        // iterate through all values in current level of array    var sum = 0;    for (var d = 0; d < durList.length; d ++) {                if (typeof durList[d] === "object") {                        var beats = durList[d][0];            var newDurList = durList[d][1];            sum += Math.abs(beats);                        // Creat new parent span group            var childSpan = {};            childSpan.type = "spanGroup";            childSpan.beats = beats;                        // Create array for the next level of embedded spans to be pushed            childSpan.spans = [];                        // Add new beats to old parent?            parentSpan.spans.push(childSpan);                        // recurse downward            this.recurseTree(newDurList, childSpan, depth, d, sum)        }        else if (typeof durList[d] === "number") {                        var curDur = durList[d];            var curDurAbs = Math.abs(curDur);                        sum += curDurAbs;                        // event            var childSpan = {};            if (curDur > 0) childSpan.type = "event";            else childSpan.type = "rest";            childSpan.beats = curDurAbs;            parentSpan.spans.push(childSpan);        }                // IF LAST EVENT        if (d === durList.length - 1) {                    // New adjusted object (with sum, beats, subdivision)            var adjusted = xAdjustY(                sum,                 parentSpan.beats,                 parentSpan.subdivision            );                        spanSum_adj = adjusted.spanSum;            beats_adj = adjusted.beats;            parentSpan.spanSum = sum;            parentSpan.spanSum_adj = spanSum_adj;            parentSpan.beats_adj = beats_adj;        };    };  }RhythmTest.prototype.completeSpan = function(parentSpan, depth, s) {        // Check if we have already recursed downward, or if we have just started    if (typeof depth === "number") {                // increment depth if NOT first instance        depth ++    }    else {                // establish depth at zero if first instance        depth = 0    };            for (s = 0; s < parentSpan.spans.length; s ++) {                var curSpan = parentSpan.spans[s];        var beats = parentSpan.beats;        var beats_adj = parentSpan.beats_adj;        var spanSum_adj = parentSpan.spanSum_adj;        var beatScale = parentSpan.beatScale;        var tempoScale = parentSpan.tempoScale;        var subdivision = parentSpan.subd_adj;        var subdScale = beats_adj/beats;        parentSpan.durList.push(curSpan.beats);                // Set subdivision        curSpan.subdivision = parentSpan.subdivision * subdScale;        // Adjust beat_width        curSpan.beatScale = beatScale * (beats_adj / spanSum_adj)        // Adjust local tempo        curSpan.tempoScale = tempoScale * (spanSum_adj / beats_adj);                if (curSpan.type === "event" || curSpan.type === "rest") {            curSpan.subdLevel_adj = valToSubdLevel(curSpan.beats, curSpan.subdivision);        }        else if (curSpan.type === "spanGroup") {            curSpan.durList = [];            curSpan.subd_adj = subdivision * subdScale;                        // Recurse downwards as necessary            this.completeSpan(curSpan, depth, s);        };    };};