#include "../NormalSequence.js"function MultiDepthRhythm(beats, subdivision, maxDepth) {        this.beats = beats || 7;    this.subdivision = subdivision || 16;    this.widthInBeats = (beats / subdivision) * 8;    this.maxDepth = maxDepth;    this.minWidthForTraversal = 0.5;    if (this.maxDepth > 0) {        var initDurList = this.relative(this.beats, 0);        for (var d = 0; d < initDurList.length; d ++) {           /* if (initDurList[d] > 0 && Math.random() > 0.85 &&                typeof initDurList[d-1] !== "string") {                initDurList[d] = initDurList[d].toString();            };*/        }        if (this.widthInBeats / initDurList.length > 0.8375) {            this.traverseTree(initDurList, 0);        };        return initDurList;    }}MultiDepthRhythm.prototype.subdivideable = function() {    do {         var legalSums = [];        for (var e = -3; e < 3; e ++) {            var val = this.beats * Math.pow(2, e);            if (val >= 1 && val % 1 === 0) legalSums.push(val);        };        var durList = new NormalSequence(1,4,1.75).wholeSeq("bySum", legalSums);    } while (durList.length < 2); // these constraints should be variable…    if (durList.length === 1) durList = [1];    return durList;};MultiDepthRhythm.prototype.relative = function(beats, depth) {    this.maxByDepth = [16,12,8,6,4];    do {        var illegalSums = [];        for (e = - 3; e < 4; e ++) {            var val2 = beats * Math.pow(2, e);            var val3 = beats * 3/2 * Math.pow(2, e);            illegalSums.push(val2, val3);        };        var legalSums = [];        for (var i = 1; i < 40; i ++) {            if (!illegalSums.contains(i)) {                legalSums.push(i);            };        };        var max = this.maxByDepth[depth];        //var mean = ((max - 1) / 2) + 1.5;        var mean = 2.25;        var durList = new NormalSequence(1, max, mean).wholeSeq("bySum", legalSums);    } while (durList.length < 3); // these constrains should be variable    durList.reduceAllByGCD();    return durList;}MultiDepthRhythm.prototype.traverseTree = function(durList, depth, s) {    depth ++;    for (var s = 0; s < durList.length; s ++) {        var dur = durList[s];        // check        if (depth < this.maxDepth &&            dur > 0.5 * this.maxByDepth[depth] &&            durList.maxIndices().contains(s) &&            typeof dur === "number") {            do { var newDurList = this.relative(dur, depth); }            while (newDurList.sum() === durList.sum());            durList[s] = [dur, newDurList];            this.traverseTree(newDurList, depth, s);        }        else {            /*if (typeof durList[s-1] !== "string" &&                durList[s-1] > 0 &&                Math.random() > 0.382            ) { durList[s] *= -1; };*/            /*if (durList[s] > 0 && Math.random() > 0.618 &&                typeof durList[s-1] !== "string") {                durList[s] = durList[s].toString();            };*/        };    };}