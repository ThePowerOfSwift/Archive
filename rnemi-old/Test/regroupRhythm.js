#include "../arrayMethods.js"var durGroups = [];function regroupRhythm(group, y, subd) {	// If first event	if (durGroups.length == 0) {				// Total amount of beats of group		this.x = group.sum();        this.tieThrown = false;				// Adjust each durational value: multiply by y 		for (var d = 0; d < group.length; d ++) { group[d] *= y; };		// Add first durational group		var newGroup = [];		durGroups.push(newGroup);	};	    // Establish current durational item     var curBeats = group[0];		// Current sum of current rhythmic group	var curSum = 0;		for (var b = 0; b < durGroups.last().length; b ++) {		curSum += durGroups.last()[b].beats;	};	// If it fits, and there's extra room	if ((curBeats + curSum) < this.x) {				// Create new span with current duration		var newSpan = {};		newSpan.beats = curBeats;				if (this.tieThrown == true) {						newSpan.tieCatch = true;		};				// Add current durational item to current rhythmic group		durGroups.last().push(newSpan);		        this.tieThrown = false;        		// Recurse through adjusted list (without current value)		regroupRhythm(group.slice(1), y);	}	// If it fits, and there's nothin' left	else if ((curBeats + curSum) == this.x) {				// Create new span with current duration		var newSpan = {};		newSpan.beats = curBeats;				if (this.tieThrown == true) {						newSpan.tieCatch = true;		};            this.tieThrown = true;				// Add current durational item to current rhythmic group		durGroups.last().push(newSpan);				if (group.length != 0) { 						// Add new group to rhythmic group list			var newGroup = [];			durGroups.push(newGroup);						// Recurse through adjusted list (without current value)			regroupRhythm(group.slice(1), y);		};	}	// If it's tooooo big	else if ((curBeats + curSum) > this.x) {				// New span with remaining beats, tieThrow = true;		var newSpan = {};		newSpan.beats = this.x - curSum;		newSpan.tieThrow = true;                if (this.tieThrown == true) {                        newSpan.tieCatch = true;        };				// Add remaining value to last group, to fill up to x		durGroups.last().push(newSpan);				// Add new group to rhyhtmic group list		var newGroup = [];		durGroups.push(newGroup);				// Adjust first value to  		group[0] = curBeats - (this.x - curSum);		        this.tieThrown = true;		// Recurse through adjusted list (with truncated first value)		regroupRhythm(group, y);	};};regroupRhythm([1,3,2], 3, 16);for (var g = 0; g < durGroups.length; g ++) {        $.writeln(">>>")    for (var b = 0; b < durGroups[g].length; b ++) {                $.writeln(durGroups[g][b].beats);    };};