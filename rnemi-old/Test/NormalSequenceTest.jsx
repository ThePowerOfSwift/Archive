#include "../t.js"#include "../arrayMethods.js"#include "../Interpolation.js"function NormalSequence(    min,    max,    muMean,    sigmaMin,    sigmaMax,    dirStrength,    amountRepetition,    resolution,    isExponential) {    this.min = min || 1;    this.max = max || 8;    this.muMean = muMean || 0.75;    this.mean = this.muMean;    this.sigmaMin = sigmaMin || 0.125;    this.sigmaMax = sigmaMax || 0.5;    this.dirStrength = dirStrength || 0.33;    this.amountRepetition = amountRepetition || 1;    this.resolution = resolution || 1;    this.isExponential = isExponential || true;    // Create the array that shall be returned ultimately    this.sequence = [];    // Create interpolation objects for all interpolizeable parameters    this.initializeInterpolations();    // Define all interpolated parameters at their initial state    this.callInterpolationsAtPoint(0);   }NormalSequence.prototype.initializeInterpolations = function() {    this.interpParams = [        "min", "max", "mean",         "dirStrength", "sigmaMin", "sigmaMax",         "amountRepetition"    ];    for (var p = 0; p < this.interpParams.length; p ++) {        var param = this.interpParams[p];        var interpName = param + "_interp";        if (typeof this[param] === "number") {                        // Create static interpolation that will return same val regardless            this[interpName] = new Interpolation(                0, this[param], 1, this[param], 1            );        }        else if (typeof this[param] === "object") {            // Create dynamic interpolation with values given            this[interpName] = new Interpolation(                0, this[param][0], 1, this[param][1], this[param][2]            );        };    };};NormalSequence.prototype.callInterpolationsAtPoint = function(x) {    for (var p = 0; p < this.interpParams.length; p ++) {        var param = this.interpParams[p];        var interpName = param + "_interp";        this[param] = this[interpName].point(x);    };};NormalSequence.prototype.establishCurrentPosition = function() {    if (this.sequence.length === 0) return 0;    else {        if (this.byWhat === "bySum") {            var totalSum = this.byWhatVal;            var curSum = this.sequence.sum();            var x = curSum / totalSum;            return x;    }        else if (this.byWhat === "byAmount") {            var totalAmount = this.byWhatVal;            var curAmount = this.sequence.length;            var x = curAmount / totalAmount;            return x;        };    };};NormalSequence.prototype.wholeSeq = function(byWhat, val) {    this.byWhat = byWhat;    this.byWhatVal = val;    var sumMatch = false;        if (byWhat == "bySum") {          this.sequence.length = 0;        do {            do {                var newNum = this.singleNum();                                             this.sequence.push(newNum);              } while (this.sequence.sum() < val)            if (this.sequence.sum() === val) {                if (this.sequence.length <= 2) {                    this.sequence.length = 0;                }                else {                    return this.sequence;                };            }            else {                this.sequence.length = 0;            };                    } while (sumMatch === false);    }    else if (byWhat == "byAmount") {        for (var num = 0; num < val; num ++) {            var newNum = this.singleNum();            this.sequence.push(newNum);        };    };    return this.sequence;}NormalSequence.prototype.singleNum = function() {        if (this.sequence.length === 0) {        //this.sigma = this.meanToSigma(this.mean);        this.sigma = 4;    };    //t.w("this.mean: " + this.mean + "; this.sigma: " + this.sigma);        var x1, x2, rad;    // GENERATE A NEW NUMBER    do {        do {            x1 = 2 * Math.random() - 1;            x2 = 2 * Math.random() - 1;            rad = x1 * x1 + x2 * x2;        }         while (rad >= 1 || rad === 0);        var c = Math.sqrt(-2 * Math.log(rad) / rad);        var newNum = ((x1 * c) * this.sigma) + this.mean;                newNum = Math.round(newNum * this.resolution) / this.resolution;        //t.w("newNum: " + newNum);        // TEST IF GENERATED VALUE IS ACCEPTABLE GIVEN CONSTRAINTS        var acceptable = true;                // IF WITHIN BOUNDS        if (newNum < this.min || newNum > this.max) acceptable = false;                    // IF NOT TOO MANY REPETITIONS        if (this.sequence.length > this.amountRepetition) {            var repetitionMatch = true;            for (var r = 1; r <= this.amountRepetition + 1; r ++) {                if (newNum !== this.sequence[this.sequence.length - r]) {                    repetitionMatch = false;                    break;                };            };        }        else {            repetitionMatch = false;        };                // If the last r numbers are of the same value, must choose another newNum        if (repetitionMatch === true) acceptable = false;        if (this.isExponential === true) {                        // Initiate exponential list            var expList = [];            for (var exponent = -1; exponent < 10; exponent ++) {                expList.push(2*Math.pow(2,exponent));                expList.push(3*Math.pow(2,exponent));            }            if (expList.contains(newNum) === false) {                acceptable = false;            };        };        // If newNum has passed all of the tests to this point        if (acceptable === true) {            if (this.sequence.length === 0) {                if (newNum > .5*this.range + this.min) {                    this.dir = -1;                };                else {                    this.dir = 1;                };              }            else if (this.sequence.length > 0) {                if (newNum < this.sequence.last() || newNum === this.max) {                    this.dir = -1;                }                else {                    this.dir = 1;                };            };            // Establish position within sequence for interpolations            var x = this.establishCurrentPosition();            this.callInterpolationsAtPoint(x);            // Define characteristics for next choice            this.mean = newNum * (1 + (this.dir * this.dirStrength));            /*t.w("newNum: " + newNum + "; this.mean: " + this.mean +                "; this.dirStrength: " + this.dirStrength            );*/            this.sigma = this.meanToSigma(newNum);                        return newNum;        };    }    // KEEP WITHIN DESIRED BOUNDS (I ASSUME THESE CAN BE FLEXIBLE)    while (acceptable === false)}NormalSequence.prototype.meanToSigma = function(curVal) {    var sigmaRange = this.sigmaMax - this.sigmaMin;    //t.w("sigmaRange: " + sigmaRange);    var muMin = this.min;    //t.w("muMin: " + muMin);    var muMax = this.max;    //t.w("muMax: " + muMax);    var muMean = this.muMean;    //t.w("muMean: " + muMean);    var curMu = curVal;    //t.w("curMu: " + curMu);    // Find greater difference between extremes and mean    var muRange;    if ((muMean - muMin) >= (muMax - muMean)) muRange = muMean - muMin;    else muRange = muMax - muMean;    muRange *= 2;    var verticalScale = (4 * sigmaRange) / (Math.pow(muRange, 2));    //t.w("verticalScale: " + verticalScale);    var horizontalTranslation = Math.pow((curMu - muMean),2);    //t.w("horizontalTranslation: " + horizontalTranslation);    var verticalTranslation = this.sigmaMin;    //t.w("verticalTranslation: " + verticalTranslation);    // Actual calculation    var sigma = (verticalScale * horizontalTranslation) + verticalTranslation;    sigma *= (this.max - this.min);    return sigma;};for (var i = 0; i < 50; i ++) {    var seq = new NormalSequence();    var primeList = [5,7,11,13,17,19,23];    var randPrime = Math.floor(Math.random()*primeList.length);    var sum = primeList[randPrime];    var sequence = seq.wholeSeq("bySum", sum);    t.w(sequence + ": sum: " + sequence.sum() + "; amount: " + sequence.length);};