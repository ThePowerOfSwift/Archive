#include "../arrayMethods.js"function BeamGroupVoice(beamGroups) {    this.beamGroups = beamGroups;    this.manageStrata();    this.printInfo();}BeamGroupVoice.prototype.manageStrata = function() {    this.amountBeamGroupsDistributed = 0;    this.beamGroupsDistributed = [];    this.stratumIndices;    for (var ai = 0; ai < this.beamGroups.length - 1; ai ++) {        for (var bi = ai + 1; bi < this.beamGroups.length; bi ++) {                if (this.stratumIndices) {                    for (var s = 0; s < this.stratumIndices.length; s ++) {                        var stratum = this.stratumIndices[s];                    };                };            if (!this.beamGroupsDistributed.contains(ai) ||                !this.beamGroupsDistributed.contains(bi)            ){                var relationship = this.compareBeamGroups(ai, bi);                if (relationship !== "none") this[relationship](ai, bi);            };        };     };};BeamGroupVoice.prototype.chain = function(ai, bi) {        if (!this.stratumIndices) {        this.stratumIndices = [[ai,bi]];        this.beamGroupsDistributed.push(ai,bi);    }    else {        var si, m, u;        for (var s = 0; s < this.stratumIndices.length; s ++) {            var stratum = this.stratumIndices[s];            if (stratum.contains(ai)) {                m = ai, u = bi;                si = s;                break;            };            else if (stratum.contains(bi)) {                m = bi, u = ai;                si = s;                break;            };                    };        var overlapping = true;        var stratum = this.stratumIndices[s];        for (var i = 0; i < stratum.length; i ++) {            var cur = stratum[i];            var rel = this.compareBeamGroups(m, cur);            if (rel === "overlap") {                overlapping = true;                break;            }            else if (rel !== "overlap") {                overlapping = false;                break;            };        };        if (overlapping) {            this.overlap(ai, bi);        };        else if (!overlapping) {            stratum.push(u);            this.beamGroupsDistributed.push(u);        };    };};BeamGroupVoice.prototype.overlap = function(ai, bi) {    if (!this.stratumIndices) {         this.stratumIndices = [[ai],[bi]];         this.beamGroupsDistributed.push(ai, bi);    }    else {        var m, u;        for (var s = 0; s < this.stratumIndices.length; s ++) {            var stratum = this.stratumIndices[s];            if (stratum.contains(ai)) {                m = ai; u = bi;             }            else if (stratum.contains(bi)) {                m = bi; u = ai;             };        };        // Check if possible to chain unmatched value to any present stratum        var overlapping = true;        for (var s = 0; s < this.stratumIndices.length; s ++) {            var stratum = this.stratumIndices[s];            // Is there any beamGroup in this stratum             var chainable = false;            for (var i = 0; i < stratum.length; i ++) {                var cur = stratum[i];                var rel = this.compareBeamGroups(cur, u);                if (rel === "overlap") {                     chainable = false;                    break;                 }                else if (rel === "chain") { chainable = true; }                else {/* neutral, don't do anything? */};            };            if (chainable) {                stratum.push(u);                this.beamGroupsDistributed.push(u);                overlapping = false;                break;            };        };        // Create whole new stratum        if (overlapping) {             this.stratumIndices.push([u]);            this.beamGroupsDistributed.push(u);        };    };};BeamGroupVoice.prototype.compareBeamGroups = function(ai, bi) {        // returns either "chain", "overlap", or "none"    var relationship;    var a = this.beamGroups[ai];    var beginA = a.beatIndex;    var endA = beginA + a.widthInBeats;    var b = this.beamGroups[bi];    var beginB = b.beatIndex;    var endB = beginB + b.widthInBeats;    if (endA === beginB || endB === beginA) { return "chain"; }    else if (         (beginA >= beginB && beginA <= endB) ||         (endA >= beginB && endA <= endB)    ) { return "overlap"; }     else { return "none"; };};BeamGroupVoice.prototype.printInfo = function() {        for (var s = 0; s < this.stratumIndices.length; s ++) {        var stratum = this.stratumIndices[s];        $.writeln("STRATUM: " + stratum);    };};var beamGroups = [    {"beatIndex": 3, "widthInBeats": 1},    {"beatIndex": 4, "widthInBeats": 4},    {"beatIndex": 5, "widthInBeats": 2.5},    {"beatIndex": 0, "widthInBeats": 5},    {"beatIndex": 0, "widthInBeats": 3},    {"beatIndex": 2.25, "widthInBeats": 3.25}];var voice = new BeamGroupVoice(beamGroups);