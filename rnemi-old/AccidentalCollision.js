#include "arrayMethods.js"// Takes in list of accidentals sorted from low-to-high vertical positionfunction AccidentalCollision(accidentals) {        //t.w("===========================");    this.accidentals = accidentals;    this.amount = accidentals.length;    this.allCollisions = [];        // Creates list list of all pairs of accidentals    this.createBoundingShapesArrays();    this.createDyadList();    this.createAllCollisions();    // Do the acutal adjustment and movement here    this.adjustAccidentals();}AccidentalCollision.prototype.createBoundingShapesArrays = function() {    for (var a = 0; a < this.amount; a ++) {        var accidental = this.accidentals[a];        accidental.boundingShapes = [];        for (zone in accidental.dimensions) {            if (zone === "body") {                var boundingShape = {};                boundingShape.type = "body";                var vertices = accidental.dimensions.body.boundingShape;                boundingShape.vertices = vertices;                accidental.boundingShapes.push(boundingShape);            }            else if (zone === "columns") {                for (var c = 0; c < accidental.dimensions.columns.length; c ++) {                    var boundingShape = {};                    boundingShape.type = "column";                    boundingShape.number = c;                    var vertices = accidental                        .dimensions                        .columns[c]                        .boundingShape;                    boundingShape.vertices = vertices;                    accidental.boundingShapes.push(boundingShape);                };            }            else if (zone === "arrow") {                var boundingShape = {};                boundingShape.type = "arrow";                var vertices = accidental.dimensions.arrow.boundingShape;                boundingShape.vertices = vertices;                accidental.boundingShapes.push(boundingShape);            };        };    };};AccidentalCollision.prototype.createDyadList = function() {        this.dyadList = [];    for (var a = 0; a < this.amount - 1; a ++) {        for (var aa = a + 1; aa < this.amount; aa ++) {            var cur = this.accidentals[a];            var next = this.accidentals[aa];            var dyad = {};            dyad.accidentals = [cur, next];            this.dyadList.push(dyad);        };    };};AccidentalCollision.prototype.createAllCollisions = function() {    for (var d = 0; d < this.dyadList.length; d ++) {        var dyad = this.dyadList[d];        this.dyadCollision(dyad);    };};AccidentalCollision.prototype.adjustAccidentals = function() {    // First search for adjacent catastrophic collisions;    // Call this.moveAccidental only on first one    var adjacentCollisionID;    var adjacentCollisions = false;    if (this.dyadList.length > 2) {                //t.w("2 or more dyads");        for (var i = 0, ii = i + 2; i < this.dyadList.length; i ++, i ++) {            var curDyad = this.dyadList[i];            var nextDyad = this.dyadList[ii];            // Adjacent catastrophic collisions            if (curDyad.collisionStatus.isSolvableWithoutMovement === false &&                nextDyad.collisionStatus.isSolvableWithoutMovement === false) {                adjacentCollisions = true;                adjacentCollisionID = ii;            };        };        if (adjacentCollisions === true) {            //t.w("accidentalCollisions is true")            for (var d = 0; d < this.dyadList.length; d ++) {                var dyad = this.dyadList[d];                if (d === adjacentCollisionID) {                    this.moveAccidental(dyad);                }                else if ((d !== adjacentCollisionID)  ||                         (d !== adjacentCollisionID - 2)                ) {                    if (dyad.collisionStatus.hasCollision === true) {                        //t.w(".hasCollision === true");                        var solution = dyad.collisionStatus.solution;                        for (var method in solution) {                            //t.w("method: " + method);                            //t.w("dyad: " + dyad);                            this[method](dyad);                        };                    };                };            };        }        // if no adjacent collisions: go on as usual        else {            for (var d = 0; d < this.dyadList.length; d ++) {                var dyad = this.dyadList[d];                var a = dyad.accidentals[0];                var b = dyad.accidentals[1];                if (dyad.collisionStatus.hasCollision === false) {                    // Pass, let these accidentals stay as they are!                }                else {                    //t.w("HAS COLLISION");                    var solution = dyad.collisionStatus.solution;                    for (var method in solution) {                        //t.w(method);                        var param = solution[method];                        this[method](param);                    };                    //t.w(">>> BUT IS SOLVABLE");                };            };        };    }    else if (this.dyadList.length === 1) {        //t.w("single dyad");        var dyad = this.dyadList[0];        //t.w("dyad: " + dyad);        //t.w(dyad.collisionStatus.hasCollision);        if (dyad.collisionStatus.hasCollision === false) {            // Pass, do nothing        }        // If collision: if catastrophic: move, else: adjust        else {            //t.w("solution: " + dyad.collisionStatus.solution);            var solution = dyad.collisionStatus.solution;            for (var method in solution) {                //t.w(method);                var param = solution[method];                this[method](param);            };        };    };}AccidentalCollision.prototype.dyadCollision = function(dyad) {    //t.w("------------------------------------------------");    // return info (to be added to allCollisions)    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    dyad.collisions = [];    for (var ai = 0; ai < a.boundingShapes.length; ai ++) {        var verticesA = a.boundingShapes[ai].vertices;        var typeA = a.boundingShapes[ai].type;                for (var bi = 0; bi < b.boundingShapes.length; bi ++) {            var verticesB = b.boundingShapes[bi].vertices;            var typeB = b.boundingShapes[bi].type;                        if (polygonCollision(verticesA, verticesB)) {                var collision = {};                collision.a = typeA;                collision.b = typeB;                                if (typeA === "column") {                    collision.aColumnID = a.boundingShapes[ai].number;                }                if (typeB === "column") {                    collision.bColumnID = b.boundingShapes[bi].number;                };                dyad.collisions.push(collision);            };        };    };    dyad.collisionStatus = {};    if (dyad.collisions.length === 0) {        dyad.collisionStatus.hasCollision = false;        ////t.w("NO COLLISIONS");    }    else {        var status = this.isSolvableWithoutMovement(dyad);        var solvable = status.isSolvableWithoutMovement;        var solution = status.solution;        dyad.collisionStatus.hasCollision = true;        dyad.collisionStatus.isSolvableWithoutMovement = solvable;        dyad.collisionStatus.solution = solution;    };};AccidentalCollision.prototype.isSolvableWithoutMovement = function(dyad) {    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var collisions = dyad.collisions;    // First filter out conveniently solvable exceptions    if (collisions.length === 1) {        var collision = collisions[0];                var typeA = collision.a;        var typeB = collision.b;        if (typeA === "column" && typeB === "column") {            var columnA = collision.aColumnID;            var columnB = collision.bColumnID;            // for testing only!            //this.singleColumnToColumnSolution(dyad);                        // Return object with method, and dyad as variable            return {                "isSolvableWithoutMovement": true,                "solution": {                    "singleColumnToColumnSolution": dyad                }            };        }        else if (            (typeA === "column" && typeB === "arrow") ||            (typeA === "arrow" && typeB === "column")        ) {                        // for testing only            // this.singleColumnToArrowSolution(dyad);                        // return method of solution            return {                "isSolvableWithoutMovement": true,                "solution": {                    "singleColumnToArrowSolution": dyad                }            };        }        else if (            (typeA === "column" && typeB === "body") ||            (typeA === "body" && typeB === "column")        ) {                        // for testing            //this.singleColumnToBodySolution(dyad);                        // return method of solution            return {                "isSolvableWithoutMovement": true,                "solution": {                    "singleColumnToBodySolution": dyad                }            };        };    }    else {        var bodyAPresent = false;        var bodyBPresent = false;        var amountColumnA = [0,0];        var amountColumnB = [0,0];        var amountArrows = 0;        var arrowBody = false;        for (var c = 0; c < collisions.length; c ++) {            var curCollision = collisions[c];            var typeA = curCollision.a;            var typeB = curCollision.b;            if (typeA === "column") {                amountColumnA[curCollision.aColumnID] ++;            };            if (typeB === "column") {                amountColumnB[curCollision.bColumnID] ++;            };            // Body on body collision: CATASTROPHIC            if (typeA === "body" && typeB === "body") {                                // Must resort to moving accidental                return {                    "isSolvableWithoutMovement": false,                    "solution": {                        "moveAccidental": dyad                    }                };            };            if (typeA === "body") bodyAPresent = true;            if (typeB === "body") bodyBPresent = true;            if (                (typeA === "arrow" && typeB === "body") ||                (typeA === "body" && typeB === "arrow")            ) {                // an object with status and method of solution                return this.checkArrowBody(dyad);                //arrowBody = true;            };        };        if (bodyAPresent === false && bodyBPresent === false &&            amountArrows === 0) {            // just columns on columns            return {                "isSolvableWithoutMovement": true,                "solution": {                    "multipleColumnsSolution": dyad                }            };        }        if (bodyAPresent === true && bodyBPresent === true) {                        // an object with status and method of solution            return this.checkBothBodiesPresent(dyad);        }        else {            ////t.w("potentially singleColumnCulprit");            var culprit = a.dimensions.columns[0].components.thinLine;                        // for testing only            // this.singleColumnCulpritSolution(dyad);            return {                 "isSolvableWithoutMovement": true,                "solution": {                    "singleColumnCulpritSolution": dyad                }            };        };    };};AccidentalCollision.prototype.checkBothBodiesPresent = function(dyad) {    ////t.w("BOTH BODIES PRESENT");    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    if (        (            // If flat or quarterFlat involved in any capacity            (a.coarse === -1 && b.coarse !== -1) ||             (a.coarse !== -1 && b.coarse === -1) ||            (a.coarse === -0.5 && b.coarse !== -0.5) ||            (a.coarse !== -0.5 && b.coarse === -0.5)        )         ||        (               // If one, but not both accidentals are quarterSharps            (a.coarse === 0.5 && b.coarse !== 0.5) ||            (a.coarse !== 0.5 && b.coarse === 0.5)        )    ) {        return {            "isSolvableWithoutMovement": false,            "solution": {                "moveAccidental": dyad            }        };    }    else {        return {            "isSolvableWithoutMovement": true,            "solution": {                "bothBodiesPresentSolution": dyad            }        };    };};AccidentalCollision.prototype.checkArrowBody = function(dyad) {    // return false OR object = { method for solution }    //t.w("ARROW BODY");    var collisions = dyad.collisions;    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];       // find out which accidental has arrow    for (var c = 0; c < collisions.length; c ++) {        var curCollision = collisions[c];        var typeA = curCollision.a;        var typeB = curCollision.b;        if (typeA === "arrow" && typeB === "body") {                       // check if a.arrow.boundingShape can be lowered            // a.arrow info            var tipX = a.dimensions.arrow.boundingShape[1][0];            var tipY = a.dimensions.arrow.boundingShape[1][1];            var tipY_adj = tipY - (0.25 * a.g);                        // b.body info            var boundingShape = b.dimensions.body.boundingShape;            var lastVal = boundingShape.length - 1;            var penultimateVal = boundingShape.length - 2;            var last = boundingShape[lastVal];            var penultimate = boundingShape[penultimateVal];            var x = tipX;            var bodyY = this.bodyLineSegAtX([last, penultimate], x);                        // If we can solve this problem without movement            if (tipY_adj < bodyY) {                return {                    "isSolvableWithoutMovement": true,                    "solution": {                        "arrowBodySolution": dyad                    }                };            }            // If we must resort to moving one of the accidentals            else {                return {                    "isSolvableWithoutMovement": false,                    "solution": {                        "moveAccidental": dyad                    }                };            };        }        else if (typeA === "body" && typeB === "arrow") {            // check if arrow can be raised            // b.arrow info            var tipX = b.dimensions.arrow.boundingShape[1][0];            var tipY = b.dimensions.arrow.boundingShape[1][1];            var tipY_adj = tipY + (0.25 * b.g);                        // a.body info            var boundingShape = a.dimensions.body.boundingShape;            var first = boundingShape[0];            var second = boundingShape[1];            var x = tipX;            var bodyY = this.bodyLineSegAtX([first, second], x);                        if (tipY_adj > bodyY) {                return {                    "isSolvableWithoutMovement": true,                    "solution": {                        "arrowBodySolution": dyad                    }                };            }            else {                return {                    "isSolvableWithoutMovement": false,                    "solution": {                        "moveAccidental": dyad                    }                }            };        };    };};AccidentalCollision.prototype.singleColumnToColumnSolution = function(dyad) {    //t.w("single collision: column: column:: split a.y / b.y diff");    // takes in the dyad of this simple collision    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var aY = a.y;    var bY = b.y;    var meanY = (a.y + b.y) / 2;    var aColumnID = dyad.collisions[0].aColumnID;    var bColumnID = dyad.collisions[0].bColumnID;    var aColumn = a.dimensions.columns[aColumnID].components.thinLine;    var bColumn = b.dimensions.columns[bColumnID].components.thinLine;    var aYParam;    var bYParam;    // Make sure we are adjusting the correct end point    if (aColumn.y0 > aColumn.y1) aYParam = "y0";    else aYParam = "y1";    if (bColumn.y0 < bColumn.y1) bYParam = "y0";    else bYParam = "y1";    if (aColumn[aYParam] > meanY && bColumn[bYParam] < meanY) {        // Adjust the end points for each column        aColumn[aYParam] = (meanY - a.boundingPadding);        bColumn[bYParam] = (meanY + a.boundingPadding);    }    else {        aColumn[aYParam] = bColumn[bYParam] - 2 * a.boundingPadding;    };  };AccidentalCollision.prototype.singleColumnToArrowSolution = function(dyad) {    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var collision = dyad.collisions[0];    if (collision.a === "column") {        var aColumnID = collision.aColumnID;        var aColumn = a.dimensions.columns[aColumnID].components.thinLine;        var aYParam = this.sortEndPoints(aColumn)[1];        bTipY = b.dimensions.arrow.boundingShape[1][1];        var bodyPoints = [            a.dimensions.body.boundingShape[0],            a.dimensions.body.boundingShape[1]        ];        var lowestAllowableY = (            this.bodyLineSegAtX(bodyPoints, aColumn.x) + 1 * a.boundingPadding        );        if (bTipY < lowestAllowableY) {            // Adjust b.arrow            bTipY += 0.25 * b.g;            bArrow = b.dimensions.arrow.components.arrow;            bArrow.tip = bTipY;            if (aColumn[aYParam] > bTipY - 0.5 * b.boundingPadding) {                aColumn[aYParam] = bTipY - 0.5 * b.boundingPadding;                // must also adjust correct b.column                var bColumnID;                if (b.coarse === 0 || b.coarse === 1) {                    bColumnID = 1;                    var direction = -1;                }                else {                    bColumnID = 0;                    var direction = 1;                };                bColumn = b.dimensions.columns[bColumnID].components.thinLine;                var bYParam = this.sortEndPoints(bColumn)[0];                bColumn[bYParam] += 0.125 * b.g;            };        }        else {            aColumn[aYParam] = bTipY - 0.5 * b.boundingPadding;        };    }    else if (collision.b === "column") {        var bColumnID = collision.bColumnID;        var bColumn = b.dimensions.columns[bColumnID].components.thinLine;        var bYParam = this.sortEndPoints(bColumn)[0];        aTipY = a.dimensions.arrow.boundingShape[1][1];        var lastVal = b.dimensions.body.boundingShape.length - 1;        var penultimateVal = b.dimensions.body.boundingShape.length - 2;        var bodyPoints = [            b.dimensions.body.boundingShape[lastVal],            b.dimensions.body.boundingShape[penultimateVal]        ];        var highestAllowableY = (            this.bodyLineSegAtX(bodyPoints, bColumn.x) - 1 * b.boundingPadding        );        if (aTipY > highestAllowableY) {            // Adjust a.arrrow            aTipY -= 0.25 * a.g;            aArrow = a.dimensions.arrow.components.arrow;            aArrow.tip = aTipY;            if (bColumn[bYParam] < aTipY + 0.5 * a.boundingPadding) {                bColumn[bYParam] = aTipY - 0.5 * a.boundingPadding                // must also adjust the correct a.column!                var aColumnID;                if (a.coarse === 1) aColumnID = 1;                else aColumnID = 0;                aColumn = a.dimensions.columns[aColumnID].components.thinLine;                var aYParam = this.sortEndPoints(aColumn)[1];                aColumn[aYParam] -= 0.125 * a.g;            };        };        bColumn[bYParam] = aTipY + 0.5 * a.boundingPadding;    };};AccidentalCollision.prototype.singleColumnToBodySolution = function(dyad) {    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var collision = dyad.collisions[0];    if (collision.a === "column") {        var aColumnID = collision.aColumnID;        var aColumn = a.dimensions.columns[aColumnID].components.thinLine;        var aYParam = this.sortEndPoints(aColumn)[1];        var lastVal = a.dimensions.body.boundingShape.length - 1;        var penultimateVal = a.dimensions.body.boundingShape.length - 2;        var bodyPoints = [            b.dimensions.body.boundingShape[lastVal],            b.dimensions.body.boundingShape[penultimateVal]        ];        var refY = this.bodyLineSegAtX(bodyPoints, aColumn.x);        aColumn[aYParam] = refY - 3 * a.boundingPadding;    }    else if (collision.b === "column") {        var bColumnID = collision.bColumnID;        var bColumn = b.dimensions.columns[bColumnID].components.thinLine;        var bYParam = this.sortEndPoints(bColumn)[0];        var bodyPoints = [            a.dimensions.body.boundingShape[0],            a.dimensions.body.boundingShape[1]        ];        var refY = this.bodyLineSegAtX(bodyPoints, bColumn.x);        bColumn[bYParam] = refY + 3 * b.boundingPadding;    };};AccidentalCollision.prototype.singleColumnCulpritSolution = function(dyad) {    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    if (a.coarse === b.coarse) {                ////t.w("singlecolumnCulprit: both flat or quarterFlat");        // both flat or quarterFlat        // adjust a.column[0] downward        var column = a.dimensions.columns[0].components.thinLine;        // avoid b.body        if (b.fine >= 0) {            ////t.w("b.fine: " + b.fine);            var lastVal = b.dimensions.body.boundingShape.length - 1;            var penultimateVal = b.dimensions.body.boundingShape.length - 2;            var bodyPoints = [                b.dimensions.body.boundingShape[lastVal],                b.dimensions.body.boundingShape[penultimateVal]            ];            var newY = this.bodyLineSegAtX(bodyPoints, column.x);            var yParam = this.sortEndPoints(column)[1];            column[yParam] = newY - 1.5 * a.boundingPadding;        }        // avoid b.arrow        else if (b.fine < 0) {            ////t.w("b.fine: " + b.fine);            ////t.w("AVOID ARROW!!");            var bTipY = b.dimensions.arrow.boundingShape[1][1];            var yParam = this.sortEndPoints(column)[1];            column[yParam] = bTipY - a.boundingPadding;        };            }    else if (b.fine < 0) {        // avoid b.arrow        ////t.w("AVOID ARROW");        var column = a.dimensions.columns[0].components.thinLine;        var bTipY = b.dimensions.arrow.boundingShape[1][1];        var yParam = this.sortEndPoints(column)[1];        column[yParam] = bTipY - a.boundingPadding    }    else if (b.coarse === 0 && a.coarse === -1) {        // avoid a.body        var column = a.dimensions.columns[0].components.thinLine;        var lastVal = b.dimensions.body.boundingShape.length - 1;        var penultimateVal = b.dimensions.body.boundingShape.length - 2;        var bodyPoints = [            b.dimensions.body.boundingShape[lastVal],            b.dimensions.body.boundingShape[penultimateVal]        ];        var newY = this.bodyLineSegAtX(bodyPoints, column.x);        var yParam = this.sortEndPoints(column)[1];        column[yParam] = newY - 1.5 * a.boundingPadding;    }    else {        if (b.fine < 0) {            // avoid b.arrow            var column = a.dimensions.columns[0].components.thinLine;            var bTipY = b.dimensions.arrow.boundingShape[1][1];            var yParam = this.sortEndPoints(column)[1];            column[yParam] = bTipY - 1.5 * a.boundingPadding;        };        // a = quarterFlat; b = natural        // set both to meanY +/- padding, if that is in fact less than current b.y0;    }};AccidentalCollision.prototype.multipleColumnsSolution = function(dyad) {    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var meanY = (a.y + b.y) / 2;    // split difference of altitude +/- boundingPadding    for (var c = 0; c < a.dimensions.columns.length; c ++) {            };}AccidentalCollision.prototype.arrowBodySolution = function(dyad) {    //t.w("ARROW BODY SOLUTION");    // IF arrow body collision can be fixed without movement    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var collisions = dyad.collisions;    var typeA, typeB;    for (var c = 0; c < collisions.length; c ++) {        var collision = collisions[c];        if (collision.a === "body" && collision.b === "arrow") {            typeA = "body";            typeB = "arrow";            //t.w("a: body; b: arrow");            break;        }        else if (collision.a === "arrow"  && collision.b === "body") {            typeA = "arrow";            typeB = "body";            //t.w("a: arrow; b: body");            break;        };    };    if (typeA === "body" && typeB === "arrow") {        // move b.arrow and column up        var bArrow = b.dimensions.arrow.components.arrow;        var bodyPoints = [            a.dimensions.body.boundingShape[0],            a.dimensions.body.boundingShape[1]        ];        var bTipX = b.dimensions.arrow.boundingShape[1][0];        var newY = this.bodyLineSegAtX(bodyPoints, bTipX);                // adjust arrow        bArrow.tip += 0.25 * b.g;        // adjust b.column up        // if b is sharp, second column        var aColumnID, bColumnID;        // right side column        if (b.coarse === 0 || b.coarse === 1) {            bColumnID = 1;            // right side column conflict            if (a.coarse === 1 || a.coarse === -0.5) {                //t.w("A IS SHARP OR QUARTER FLAT, ADJUST RIGHT COLUMN!");                                // short a.column right                if (a.coarse === 1) aColumnID = 1;                else if (a.coarse === -0.5) aColumnID = 0;                var aColumn = a.dimensions.columns[aColumnID].components.thinLine;                var aYParam = this.sortEndPoints(aColumn)[1];                aColumn[aYParam] = bArrow.tip - 1 * a.boundingPadding;            };        };        // left side or centered column        else {            bColumnID = 0;            aColumnID = 0;            if (a.coarse === 0 || a.coarse === -1 || a.coarse === 1) {                // shorten a.column left                var aColumn = a.dimensions.columns[0].components.thinLine;                var aYParam = this.sortEndPoints(aColumn)[1];                aColumn[aYParam] = bArrow.tip - 1 * a.boundingPadding;            }        };        var bColumn = b.dimensions.columns[bColumnID].components.thinLine;        var bYParam = this.sortEndPoints(bColumn)[0];        bColumn[bYParam] += 0.25 * b.g;    }    else if (typeA === "arrow" && typeB === "body") {        //t.w("a: arrow; b: body");        // move a.arrow and column down        var aArrow = a.dimensions.arrow.components.arrow;        var lastVal = b.dimensions.body.boundingShape.length - 1;        var penultimateVal = b.dimensions.body.boundingShape.length - 2;        var bodyPoints = [            b.dimensions.body.boundingShape[lastVal],            b.dimensions.body.boundingShape[penultimateVal]        ];        var aTipX = a.dimensions.arrow.boundingShape[1][0];        var newY = this.bodyLineSegAtX(bodyPoints, aTipX);        // adjust arrow        aArrow.tip -= 0.25 * a.g;        // adjust a column down        // if sharp, adjust second line        var aColumnID, bColumnID;        if (a.coarse === 1) {            aColumnID = 1;        }        else {            aColumnID = 0;        };        var aColumn = a.dimensions.columns[aColumnID].components.thinLine;        var aYParam = this.sortEndPoints(aColumn)[1];        aColumn[aYParam] -= 0.25 * a.g;        // if necessary, adjust b.column up    };};AccidentalCollision.prototype.bothBodiesPresentSolution = function(dyad) {    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var collisions = dyad.collisions;    if (a.coarse === 0.5 && b.coarse === 0.5) {        var meanY = (a.y + b.y ) / 2;        // shorten a.column        var aColumn = a.dimensions.columns[0].components.thinLine;        var aYParam = this.sortEndPoints(aColumn)[1];        aColumn[aYParam] = meanY - 2 * a.boundingPadding;        // shorten b.column        var bColumn = b.dimensions.columns[0].components.thinLine;        var bYParam = this.sortEndPoints(bColumn)[0];        bColumn[bYParam] = meanY + 2 * b.boundingPadding;    }    else if (a.coarse === 1 && b.coarse === 0) {        // shorten both a.columns        // shorten b.column[0];    }    else if (a.coarse === 0 && b.coarse === 1) {        // shorten both b.columns        // shorten a.column[0];    }    else if (a.coarse === 0 && b.coarse === 0) {        // shorten a.column[0];        // shorten b.column[1];    }    else if (a.coarse === 1 && a.coarse === 1) {        // shorten both a.columns        // shorten both b.columns    };};AccidentalCollision.prototype.moveAccidental = function(dyad) {    var a = dyad.accidentals[0];    var b = dyad.accidentals[1];    var collisions = dyad.collisions;    // Figure out extreme points of collision (may not be the same as accidental)    var xMinA, xMaxA, xMinB, xMaxB;    var maxDimensionsA, maxDimensionsB;    for (var c = 0; c < collisions.length; c ++) {        var collision = collisions[c];        var typeA = collision.a;        if (typeA === "column") {            var aColumnID = collision.aColumnID;            var boundingShapeA = a.dimensions.columns[aColumnID].boundingShape;        }        else {            var boundingShapeA = a.dimensions[typeA].boundingShape;        };        var typeB = collision.b;        if (typeB === "column") {            var bColumnID = collision.bColumnID;            var boundingShapeB = b.dimensions.columns[bColumnID].boundingShape;        }        else {            var boundingShapeB = b.dimensions[typeB].boundingShape;        };        maxDimensionsA = this.maxDimensions(boundingShapeA);        maxDimensionsB = this.maxDimensions(boundingShapeB);        var xMinA, xMaxA, xMinB, xMaxB;        if (maxDimensionsA.xMin < xMinA || ! xMinA) xMinA = maxDimensionsA.xMin;        if (maxDimensionsA.xMax > xMaxA || ! xMaxA) xMaxA = maxDimensionsA.xMax;        if (maxDimensionsB.xMin < xMinB || ! xMinB) xMinB = maxDimensionsB.xMin;        if (maxDimensionsB.xMax > xMaxB || ! xMaxB) xMaxB = maxDimensionsB.xMax;        ////t.w("xMaxA: " + xMaxA + "; xMinB: " + xMinB);    };    var dx = (        (b.x - xMinB) +        (xMaxA - a.x) +        1.5 * a.boundingPadding    );    ////t.w("dx: " + (-dx));    a.move(-dx, 0);};AccidentalCollision.prototype.sortEndPoints = function(linePoints) {    // takes in y0 and y1 dimensions of a line, returns a sorted list    if (linePoints.y0 > linePoints.y1) return ["y1", "y0"];    else return ["y0", "y1"];};AccidentalCollision.prototype.maxDimensions = function(vertices) {    var xMin, xMax, yMin, yMax;    for (var p = 0; p < vertices.length; p ++) {        if (vertices[p][0] < xMin || ! xMin) xMin = vertices[p][0];        if (vertices[p][0] > xMax || ! xMin) xMax = vertices[p][0];        if (vertices[p][1] < yMin || ! yMin) yMin = vertices[p][1];        if (vertices[p][1] > yMax || ! yMax) yMax = vertices[p][1];    };    return {        "xMin": xMin,        "xMax": xMax,        "yMin": yMin,        "yMax": yMax     };}AccidentalCollision.prototype.bodyLineSegAtX = function(points, x) {    var refPoints = points;    refPoints.sort(function(a,b) { return a[0] > b[0] } );    var point0 = refPoints[0];    var point1 = refPoints[1];    var rise = point1[1] - point0[1];    var run = point1[0] - point0[0];    var slope = rise / run;    var newX = x - point0[0];    var newY = (slope * newX) + point0[1];    return newY;}// Different methods for different caseAccidentalCollision.prototype.mutualBody = function(a, b) {        var bodyAXMax = a.dimensions.body.maxDimensions.xMax;    var bodyBXMin = b.dimensions.body.maxDimensions.xMin;    var dx = (        (bodyAXMax - a.x) +         (b.x - bodyBXMin) +         (3 * a.boundingPadding)    );    a.move(-dx, 0);};