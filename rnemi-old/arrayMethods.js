#include "conversions.js"Array.prototype.absMax = function() {        return Math.max.apply({}, Math.abs(this));};Array.prototype.absMin = function() {        return Math.min.apply({}, Math.abs(this));};Array.prototype.avg = function() {        return this.sum() / this.length;};Array.prototype.max = function() {        return Math.max.apply({}, this);};Array.prototype.min = function() {        return Math.min.apply({}, this);};Array.prototype.numSort = function() {        return this.sort(function(a, b){return a - b});};Array.prototype.last = function() {        return this[this.length - 1];};Array.prototype.sum = function() {    for (var i = 0, sum = 0 ; i !== this.length; ++i) {        var n = this[i];        if(!isNaN(n)) {            sum += n;        };    };    return sum;};  Array.prototype.absSum = function() {        for (var i = 0, sum = 0 ; i !== this.length; ++i) {        var n = this[i];        if(!isNaN(n)) {            sum += Math.abs(n);        }    }    return sum;};Array.prototype.contains = function(obj) {        var i = this.length;    while (i--) {        if (this[i] === obj) {            return true;        }    }    return false;};Array.prototype.remove = function(val) {    var index;    var i = this.length;    while (i--) {        if (this[i] === val) {            index = i;            break;        }    }    this.splice(index, 1);}Array.prototype.equals = function (array) {    // if the other array is a falsy value, return    if (!array)        return false;    // compare lengths - can save a lot of time     if (this.length != array.length)        return false;    for (var i = 0, l=this.length; i < l; i++) {        // Check if we have nested arrays        if (this[i] instanceof Array && array[i] instanceof Array) {            // recurse into the nested arrays            if (!this[i].equals(array[i]))                return false;               }                   else if (this[i] !== array[i]) {             // Warning - two different object instances will never be equal: {x:20} != {x:20}            return false;           };    };        return true;};  Array.prototype.getUnique = function(){      var u = {}, a = [];    for (var i = 0, l = this.length; i < l; ++i) {        if (u.hasOwnProperty(this[i])) {                continue;        }        a.push(this[i]);        u[this[i]] = 1;    }    return a;}Array.prototype.uniquePermutations = function() {        var permutations = [];        function permute (arr, data) {        var cur, memo = data || [];        for (var i = 0; i < arr.length; i ++) {            cur = arr.splice(i, 1)[0];            if (arr.length === 0) {                permutations.push(memo.concat([cur]));            };            permute(arr.slice(), memo.concat([cur]));            arr.splice(i, 0, cur);          };        return permutations;    };    return permute (this).getUnique();}Array.prototype.reduceAllByGCD = function() {    // Find gcd    var x = this[0] < 0 ? -this[0] : this[0];    for (var i = 0; i < this.length; i ++) {        var y = this[i] < 0 ? - this[i] : this[i];        while (x && y) { x > y ? x %= y : y %= x; };        x += y;    };    // reduce by gcd    for (var i = 0; i < this.length; i ++) {        this[i] /= x;    };}Array.prototype.cumulative = function() {        var cumulative = [];    var curSum = 0;    for (var i = 0; i < this.length; i ++) {        curEvent = this[i];        curSum += curEvent;        cumulative.push(curSum);    };    return cumulative;}Array.prototype.primeList = function() {    var sum = this.absSum();    var primeList = [];    for (var i = 3; i < sum - 2; i ++) {        if (isPrime(i)) primeList.push(i);    };    // Sort prime list from highest-to-lowest    primeList.sort( function(a,b) { return b - a; } )    return primeList;};Array.prototype.containsWithinRange = function(n) {    this.numSort();    if (n >= this[0] && n < this[1]) return true;    return false;};Array.prototype.maxΔ = function() {    var maxΔ;    for (var i = 1; i < this.length; i ++) {        var Δ = this.delta(this[i-1], this[i]);        if (!maxΔ || Δ > maxΔ) maxΔ = Δ;    };    return maxΔ;}Array.prototype.maxΔIndices = function() {    var maxΔ = this.maxΔ();    var indices = [];    for (var i = 1; i < this.length; i ++) {        if (this.delta(this[i-1], this[i]) === maxΔ) indices.push(i);    };    return indices;}Array.prototype.maxIndices = function() {    var max = this.max();    var indices = [];    for (var i = 0; i < this.length; i ++) {        if (this[i] === this.max()) indices.push(i);    };    return indices;}Array.prototype.delta = function(prev, cur) {    var vals = [cur,prev].numSort();    var Δ = (vals[1] / vals[0]) - 1;    if (cur < prev) delta *= -1;    return Δ;}Array.prototype.direction = function(prev, cur) {    if (cur === prev) { return 0; }    else if (cur < prev) { return -1; }    else { return 1; };}Array.prototype.repetitionAtIndex = function(index) {    var repCount = 0;    for (var i = index - 1; i >= 0; i --) {        if (this[index] === this[i]) { repCount ++; }        else { return repCount; };    };    return repCount;}Array.prototype.dirSpans = function() {    var dirSpans = [];    for (var i = 2; i < this.length; i ++) {        var curDir = this.direction(this[i-1], this[i]);        var prevDir = this.direction(this[i-2], this[i-1]);        if (            dirSpans.length > 0 &&            curDir === prevDir &&            curDir === dirSpans.last().direction &&            i === dirSpans.last().indices[1] + 1        ) {            // extend current dirSpan to current index            dirSpans.last().indices[1] = i;        }        else if (curDir === prevDir) {            // create new dirSpan            var dirSpan = {};            dirSpan.direction = curDir;            dirSpan.indices = [ (i-2), i ];            dirSpans.push(dirSpan);        };    };    for (var d = 0; d < dirSpans.length; d ++) {        var dirSpan = dirSpans[d];        dirSpan.sequence = [];        var start = dirSpan.indices[0];        var end = dirSpan.indices[1];        for (var i = start; i <= end; i ++) {            dirSpan.sequence.push(this[i]);        };    };    return dirSpans;};function intersection(a, b) {        var ai = 0, bi = 0;    var result = [];    while (ai < a.length && bi < b.length) {        if (a[ai] < b[bi]) { ai++; }        else if (a[ai] > b[bi]) { bi++; }        else {          result.push(a[ai]);          ai++;          bi++;        };    };    if (result.length > 0) return true;};function byFirstValue(a,b){        if (a[0] < b[0]) return -1;    if (a[0] > b[0]) return 1;    return 0;};/*function bestClefTransposition(pitch, preferred) {        // First, check "default" staff: preferredClefs[0]    if (pitch < defaultClefCenter + 12 &&        pitch > defaultClefCenter - )        // Return the best clef/transposition pair for current pitch    for (var c = 0; c < preferredClefs.length; c ++) {                if (pitch > )    }};*/