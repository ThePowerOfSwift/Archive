function RegroupedRhythm(durList, beats, subdivision) {        this.durList = durList;    this.beats = reduce(beats, subdivision).beats;    this.scaleSpan(beats, subdivision);    this.groups = [];    this.sum = this.durList.sum()    durs = this.scaleDurations();    this.regroup(durs, beats);    return this.reformat();};RegroupedRhythm.prototype.scaleSpan = function(beats, subdivision) {    var adj = reduce(beats, subdivision);    // CLEAN UP ONCE THINGS ARE ACTUALLY FIGURED OUT!    var subdScale = (subdivision > adj.subdivision)                 ? (subdivision / 2) / adj.subdivision                 : 1;    subdScale = (subdivision === 8 && adj.subdivision)                 ? subdScale *= 2                 : subdScale;    if (adj.beats === 3 &&         adj.subdivision === subdivision &&        this.durList.length <= 4    ) { subdScale /= 3; };       if (adj.beats === 1 && adj.subdivision === 8) subdScale /= 2;    this.beats = adj.beats * subdScale;    if (adj.beats === 3 && adj.subdivision === 8) this.beats = 3;    t.w("beats: " + beats + "; subdivision: " + subdivision);    t.w("adj.beats: " + adj.beats + "; adj.subdivision: " + adj.subdivision);    t.w("this.beats: " + this.beats);}RegroupedRhythm.prototype.scaleDurations = function() {    var durs = [];    for (var d = 0; d < this.durList.length; d ++) {        durs[d] = this.durList[d] * this.beats;    };    return durs;}RegroupedRhythm.prototype.regroup = function(durs, beats) {    if (this.groups.length === 0) {        this.isOpen = false;        this.groups.push([]);    };    var sum = 0;    var cur = durs[0];    for (var i = 0; i < this.groups.last().length; i ++) {        sum += this.groups.last()[i].beats;    };    // still within limits of beat    if (cur + sum < this.sum) {        var span = {};        span.beats = cur;        if (this.isOpen) span.receiving = true;        this.groups.last().push(span);        this.isOpen = false;        this.regroup(durs.slice(1), beats);    }    // flush with next beat    else if (cur + sum === this.sum) {        var span = {};        span.beats = cur;        if (this.isOpen) span.receiving = true;        this.isOpen = false;        this.groups.last().push(span);        if (durs.length > 1) this.groups.push([]);        this.regroup(durs.slice(1), beats)    }    // too big, must cut into multiple, tied durations    else if (cur + sum > this.sum) {        var span = {};        span.beats = this.sum - sum;        span.sending = true;        if (this.isOpen) span.receiving = true;        this.groups.last().push(span);        this.groups.push([]);        durs[0] = cur - (this.sum - sum);        this.isOpen = true;        this.regroup(durs, beats);    };};RegroupedRhythm.prototype.reformat = function() {    var regrouped = [];    for (var g = 0; g < this.groups.length; g ++) {        var group = [];        for (d = 0; d < this.groups[g].length; d ++) {            var e = this.groups[g][d];            var val;            if (e.sending) { val = e.beats.toString(); }            else { val = e.beats; };            group.push(val);        };        var types = group.typeAtIndex();        if (group.length > 1) { group.reduceAllByGCD(); }        else { group = [1]; };        for (var i = 0; i < group.length; i ++) {            if (types[i] === "string") group[i] = group[i].toString();        };        regrouped.push(group);    };    return regrouped;};