#include "TupletBracket.js"#include "DynamicMarking.js"//#include "ClarinetDiagram.js"//#include "FluteDiagram.js"function BeamGroup(Span) {     this.Span = Span;    this.beatIndex = this.Span.beatIndex;    this.widthInBeats = this.Span.widthInBeats;    this.beatWidth = 72;    //this.graphicalDimensions();    this.flattenEvents();    // this should be called a little later?    this.expansion();}BeamGroup.prototype.testRect = function(graphicalContext) {        var rect = graphicalContext.pathItems.rectangle(        this.altitude,        this.left,         this.width,        this.g    );    rect.strokeWidth = 0.5    rect.locked = true;}BeamGroup.prototype.graphicalDimensions = function() {    this.beamWidth = (this.withNumerics) ? (0.33 * this.g) : (0.225 * this.g);    this.beamDisplace = 0.5 * this.g;    this.newSpanIDPad = 0.225 * this.g;    this.tupletDepthDisplace = 1.618 * this.g;    this.augDotDisplace = 0.8 * this.g;    this.beats = this.Span.beats;    this.subdivision = this.Span.subdivision;    this.beatScale = this.Span.beatScale;    this.width = (        (this.beats / this.subdivision) * 8 *         (this.beatScale * this.beatWidth)    );    this.right = this.left + this.width;    this.center = (this.right + this.left) / 2;    this.beam = [];    this.beamlet = [];};BeamGroup.prototype.expansion = function() {    this.bracketDisplaceAtDepth = {};    this.clickHeightAtDepth = [];    for (var d = 0; d <= this.maxTupletDepth; d ++) {        //this.bracketDisplaceAtDepth[d] = (d === this.maxTupletDepth) ? 0 : 1.618;        if (d === this.maxTupletDepth) { this.bracketDisplaceAtDepth[d] = 0; }        else { this.bracketDisplaceAtDepth[d] = 1.618; };        if (this.isExpanded === true) {                var leastSubdLevel = this.leastSubdLevelAtDepth[d];            var clickHeight = clickHeightBySubdLevel(leastSubdLevel);            this.bracketDisplaceAtDepth[d] += clickHeight + 1;            if (this.withTempo === true && d < this.maxTupletDepth) {                this.bracketDisplaceAtDepth[d] += 1.618;            };        };    };};BeamGroup.prototype.flattenEvents = function() {    var leastSubdLevelAtDepth = {};    var amountEvents = 0;    var flattened = [];    var idCount = 0;    var maxTupletDepth = 0;    function flattenAndCount(Span, depthCount, spanCount) {        // Establish basic environmental attributes        if (typeof depthCount === "number") {             depthCount ++;            var localSubdLevel = subdToLevel(Span.spans[0].subdivision);            if (! leastSubdLevelAtDepth[depthCount] ||                localSubdLevel < leastSubdLevelAtDepth[depthCount] ) {                leastSubdLevelAtDepth[depthCount];            };        };        else {             depthCount = 0;            Span.id = 0;            leastSubdLevelAtDepth[depthCount] = subdToLevel(                Span.spans[0].subdivision            );        };        // Query each event, add to event count, differentiate spanIDs, etc        for (spanCount = 0; spanCount < Span.spans.length; spanCount ++) {            var curSpan = Span.spans[spanCount];            if (depthCount > maxTupletDepth) maxTupletDepth = depthCount;            if (curSpan.type === "spanGroup") {                idCount ++;                curSpan.id = idCount;                flattenAndCount(curSpan, depthCount, spanCount);            }            else if (curSpan.type === "event" || curSpan.type === "rest") {                amountEvents ++;                curSpan.depth = depthCount;                curSpan.id = Span.id;                flattened.push(curSpan);            };        };    };    flattenAndCount(this.Span);    this.leastSubdLevelAtDepth = leastSubdLevelAtDepth;    this.flattened = flattened;    this.maxTupletDepth = maxTupletDepth;    this.amountEvents = amountEvents;};BeamGroup.prototype.traverseSpanGroup = function(    graphicalContext, Span, depthCount, spanCount) {        if (typeof depthCount === "number") { depthCount ++; };    else { depthCount = 0; };    var spanGroup = this.spanGroup(graphicalContext, Span, depthCount);    var graphicalContext = spanGroup.graphicalContext;    var tupletBracket = spanGroup.tupletBracket;    //var depthCount = spanGroup.depthCount;    if (this.amountEvents === 1) {         this.singleEvent(graphicalContext, Span);        if (Span.spans[0].type === "event" || Span.spans[0].type === "rest") {            if (this.extensionStratum.status === "open") {                var extension = this.extensionStratum.extensions.last();                extension.end(this.x);                extension.draw();                var stemEnd = extension.altitude -                     this.stemDirection * 0.5 * extension.thickWidth;                this.stem(graphicalContext, this.x, stemEnd);            }            else {               this.manageComponents(graphicalContext, this.x, Span.spans[0]);             }            if ("extension" in Span.spans[0]) {                var extension = this.extensionStratum.addExtension();                extension.begin(this.x);                this.extensionStratum.status = "open";            } else { this.extensionStratum.status = "closed"; };            this.colorItemsByDepth(graphicalContext, depthCount);        };    }    else {        // Iterate through Spans        for (spanCount = 0; spanCount < Span.spans.length; spanCount ++) {            if (spanCount === 0) {this.hasNewTupletBracket = true; }            else { this.hasNewTupletBracket = false; };            var curSpan = Span.spans[spanCount];            if (curSpan.type === "event" || curSpan.type === "rest") {                if (this.extensionStratum.status === "open") {                    var extension = this.extensionStratum.extensions.last();                    extension.end(this.x);                    extension.draw();                    var stemEnd = extension.altitude -                         this.stemDirection * 0.5 * extension.thickWidth;                    this.stem(graphicalContext, this.x, stemEnd);                }                else { this.manageComponents(graphicalContext, this.x, curSpan); };                if (curSpan.beats % 3 === 0) this.augDot(graphicalContext);                // first event                if (this.eventCount === 0) {                    this.firstEvent(graphicalContext, Span);                }                // middle event                else if (                    this.eventCount > 0 &&                     this.eventCount < this.amountEvents - 1 &&                    this.amountEvents > 2 &&                    this.withMetrics === true                ) { this.middleEvent(graphicalContext, Span, tupletBracket); }                // last event                else if (this.eventCount === this.amountEvents - 1) {                    this.lastEvent(graphicalContext, Span, tupletBracket);                };                // If beginning extensions                if ("extension" in curSpan) {                    var extension = this.extensionStratum.addExtension();                    var x = curSpan.beats % 3 === 0                         ? this.x + 1.618 * this.augDotDisplace                         : this.x;                    extension.begin(x);                    this.extensionStratum.status = "open";                } else { this.extensionStratum.status = "closed"; };                this.colorItemsByDepth(graphicalContext, depthCount);                                // Proceed to next event                var beats = curSpan.beats;                var subdivision = curSpan.subdivision;                var beatScale = curSpan.beatScale;                var curBeatWidth = (                    (beats / subdivision) * 8 * this.beatWidth * beatScale                );                this.eventCount ++;                this.x += curBeatWidth;            }            else if (curSpan.type === "spanGroup") {                var graphicalContext = graphicalContext;                this.traverseSpanGroup(                    graphicalContext, curSpan, depthCount, spanCount                );            };        };    };};BeamGroup.prototype.manageComponents = function(graphicalContext, x, Span) {    // this is getting out of hand, consider cleaning when dust settles :/    var maxY;    var minY;    for (var c = 0; c < Span.components.length; c ++) {        var component = Span.components[c];        var performerID = component.performerID;        var graphID = component.graphID;        var performer = this.System.performersByPerformerID[performerID];        var graph = performer.instruments[0].graphsByID[graphID];        var primaryGraphID = performer.instruments[0].primaryGraphID;        var dynamicStratum = this.Voice.dynamicStratum;        var extensionStratum = this.Stratum.extensionStratum;        if (performerID === this.primaryPerformerID || graphID === "sounding") {            if (Span.type === "rest") {                if (                    (performerID === this.primaryPerformerID &&                      graphID === primaryGraphID) ||                    (performerID !== this.primaryPerformerID)                ) {                    var subd = Span.subdLevel_adj;                    var stemEnd = this.stemDirection === 1 ?                         graph.bottom - 0.25 * graph.g :                         graph.top + 0.25 * graph.g;                    this.stemlet(graphicalContext, x, subd);                    this.restStem(graphicalContext, x, stemEnd, subd, graph.g);                    graph.rest(x);                    if ("dynamicINFO" in component) {                        var dynamic = component.dynamicINFO.marking;                        dynamicStratum.rest(dynamic, x, "implicit");                    };                };            }            else if (Span.type === "event") {                if ("pitchINFO" in component) {                    if (performerID === this.primaryPerformerID) {                        graph.managePitches(x, component.pitchINFO);                    };                    // check if graph is primary graph                    if (                        (performerID === this.primaryPerformerID &&                          graphID === primaryGraphID)                    ) {                        var maxY = graph.maxNoteheadY;                        var minY = graph.minNoteheadY;                        var stemEnd = this.stemDirection === 1 ? minY : maxY;                        this.stem(graphicalContext, x, stemEnd);                    }                    else if (                        (performerID !== this.primaryPerformerID &&                         graphID === "sounding")                    ) {                        if (this.primaryPerformerID === "omni") {                            graph.managePitches(x, component.pitchINFO);                            var maxY = graph.maxNoteheadY;                            var minY = graph.minNoteheadY;                            var stemEnd = this.stemDirection === 1 ? minY : maxY;                            this.stem(graphicalContext, x, stemEnd);                        }                        else {                            var cueGraph = performer.instruments[0].graphsByID["cue"];                            var stemEnd = cueGraph.top;                            this.stem(graphicalContext, x, stemEnd);                        };                    };                };                if ("dynamicINFO" in component) {;                    if (                        (performerID === this.primaryPerformerID &&                          graphID === primaryGraphID) ||                        (performerID !== this.primaryPerformerID)                    ) {                        var dynamic = component.dynamicINFO.marking;                        var interp = component.dynamicINFO.interp;                        dynamicStratum.marking(dynamic, x, "ord", interp);                    };                };                 if ("fingeringINFO" in component) {                    t.w("fingeringINFO in component: " + performerID);                    var diagramTypeByPerformerID = {                        "FL": "fluteDiagram",                        "CL": "clarinetDiagram"                    };                    this[diagramTypeByPerformerID[performerID]](                        component.fingeringINFO                    );                }                             };        };     };};BeamGroup.prototype.clarinetDiagram = function(fingering) {    //var diagram = new ClarinetDiagram(this.x, this.altitude, this.g, fingering);};BeamGroup.prototype.fluteDiagram = function(fingering) {    //var diagram = new FluteDiagram(this.x, this.altitude, this.g, fingering);}BeamGroup.prototype.spanGroup = function(graphicalContext, Span, depthCount) {    Span.durList = this.durListFromSpan(Span);    var graphicalContext = graphicalContext.groupItems.add();    graphicalContext.name = "SpanGroup: " + Span.beats + ": " + Span.subdivision;    if (this.withNumerics === true &&        this.amountEvents > 1 &&        Span.spanSum_adj !== Span.beats_adj     ) {        var tupletBracket = this.tupletBracket(            graphicalContext, Span, depthCount        );        if (depthCount < this.maxTupletDepth) {            // Add bookend ligatures as necessary (perhaps encapsulate this);            var firstSpan = Span.spans[0];            if (firstSpan.type === "spanGroup") {                var ligature = tupletBracket.ligature(this.x);                var bracketRef = this.getBracketDisplace(depthCount + 1);                var vertDisplace = this.stemDirection * ligature.vertDisplace;                var bracketHeight = this.stemDirection * tupletBracket.height;                var beamEnd = bracketRef + bracketHeight + vertDisplace;                ligature.begin(beamEnd);            }            else if (firstSpan.type === "event" || firstSpan.type === "rest") {                var ligature = tupletBracket.ligature(this.x);                var beamRef = this.altitude + (                    this.stemDirection * 0.5 * this.beamWidth                );                var beamEnd = beamRef + ligature.vertDisplace;                ligature.begin(beamEnd);            };            var lastSpan = Span.spans.last();            if (lastSpan.type === ("event" || "rest")) {                var x = tupletBracket.right - tupletBracket.padRight;                var ligature = tupletBracket.ligature(x);                ligature.end();            };        };    };    return {        "graphicalContext": graphicalContext,        "tupletBracket": tupletBracket,        "depthCount": depthCount    };};BeamGroup.prototype.colorItemsByDepth = function(graphicalContext, depth) {    var color = (this.withMetrics) ? tupletColor[depth].darkColor : gray[50];        for (var i = 0; i < graphicalContext.pathItems.length; i ++) {        var item = graphicalContext.pathItems[i];        item.strokeColor = color;        if (item.filled) item.fillColor = color;        // if (!item.strokeDashes) item.fillColor = color;    };}BeamGroup.prototype.singleEvent = function(graphicalContext, Span) {    var min = 0;    var amount = Span.spans[0].subdLevel_adj;    //var amount = (this.withMetrics) ? 1 : Span.subdLevel;    var direction = 1;    this.beamlets(graphicalContext, this.x, min, amount, direction);};BeamGroup.prototype.firstEvent = function(graphicalContext, Span) {    var cur = this.flattened[this.eventCount];    var next = this.flattened[this.eventCount + 1];    cur.subdLevel = cur.subdLevel_adj;    next.subdLevel = next.subdLevel_adj;    var subdOrdered = [cur.subdLevel, next.subdLevel].numSort();    if (this.withMetrics) {        var x = this.x;        var min = 0;        var amount = subdOrdered[0];        this.beams(graphicalContext, min, amount);        this.beamPoints(x, amount);        if (cur.subdLevel > next.subdLevel) {            // Add beamlets            var x = this.x;            var min = next.subdLevel + 1;            var amount = cur.subdLevel - min;            var direction = 1;            this.beamlets(graphicalContext, x, min, amount, direction);        };    }    else {        var x = this.x;        var min = 0;        var amount = 1;        this.beams(graphicalContext, min, amount);        this.beamPoints(x, amount);    };};BeamGroup.prototype.middleEvent = function(graphicalContext, Span, tupletBracket) {    var prev = this.flattened[this.eventCount - 1];    var cur = this.flattened[this.eventCount];    var next = this.flattened[this.eventCount + 1];    prev.subdLevel = prev.subdLevel_adj;    cur.subdLevel = cur.subdLevel_adj;    next.subdLevel = next.subdLevel_adj;    // Single event spanID    if (cur.id !== prev.id && cur.id !== next.id) {        // Add TupletBracketLigature as necessary        if (!this.hasNewTupletBracket && cur.depth < prev.depth) {            var ligature = tupletBracket.ligature(this.x);            ligature.reintroduce();        };        // Extend previous spanID beams // consider encapsulating this        var x = this.x - this.newSpanIDPad;        var amount;        if (cur.subdLevel <= prev.subdLevel) {            if (next.subdLevel < cur.subdLevel) { amount = next.subdLevel; }            else { amount = cur.subdLevel; };        }        else { amount = prev.subdLevel; };        this.beamPoints(x, amount);        // Declare beams and add beamPoints        var x = this.x;        var min = 0;        var amount = cur.subdLevel;        this.beams(graphicalContext, min, amount);        this.beamPoints(x, amount);    }    // First event in spanID    else if (cur.id !== prev.id && cur.id === next.id) {        // Add TupletBracketLigature as necessary        if (!this.hasNewTupletBracket && cur.depth < prev.depth) {            var ligature = tupletBracket.ligature(this.x);            ligature.reintroduce();        };        // Extend previous spanID beams // consider encapsulating this        var x = this.x - this.newSpanIDPad;        var amount;        if (cur.subdLevel <= prev.subdLevel) {            if (next.subdLevel < cur.subdLevel) { amount = next.subdLevel; }            else { amount = cur.subdLevel; };        }        else { amount = prev.subdLevel; };        this.beamPoints(x, amount);        // Declare beams and add beamPoints for current event        if (cur.subdLevel > next.subdLevel) {            var x = this.x;            var min = 0;            var amount = next.subdLevel;            this.beams(graphicalContext, min, amount);            this.beamPoints(x, amount);            // Add beamlets            var x = this.x;            var min = next.subdLevel + 1;            var amount = cur.subdLevel - min;            var direction = 1;            this.beamlets(graphicalContext, x, min, amount, direction);        }        else {            var x = this.x;            var min = 0;            var amount = cur.subdLevel;            this.beams(graphicalContext, min, amount);            this.beamPoints(x, amount);        };    }    // Continuation of spanID    else if (cur.id === prev.id && cur.id === next.id) {        var subdOrdered = [            prev.subdLevel, cur.subdLevel, next.subdLevel        ].numSort()        // Declare beams        if (next.subdLevel > prev.subdLevel) {            var min = prev.subdLevel + 1;            var amount = cur.subdLevel - prev.subdLevel;            if (cur.subdLevel > next.subdLevel) {                amount -= (cur.subdLevel - next.subdLevel);            };            this.beams(graphicalContext, min, amount);        };        // Add beamPoints        var x = this.x;        var amount = cur.subdLevel;        if (cur.subdLevel > prev.subdLevel && cur.subdLevel > next.subdLevel) {            amount -= (cur.subdLevel - subdOrdered[1]);        };        this.beamPoints(x, amount);        // Add beamlets        var x = this.x;        var min = subdOrdered[1] + 1;        var amount = cur.subdLevel - min;        var direction = (next.beats > prev.beats) ? -1 : 1;        this.beamlets(graphicalContext, x, min, amount, direction);    }    // Last event in spanID    else if (cur.id === prev.id && cur.id !== next.id) {        var subdOrdered = [prev.subdLevel, cur.subdLevel].numSort();        // Declare beams if necessary        if (cur.subdLevel > prev.subdLevel) {            var min, amount;            if (cur.subdLevel > next.subdLevel) {                // Add beamlets                x = this.x;                min = prev.subdLevel + 1;                amount = cur.subdLevel - min;                direction = -1;                this.beamlets(graphicalContext, x, min, amount, direction);                // Add beamPoints                var x = this.x;                var amount = prev.subdLevel;                this.beamPoints(x, amount);            }            else {                min = prev.subdLevel + 1;                amount = cur.subdLevel - min;                this.beams(graphicalContext, min, amount);                // Add beamPoints                x = this.x;                amount = cur.subdLevel;                this.beamPoints(x, amount);            };        };        else {            // Add beamPoints            var x = this.x;            var amount = cur.subdLevel;            this.beamPoints(x, amount);        };    };};BeamGroup.prototype.lastEvent = function(graphicalContext, Span, tupletBracket)  {    var prev = this.flattened[this.eventCount - 1];    var cur = this.flattened[this.eventCount];    prev.subdLevel = prev.subdLevel_adj;    cur.subdLevel = cur.subdLevel_adj;    var subdOrdered = [prev.subdLevel, cur.subdLevel].numSort();    // Add TupletBracketLigature as necessary    if (cur.depth < prev.depth && cur.depth < this.maxTupletDepth) {        var ligature = tupletBracket.ligature(this.x);        ligature.reintroduce();    };    // single spanID at end    if (cur.id !== prev.id) {        // Add beamPoints to previous beams if less than quarter note        var x = this.x - this.newSpanIDPad;        var amount;        if (cur.subdLevel > 0) {            if (cur.subdLevel < prev.subdLevel) { amount = cur.subdLevel; }            else if (cur.subdLevel > prev.subdLevel) { amount = prev.subdLevel; }            else { amount = cur.subdLevel; };            this.beamPoints(x, amount);        };        // Declare new beams as necessary        var x = this.x;        var min = 0;        var amount = subdOrdered[0];        this.beams(graphicalContext, min, amount);        this.beamPoints(x, amount);        // Extending beamlets        var x = this.x;        var min = 0;        var amount = cur.subdLevel;        var direction = 1;        this.beamlets(graphicalContext, x, min, amount, direction);    }    // ending of SpanID    else if (cur.id === prev.id) {         if (cur.subdLevel > prev.subdLevel) {            // Add beamPoints            var x = this.x;            var amount = prev.subdLevel;            this.beamPoints(x, amount);            // Add beamlets            var min = prev.subdLevel + 1;            var amount = cur.subdLevel - min;            var direction = -1;            this.beamlets(graphicalContext, x, min, amount, direction);         }         else {            // Just add beamPoints to preexisting beams            var x = this.x;            var amount = cur.subdLevel;            this.beamPoints(x, amount);         };    };};BeamGroup.prototype.draw = function(graphicalContext) {    this.graphicalDimensions();    this.graphicalContext = graphicalContext;    this.ligatureContext = this.graphicalContext.layers.add();        // Draw the thing    this.x = this.left;    this.eventCount = 0;    this.traverseSpanGroup(graphicalContext, this.Span, null);};BeamGroup.prototype.tupletBracket = function(graphicalContext, Span, depth) {    //$.writeln("BeamGroup.tupletBracket()");    var left = this.x;    var bracketDisplace = this.getBracketDisplace(depth) * this.g;    var altitude = this.altitude + (this.stemDirection * bracketDisplace);    if (! this.isExpanded) altitude += this.stemDirection * 0.5 * this.g;    var tupletDepth = depth;    var spanSum = Span.spanSum_adj;    var beats = Span.beats_adj;    var subdivision = Span.spans[0].subdivision;    var beatStructure = Span.beatStructure;    var beatScale = Span.beatScale;    var tempo = Span.tempo || 60 * Span.tempo * (1/beatScale);        var tupletBracket = new TupletBracket(        this, graphicalContext, left, altitude, tupletDepth,        spanSum, beats, subdivision, beatStructure,        beatScale, tempo    );    return tupletBracket;};BeamGroup.prototype.beams = function(graphicalContext, min, amount) {    if (amount < 0) amount = -1;    for (var level = min; level <= min + amount; level ++) {        this.beam[level] = graphicalContext.pathItems.add();        this.beam[level].strokeWidth = this.beamWidth;        this.beam[level].filled = false;    };};BeamGroup.prototype.beamPoints = function(x, amount) {    if (amount >= 0) {        for (var level = 0; level <= amount; level ++) {        var y = this.altitude - (level * this.beamDisplace * this.stemDirection);            var beamPoint = this.beam[level].pathPoints.add();            beamPoint.anchor = [x, y];            beamPoint.leftDirection = beamPoint.anchor;            beamPoint.rightDirection = beamPoint.anchor;        };     };};BeamGroup.prototype.beamlets = function(    graphicalContext, x, min, amount, direction) {    var beamlet_length = 0.5 * this.g;    if (min >= 0) {        for (var level = min; level <= (min + amount); level ++) {            var x0 = x;            var x1 = x + (beamlet_length * direction);            var y = this.altitude - (level * this.beamDisplace * this.stemDirection);            var points = [[x0, y], [x1, y]];            this.beamlet[level] = graphicalContext.pathItems.add();            this.beamlet[level].setEntirePath(points);            this.beamlet[level].strokeWidth = this.beamWidth;            this.beamlet[level].filled = false;        };    };};BeamGroup.prototype.stem = function(graphicalContext, x, stemEnd) {    var strokeWidth = 0.0618 * this.g;    var y0 = stemEnd;    var y1 = this.altitude + this.stemDirection * 0.5 * this.beamWidth;    var stem = graphicalContext.pathItems.add();    stem.setEntirePath([[x, y0],[x, y1]]);    stem.strokeWidth = strokeWidth;    stem.filled = false;};BeamGroup.prototype.restStem = function(graphicalContext, x, stemEnd, subdLevel, g) {    var strokeWidth = 0.0618 * this.g;    var stemletLength = (this.beamDisplace * subdLevel) + (0.618 * this.g);    var y0 = stemEnd;    var y1 = this.altitude - (this.stemDirection * stemletLength);    var stem = graphicalContext.pathItems.add();    stem.setEntirePath([[x, y0],[x, y1]]);    stem.strokeWidth = strokeWidth;    stem.filled = false;    stem.strokeDashes = [0.5 * g];}BeamGroup.prototype.stemlet = function(graphicalContext, x, subdLevel) {        var strokeWidth = 0.0618 * this.g;    var stemletLength = (this.beamDisplace * subdLevel) + (0.618 * this.g);    var y0 = this.altitude + (this.stemDirection * 0.5 * this.beamWidth);    var y1 = this.altitude - (this.stemDirection * stemletLength);    var points = [[x, y0], [x, y1]];        var stemlet = graphicalContext.pathItems.add();    stemlet.setEntirePath(points);    stemlet.strokeWidth = strokeWidth;    stemlet.filled = false;};BeamGroup.prototype.augDot = function(graphicalContext) {        // we want the area to proporionate with g, not height;    var area = 0.382 * this.g;    var height = areaToDiameter(area);    /*var top = this.altitude + (0.5 * height) - this.stemDirection * (        this.beamHeight + 1 * this.g // fine-tune    );*/    var displace = this.Stratum.greatestSubdLevel * this.beamWidth +         0.5 * this.Stratum.displaceFromPerformer;    // var displace = 2 * this.g;    //var top = this.altitude - this.stemDirection * displace;    var top = this.Stratum.extensionStratum.altitude + 0.5 * height;    var left = this.x + this.augDotDisplace;    var dot = graphicalContext.pathItems.ellipse(        top, left, height, height    );    dot.strokeWidth = 0;    dot.filled = true;};BeamGroup.prototype.slash = function(graphicalContext) {    var color = gray[75];    var displace = 1.2 * this.g;    var x0 = this.left - 0.5 * displace;     var x1 = this.left + displace;    var y0 = this.altitude - (this.stemDirection * displace);    var y1 = this.altitude + (this.stemDirection * 0.5 * displace);    var points = [[x0, y0],[x1, y1]];    var slash = graphicalContext.pathItems.add();    slash.setEntirePath(points);    slash.strokeWidth = 0.125 * this.g;    slash.strokeColor = color;    slash.filled = false;};BeamGroup.prototype.setStratum = function(Stratum) {    this.Stratum = Stratum;    this.primaryPerformerID = this.Stratum.primaryPerformerID;    this.Voice = this.Stratum.Voice;    this.System = this.Stratum.System;    this.extensionStratum = this.Stratum.extensionStratum;    this.g = this.Stratum.g;    this.isExpanded = this.Stratum.isExpanded;    this.withTempo = this.Stratum.withTempo;    this.withMetrics = this.Stratum.withMetrics;    this.withNumerics = this.Stratum.withNumerics;};BeamGroup.prototype.getBracketDisplace = function(depth) {    //$.writeln("BeamGroup.getBracketDisplace()");    var displace = 0;    for (var d = this.maxTupletDepth; d >= depth; d --) {        displace += this.bracketDisplaceAtDepth[d];    };    return displace;};BeamGroup.prototype.durListFromSpan = function(Span) {    //$.writeln("BeamGroup.durListFromSpan()");    var durList = [];    for (var s = 0; s < Span.spans.length; s ++) {        var dur = Span.spans[s].beats;        Span.durList.push(dur);    };    return durList;};