/*TO-DO:- Currently EVEN spans are just cut up into more even spans: this is not always right- Sometimes only a single 3-beat microPrototype is appropriate!- */#include "arrayMethods.js"#include "conversions.js"function AgogicPrototype(durList) {    // Returns an array of arrays [ [],[],[] ] or [ [] ], etc    this.durList = durList;     //$.writeln(this.durList.absSum());    this.compoundPrototype = [];        // Scan durList to see what action is needed    this.examineDurList(durList);    for (var p = 0; p < this.compoundPrototype.length; p ++) {       //$.writeln(p + ": " + this.compoundPrototype[p]);    };};AgogicPrototype.prototype.examineDurList = function(durList) {    //$.writeln("--------- EXAMINE DUR LIST: " + durList);        // SINGLE EVENT SPAN --------------------------------------    if (durList.length === 1) {        // Even duration        if (durList.absSum() % 2 === 0) {            this.compoundPrototypeEven(durList.absSum());        }        // Odd duration        else {            //this.chosenPrototype = this.oddDur(this.durList[0]);        };    }    // DOUBLE EVENT SPAN --------------------------------------    /*else if (durList.length === 2) {        if (durList.absSum() % 2 === 0) {        }        else {        }    }*/    // MULTIPLE EVENT SPAN ------------------------------------    else if (durList.length >= 2) {                // IF THIS IS EVEN        if (durList.absSum() % 2 == 0) {            // At some point, add options for multi-factorable evens            // Add this microprototype to master compound prototype            this.compoundPrototypeEven(durList.absSum());        }        // IF THIS IS A MICRO-PROTOTYPE!        else if (durList.absSum() <= 7) {            this.compoundPrototype.push(this.microPrototypeOdd(durList));        }        // IF THIS IS A COMPOUND-PROTOTYPE!        else if (durList.absSum() >= 9) {            this.compoundPrototypeOdd(durList);        }    };}AgogicPrototype.prototype.uniquePermutations = function(durSum) {    // Create combination of 2s and 3s    var combo = [];    // Add a single 3-beat    combo.push(3);    // For the remaining beats, add 2-beats    for (var i = 0; i < (durSum - 3) / 2; i ++) { combo.push(2) };    var permutations = combo.uniquePermutations();        return permutations;};AgogicPrototype.prototype.microPrototypeOdd = function(durList) {    // Returns single array of best fitting syncopation    var potentialMicroPrototypes = this.uniquePermutations(durList.absSum());    // Array of objects with prototype and syncopation    var prototypesWithSyncopation = [];    for (var m = 0; m < potentialMicroPrototypes.length; m ++) {        curMicroPrototype = potentialMicroPrototypes[m];        syncopation = this.checkSyncopation(durList, curMicroPrototype);        var prototypeWithSyncopation = {};        prototypeWithSyncopation.microPrototype = curMicroPrototype;        prototypeWithSyncopation.syncopation = syncopation;        prototypesWithSyncopation.push(prototypeWithSyncopation);    };    // Sort potential prototypes by LOWEST to HIGHEST syncopation    prototypesWithSyncopation.sort( function(a,b) {        return a.syncopation - b.syncopation    });    var leastSyncopation = prototypesWithSyncopation[0].syncopation;    // Filter out all potential prototypes with greater syncopation    var i = 0;    while (i < prototypesWithSyncopation.length) {                if (prototypesWithSyncopation[i].syncopation > leastSyncopation) {            // Delete potential prototype with high syncopation            prototypesWithSyncopation.splice(i, 1);        }        else { i ++ };    };    // ONLY ONE BEST FIT    if (prototypesWithSyncopation.length === 1) {        // Pass best fitting microPrototype        return prototypesWithSyncopation[0].microPrototype;    }    // MULTIPLE BEST FIT    else {        // Filter out microPrototypes that don't end or begin with 3-beat        var i = 0;        while (i < prototypesWithSyncopation.length) {            var curPrototype = prototypesWithSyncopation[0].microPrototype;            var firstDur = curPrototype[0];            var lastDur = curPrototype[curPrototype.length - 1];            // If 3 is in middle            if (firstDur !== 3 && lastDur !== 3) {                prototypesWithSyncopation.splice(i, 1);            }            else { i ++ };        };        if (prototypesWithSyncopation.length === 1) {            return prototypesWithSyncopation[0].microPrototype;        }        else {            var i = 0;            while (i < prototypesWithSyncopation.length) {                var curPrototype = prototypesWithSyncopation[0].microPrototype;                var firstDur = curPrototype[0];                if (firstDur !== 3) {                    prototypesWithSyncopation.splice(i, 1);                }                else { i ++ };            };            return prototypesWithSyncopation[0].microPrototype;        };    };};AgogicPrototype.prototype.compoundPrototypeOdd = function(durList) {    if (durList.absSum() === 9) var oddList = [5];    else var oddList = [5,7];    var priorSum = 0;    var potentialSpanList = [];    function scanOddSpan(durList) {        for (var i = 0; i < durList.length; i ++) {            var firstDur = durList[i];            var curSpanSum = firstDur;            var amountElements = 1;                        for (var ii = i + 1; ii < durList.length; ii ++) {                if (ii === durList.length - 1) var isLastDur = true;                else var isLastDur = false;                var curDur = durList[ii];                curSpanSum += curDur;                var subsequentSum = durList.absSum() - (curSpanSum + priorSum);                amountElements ++;                if (                    // IF EITHER FIRST EVENT, OR PRIOR SUM GREATER THAN 3                    (i === 0 || priorSum > 3) &&                                        // AND IF EITHER LAST EVENT, OR SUBSEQUENT SUM GREAT THAN 3                    (isLastDur === true || subsequentSum > 3) &&                                        // AND IF CURRENT SPAN SUM IS 5 or 7                    (oddList.contains(curSpanSum))                 ) {                    // Create object for current positive match                    var match = {};                    match.index = i;                    match.sum = curSpanSum;                    match.amountElements = amountElements;                    match.avgElDur = curSpanSum / amountElements;                    // Add match object to potentialSpanList                    potentialSpanList.push(match);                };             };            priorSum += firstDur;        };    };    scanOddSpan(durList);    // Once all is said and done, check    if (potentialSpanList.length === 0) {        //$.writeln("PLAN B MUST RECONTEXTUALIZE ALL BEATS!");        // PLAN B, recontextualize all beats    }    else {        // Sort potential odd matches by average element duration        potentialSpanList.sort(function(a,b) {return a.avgElDur - b.avgElDur});        var chosenSpanInfo = potentialSpanList[0];        var index = chosenSpanInfo.index;        var amount = chosenSpanInfo.amountElements;        var newSpanList = [];                var cutPoints = [            // Prior events, if any            [0, index],            // Current span            [index, index + amount],            // Subsequent events, if any            [index + amount, durList.length]        ];        for (var c = 0; c < cutPoints.length; c ++) {            var enter = cutPoints[c][0];             var exit = cutPoints[c][1];            var newDurList = durList.slice(enter, exit);            if (newDurList.length > 0) {                this.examineDurList(newDurList);            };        };    };};AgogicPrototype.prototype.microPrototypeEven = function(sum) {    // Returns arrays of 2s    var microPrototype = [];    for (var j = 0; j < sum / 2; j ++) {        microPrototype.push(2);    };    //$.writeln("even microPrototype return: " + microPrototype);    return microPrototype;};AgogicPrototype.prototype.compoundPrototypeEven = function(sum) {    if (sum <= 6 && sum > 0) {                //$.writeln("EVEN: sum less than or equal to 6: " + this.microPrototypeEven(sum));        this.compoundPrototype.push(this.microPrototypeEven(sum));    }    else if (sum > 6) {                //$.writeln("EVEN: sum greater than 6: " + this.microPrototypeEven(4));        var evenPrototype = [];        // Cut down by four, recurse as modified        this.compoundPrototype.push(this.microPrototypeEven(4));        // Recurse downward until everything has been cut down        this.compoundPrototypeEven(sum - 4);    };};AgogicPrototype.prototype.checkSyncopation = function(durList, prototype) {    function compare(cumulativeDurList, cumulativePrototype) {        // If event occurs on prototype beat        if (cumulativeDurList[0] === cumulativePrototype[0]) {            cumulativeDurList.splice(0, 1);            cumulativePrototype.splice(0, 1);            if (cumulativeDurList.length > 1) {                compare(cumulativeDurList, cumulativePrototype);            };        }        // If event occurs before next prototype beat        else if (cumulativeDurList[0] < cumulativePrototype[0]) {            var delayedMatch = false;            // Check if upcoming events fall on prototype beat            for (i = 1; i < cumulativeDurList.length; i ++) {                if (cumulativeDurList[i] <= cumulativePrototype[0]) {                    delayedMatch = true;                    delayedMatchIndex = i;                    break;                };            };            // If upcoming event falls on prototype beat            if (delayedMatch === true) {                cumulativeDurList.splice(0, delayedMatchIndex + 1);                cumulativePrototype.splice(0, 1);                // Proceed to next event, adding no syncopation!                if (cumulativeDurList.length > 1) {                    compare(cumulativeDurList, cumulativePrototype);                };            }            else if (delayedMatch === false) {                // Add 2 points if syncopation occurs on 3-beat!                // Add to the syncopation value                syncopation ++;                cumulativeDurList.splice(0, 1);                cumulativePrototype.splice(0, 1);                // Proceed to next event, with added syncopation                if (cumulativePrototype.length > 1) {                    compare(cumulativeDurList, cumulativePrototype);                };            };        }        // If event occrs after next prototype beat        else if (cumulativeDurList[0] > cumulativePrototype[0]) {            var delayedMatch = false;            for (var i = 1; i < cumulativePrototype.length; i ++) {                // Check if current event falls on or after next prorotype beat                if (cumulativeDurList[0] >= cumulativePrototype[i]) {                    delayedMatch = true;                    delayedMatchIndex = i;                    break;                };            };            if (delayedMatch === true) {                if (cumulativeDurList.length > 1) {                    cumulativeDurList.splice(0, 0);                    cumulativePrototype.splice(0, delayedMatchIndex);                    // Continue to next evet                    compare(cumulativeDurList, cumulativePrototype);                };            }            else if (delayedMatch === false) {                // Add 2 points if syncopation occurs on 3-beat!                syncopation ++;                cumulativeDurList.splice(0, 1);                cumulativePrototype.splice(0, 1);                if (cumulativeDurList.length > 1) {                    // Continue to next event                    compare(cumulativeDurList, cumulativePrototype);                };            };        };    };    var cumulativeDurList = durList.cumulative();    var cumulativePrototype = prototype.cumulative();    var syncopation = 0;    compare(cumulativeDurList, cumulativePrototype);      return syncopation;};AgogicPrototype.prototype.oddDur = function(dur) {    // Returns [n arrays of [arrays of 2s and 3s]]    // Check for factors    if (factors(dur).length === 0) {    }    else if (factors(dur).length === 1) {    }    else if (factors(dur).length === 2) {    }    else {    };};//var a = new AgogicPrototype(durList);