// Converts MIDI nn to frequencyfunction midiToFreq(midi) {    var freq = 440.*(Math.pow(2,((midi-69.)/12.)));    return freq;};// Mean to Sigma Quadratic curve (make more subtle later)function meanToSigma(mean, min, range) {    var sigma = ((.5*range)/Math.pow(.5*range,2))*                 Math.pow((mean - (.5*range + min)),2) + .25*range               return sigma;};// Converts frequency to MIDI nnfunction freqToMidi(freq) {    var midi = 69. + 12.*(Math.log(freq/440.)/Math.LN2);    return midi;};// Converts slope to anglefunction slopeToAngle(slope) {    var angle = Math.atan(slope)*(180/Math.PI);    return angle;};// Takes in height, width; returns hypotenusefunction pythagoras(a, b) {    var c = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));    return c;}function roundBinary(n) {    var binary = [];    for (var e = 0; e < 5; e ++) {        binary.push(Math.pow(2,e));    };    var cur = binary[0];    var diff = Math.abs(n - cur);    for (var val = 0; val < binary.length; val ++) {        var newDiff = Math.abs(n - binary[val]);        if (newDiff < diff) {            diff = newDiff;            cur = binary[val];        };    };    return cur;}function areaToDiameter(area) {    var r = Math.sqrt(area / Math.PI);    return r * 2;}// Takes in key val (1, -0.5), returns string version ("active", "trill_half")function keyValToState(keyVal) {    var toState = {        "-1": "trill",        "-0.5": "trill_half",        "0": "idle",        "0.5": "half",        "1": "active"    };    return toState[keyVal];};// Takes in fingerboard position and MIDI nn of openString, returns frequencyfunction positionToFreq(position, stringMidi) {    var freq = midiToFreq(stringMidi)/(1-position);    return freq;};// Takes in fingerboard position and MIDI nn of openString, returns midifunction positionToMidi(position, stringMidi) {    var midi = freqToMidi(midiToFreq(stringMidi)/(1-position));    return midi;};// Takes in relative duration of event, returns subdivision level (# of beams) [CLEAN]function valToSubdLevel(val, groupSubdLevel) {    if (val % 3 === 0) {        var subdLevel = Math.log(groupSubdLevel)/Math.log(2) -            Math.log(val/3*2)/Math.log(2) - 3    }    else {        var subdLevel = Math.log(groupSubdLevel)/Math.log(2) -            Math.log(val)/Math.log(2) - 3    };     return subdLevel;};// Reduce fraction for rhythmic ratiosfunction reduce(beats, subdivision) {    var gcd = function gcd(a,b) { return b ? gcd(b, a % b) : a; };    gcd = gcd(beats,subdivision);    return {        "beats": beats / gcd,        "subdivision": subdivision / gcd    };};// Given current sum of values and overall group duration, returns arrayfunction xAdjustY(spanSum, beats, subdivision) {    var potentialYList = [];    for (var exponent = -8; exponent < 8; exponent ++) {        potentialYList.push(beats*Math.pow(2,exponent));    };    var cur = potentialYList[0];    var diff = Math.abs(spanSum - cur);    for (var val = 0; val < potentialYList.length; val ++) {        var newDiff = Math.abs(spanSum - potentialYList[val]);        if (newDiff < diff) {            diff = newDiff;            cur = potentialYList[val];        };    };    while (cur % 1 !== 0) {        cur *= 2;        spanSum *= 2;    };    /*// reduce    reduced = reduce(spanSum, cur);        spanSum = reduced[0];    cur = reduced[1];*/    // Adjust subdivision by change in beats        subdivision *= cur/beats;    return {        "beats": cur,        "spanSum": spanSum,        "subdivision": subdivision    };};// Takes in decimal and return [beat, beat_type] tuplefunction decimalToTimeSig(val) {    // Assumes 8th note is primary beat    var e = 0;    do {        var multiplier = Math.pow(2,e)        var product = val * multiplier;        if (product % 1 === 0) { return [product, 8 * multiplier]; }        else { e ++; };    } while (product % 1 !== 0)}function factors(num) {    var factors = [];    for (var i = 2; i <= Math.floor(Math.sqrt(num)); i ++) {        if (num % i === 0) {            factors.push(i);            if (num / i !== i) factors.push(num / i)        };    };    factors.numSort();    return factors};// Returns amount of beams for current subdivision (16:2, 32:3, 64:4, etc)function subdToLevel(subd) {    var level = Math.log(subd)/Math.log(2) - 2;    return level;};// Returns current subdivision for amount of beams (2:16, 3:32, 4:64, etc)function levelToSubd(level) {    var subd = Math.pow(2, (level + 2));    return subd;};function clickHeightBySubdLevel(subdLevel) {    var clickHeights = {        "2": 1.75,        "3": 1.618,        "4": 0.618,        "5": 0.618    };    return clickHeights[subdLevel];};function isPrime(n) {   // If n is less than 2 or not an integer then by definition cannot be prime.   if (n < 2) return false   if (n != Math.round(n)) return false   // Now assume that n is prime, we will try to prove that it is not.   var isPrime = true;   // Now check every whole number from 2 to the square root of n.    // If any of these divides n exactly, n cannot be prime.   for (var i = 2; i <= Math.sqrt(n); i++) {      if (n % i == 0) isPrime = false   };   // Finally return whether n is prime or not.   return isPrime;};function clone(obj) {    // Handle the 3 simple types, and null or undefined    if (null == obj || "object" != typeof obj) return obj;    // Handle Date    if (obj instanceof Date) {        var copy = new Date();        copy.setTime(obj.getTime());        return copy;    }    // Handle Array    if (obj instanceof Array) {        var copy = [];        for (var i = 0, len = obj.length; i < len; i++) {            copy[i] = clone(obj[i]);        }        return copy;    }    // Handle Object    if (obj instanceof Object) {        var copy = {};        for (var attr in obj) {            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);        }        return copy;    }    throw new Error("Unable to copy obj! Its type isn't supported.");}function pointInPolygon(point, vertices) {    // point is an array of [x,y] coordinates    // verteces is an [array of [x,y] coordinates]    var x = point[0], y = point[1];    var inside = false;    for (var i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {        var xi = vertices[i][0], yi = vertices[i][1];        var xj = vertices[j][0], yj = vertices[j][1];        var intersect = ((yi > y) != (yj > y))            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);        if (intersect) inside = !inside;    };    return inside;};function axisOverlap(a0, a1, b0, b1) {    return !(a0 > b1 || b0 > a1);};function polygonCollision (shapeA, shapeB) {    // Populate arrays as appropriate    var vertsax = [];    var vertsay = [];    for (var p = 0; p < shapeA.length; p ++) {        vertsax.push(shapeA[p][0]);        vertsay.push(shapeA[p][1]);    };    var vertsbx = [];    var vertsby = [];    for (var p = 0; p < shapeB.length; p ++) {        vertsbx.push(shapeB[p][0]);        vertsby.push(shapeB[p][1]);    };    var alen = vertsax.length;    var blen = vertsbx.length;    // Loop for axes in Shape A    for ( var i = 0, j = alen - 1; i < alen; j = i++ ) {        // Get the axis        var vx =    vertsax[ j ] - vertsax[ i ];        var vy = -( vertsay[ j ] - vertsay[ i ] );        var len = Math.sqrt( vx * vx + vy * vy );        vx /= len;        vy /= len;        // Project shape A        var max0 = vertsax[ 0 ] * vx + vertsay[ 0 ] * vy, min0 = max0;        for ( k = 1; k < alen; k++ ) {            var proja = vertsax[ k ] * vx + vertsay[ k ] * vy;            if ( proja > max0 ) { max0 = proja; }            else if ( proja < min0 ) { min0 = proja; }        }        // Project shape B        var max1 = vertsbx[ 0 ] * vx + vertsby[ 0 ] * vy, min1 = max1;        for ( var k = 1; k < blen; k++ ) {            var projb = vertsbx[ k ] * vx + vertsby[ k ] * vy;            if ( projb > max1 ) { max1 = projb; }            else if ( projb < min1 ) { min1 = projb; };        };        // Test for gaps        if (!axisOverlap( min0, max0, min1, max1 )) return false;    }    // Loop for axes in Shape B (same as above)    for ( var i = 0, j = blen - 1; i < blen; j = i++ ) {        var vx =    vertsbx[ j ] - vertsbx[ i ];        var vy = -( vertsby[ j ] - vertsby[ i ] );        var len = Math.sqrt( vx * vx + vy * vy );        vx /= len;        vy /= len;        var max0 = vertsax[ 0 ] * vx + vertsay[ 0 ] * vy, min0 = max0;        for ( k = 1; k < alen; k++ ) {            var proja = vertsax[ k ] * vx + vertsay[ k ] * vy;            if ( proja > max0 ) { max0 = proja; }            else if ( proja < min0 ) { min0 = proja; };        }        var max1 = vertsbx[ 0 ] * vx + vertsby[ 0 ] * vy, min1 = max1;        for ( var k = 1; k < blen; k++ ) {            var projb = vertsbx[ k ] * vx + vertsby[ k ] * vy;            if ( projb > max1 ) { max1 = projb; }            else if ( projb < min1 ) { min1 = projb; };        }        if (!axisOverlap( min0, max0, min1, max1 )) return false;    }    return true;}